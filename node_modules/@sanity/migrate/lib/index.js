"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __typeError = (msg) => {
  throw TypeError(msg);
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));
var __await = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = !1, method, it = {};
  return obj == null ? (obj = value[__knownSymbol("iterator")](), method = (k) => it[k] = (x) => obj[k](x)) : (obj = obj.call(value), method = (k) => it[k] = (v) => {
    if (isAwait) {
      if (isAwait = !1, k === "throw") throw v;
      return v;
    }
    return isAwait = !0, {
      done: !1,
      value: new __await(new Promise((resolve) => {
        var x = obj[k](v);
        x instanceof Object || __typeError("Object expected"), resolve(x);
      }), 1)
    };
  }), it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
Object.defineProperty(exports, "__esModule", { value: !0 });
var paths = require("@sanity/util/paths"), arrify = require("arrify"), mutate = require("@sanity/mutate"), promises = require("node:fs/promises"), createDebug = require("debug"), FIFO = require("fast-fifo"), createSafeJsonParser = require("@sanity/util/createSafeJsonParser"), groqJs = require("groq-js"), client$1 = require("@sanity/client"), client = require("@sanity/util/client"), node_os = require("node:os"), path = require("node:path");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var arrify__default = /* @__PURE__ */ _interopDefaultCompat(arrify), createDebug__default = /* @__PURE__ */ _interopDefaultCompat(createDebug), FIFO__default = /* @__PURE__ */ _interopDefaultCompat(FIFO), path__default = /* @__PURE__ */ _interopDefaultCompat(path);
function defineMigration(migration) {
  return migration;
}
var __knownSymbol$k = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$h = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$h = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$h, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$k("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$i = (obj, it, method) => (it = obj[__knownSymbol$k("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$k("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function decodeText(it) {
  return __asyncGenerator$h(this, null, function* () {
    const decoder = new TextDecoder();
    try {
      for (var iter = __forAwait$i(it), more, temp, error; more = !(temp = yield new __await$h(iter.next())).done; more = !1) {
        const chunk = temp.value;
        yield decoder.decode(chunk, { stream: !0 });
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$h(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$j = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$g = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$g = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$g, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$j("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$h = (obj, it, method) => (it = obj[__knownSymbol$j("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$j("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function delay(it, ms) {
  return __asyncGenerator$g(this, null, function* () {
    try {
      for (var iter = __forAwait$h(it), more, temp, error; more = !(temp = yield new __await$g(iter.next())).done; more = !1) {
        const chunk = temp.value;
        yield new __await$g(sleep(ms)), yield chunk;
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$g(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$i = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$f = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$f = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$f, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$i("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$g = (obj, it, method) => (it = obj[__knownSymbol$i("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$i("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function filter(it, predicate) {
  return __asyncGenerator$f(this, null, function* () {
    try {
      for (var iter = __forAwait$g(it), more, temp, error; more = !(temp = yield new __await$f(iter.next())).done; more = !1) {
        const chunk = temp.value;
        (yield new __await$f(predicate(chunk))) && (yield chunk);
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$f(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$h = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$e = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$e = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$e, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$h("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$f = (obj, it, method) => (it = obj[__knownSymbol$h("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$h("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function parseJSON(_0) {
  return __asyncGenerator$e(this, arguments, function* (it, { parse: parse2 = JSON.parse } = {}) {
    try {
      for (var iter = __forAwait$f(it), more, temp, error; more = !(temp = yield new __await$e(iter.next())).done; more = !1) {
        const chunk = temp.value;
        yield parse2(chunk);
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$e(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
function stringifyJSON(it) {
  return __asyncGenerator$e(this, null, function* () {
    try {
      for (var iter = __forAwait$f(it), more, temp, error; more = !(temp = yield new __await$e(iter.next())).done; more = !1) {
        const chunk = temp.value;
        yield JSON.stringify(chunk);
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$e(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$g = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$d = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$d = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$d, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$g("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$e = (obj, it, method) => (it = obj[__knownSymbol$g("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$g("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function map(it, project) {
  return __asyncGenerator$d(this, null, function* () {
    try {
      for (var iter = __forAwait$e(it), more, temp, error; more = !(temp = yield new __await$d(iter.next())).done; more = !1) {
        const chunk = temp.value;
        yield project(chunk);
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$d(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$f = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$c = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$c = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$c, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$f("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$d = (obj, it, method) => (it = obj[__knownSymbol$f("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$f("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function split(it, delimiter) {
  return __asyncGenerator$c(this, null, function* () {
    let buf = "";
    try {
      for (var iter = __forAwait$d(it), more, temp, error; more = !(temp = yield new __await$c(iter.next())).done; more = !1) {
        const chunk = temp.value;
        if (buf += chunk, buf.includes(delimiter)) {
          const lastIndex = buf.lastIndexOf(delimiter), parts = buf.slice(0, Math.max(0, lastIndex)).split(delimiter);
          for (const part of parts)
            yield part;
          buf = buf.slice(Math.max(0, lastIndex + delimiter.length));
        }
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$c(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    yield buf;
  });
}
var __knownSymbol$e = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$b = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$b = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$b, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$e("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$c = (obj, it, method) => (it = obj[__knownSymbol$e("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$e("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function parse(it, options) {
  return parseJSON(
    filter(split(it, `
`), (line) => !!(line && line.trim())),
    options
  );
}
function stringify(iterable) {
  return __asyncGenerator$b(this, null, function* () {
    try {
      for (var iter = __forAwait$c(iterable), more, temp, error; more = !(temp = yield new __await$b(iter.next())).done; more = !1) {
        const doc = temp.value;
        yield `${JSON.stringify(doc)}
`;
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$b(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$d = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$a = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$a = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$a, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$d("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$b = (obj, it, method) => (it = obj[__knownSymbol$d("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$d("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function take(it, count) {
  return __asyncGenerator$a(this, null, function* () {
    let i = 0;
    try {
      for (var iter = __forAwait$b(it), more, temp, error; more = !(temp = yield new __await$a(iter.next())).done; more = !1) {
        const chunk = temp.value;
        if (i++ >= count) return;
        yield chunk;
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$a(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$c = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __forAwait$a = (obj, it, method) => (it = obj[__knownSymbol$c("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$c("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
async function toArray(it) {
  const result = [];
  try {
    for (var iter = __forAwait$a(it), more, temp, error; more = !(temp = await iter.next()).done; more = !1) {
      const chunk = temp.value;
      result.push(chunk);
    }
  } catch (temp2) {
    error = [temp2];
  } finally {
    try {
      more && (temp = iter.return) && await temp.call(iter);
    } finally {
      if (error)
        throw error[0];
    }
  }
  return result;
}
var __defProp$6 = Object.defineProperty, __getOwnPropSymbols$4 = Object.getOwnPropertySymbols, __hasOwnProp$4 = Object.prototype.hasOwnProperty, __propIsEnum$4 = Object.prototype.propertyIsEnumerable, __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$4.call(b, prop) && __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b))
      __propIsEnum$4.call(b, prop) && __defNormalProp$6(a, prop, b[prop]);
  return a;
};
function create(document) {
  return { type: "create", document };
}
function patch(id, patches, options) {
  return __spreadValues$4({
    type: "patch",
    id,
    patches: arrify__default.default(patches)
  }, options ? { options } : {});
}
function at(path2, operation) {
  return {
    path: typeof path2 == "string" ? paths.fromString(path2) : path2,
    op: operation
  };
}
function createIfNotExists(document) {
  return { type: "createIfNotExists", document };
}
function createOrReplace(document) {
  return { type: "createOrReplace", document };
}
function delete_(id) {
  return { type: "delete", id };
}
const del = delete_, set = (value) => ({ type: "set", value }), setIfMissing = (value) => ({
  type: "setIfMissing",
  value
}), unset = () => ({ type: "unset" }), inc = (amount = 1) => ({
  type: "inc",
  amount
}), dec = (amount = 1) => ({
  type: "dec",
  amount
}), diffMatchPatch = (value) => ({
  type: "diffMatchPatch",
  value
});
function insert(items, position, indexOrReferenceItem) {
  return {
    type: "insert",
    referenceItem: indexOrReferenceItem,
    position,
    items: arrify__default.default(items)
  };
}
function append(items) {
  return insert(items, "after", -1);
}
function prepend(items) {
  return insert(items, "before", 0);
}
function insertBefore(items, indexOrReferenceItem) {
  return insert(items, "before", indexOrReferenceItem);
}
const insertAfter = (items, indexOrReferenceItem) => insert(items, "after", indexOrReferenceItem);
function truncate(startIndex, endIndex) {
  return {
    type: "truncate",
    startIndex,
    endIndex
  };
}
function replace(items, referenceItem) {
  return {
    type: "replace",
    referenceItem,
    items: arrify__default.default(items)
  };
}
function transaction(idOrMutations, _mutations) {
  const [id, mutations] = typeof idOrMutations == "string" ? [idOrMutations, _mutations] : [void 0, idOrMutations];
  return { type: "transaction", id, mutations };
}
function isMutation(mutation) {
  return mutation !== null && typeof mutation == "object" && "type" in mutation && (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace" || mutation.type === "patch" || mutation.type === "delete");
}
function isTransaction(mutation) {
  return mutation !== null && typeof mutation == "object" && "type" in mutation && mutation.type === "transaction";
}
function isOperation(value) {
  return value !== null && typeof value == "object" && "type" in value && (value.type === "set" || value.type === "unset" || value.type === "insert" || value.type === "diffMatchPatch" || value.type === "dec" || value.type === "inc" || value.type === "upsert" || value.type === "unassign" || value.type === "truncate" || value.type === "setIfMissing");
}
function isNodePatch(change) {
  return change !== null && typeof change == "object" && "path" in change && Array.isArray(change.path) && "op" in change && isOperation(change.op);
}
function getValueType(value) {
  return Array.isArray(value) ? "array" : value === null ? "null" : typeof value;
}
function callMap(mapFn, value, path2) {
  const res = mapFn(value, path2);
  return Array.isArray(res) ? res : [res];
}
function getPathWithKey(item, index, container) {
  return item && Array.isArray(container) && typeof item == "object" && "_key" in item && typeof item._key == "string" ? { _key: item._key } : index;
}
function mapObject(reducerFn, object, path2) {
  return [
    ...callMap(reducerFn, object, path2),
    ...Object.keys(object).flatMap(
      (key) => flatMapAny(reducerFn, object[key], path2.concat(getPathWithKey(object[key], key, object)))
    )
  ];
}
function mapArray(mapFn, array, path2) {
  return [
    ...callMap(mapFn, array, path2),
    ...array.flatMap(
      (item, index) => flatMapAny(mapFn, item, path2.concat(getPathWithKey(item, index, array)))
    )
  ];
}
function flatMapAny(mapFn, val, path2) {
  const type = getValueType(val);
  return type === "object" ? mapObject(mapFn, val, path2) : type === "array" ? mapArray(mapFn, val, path2) : callMap(mapFn, val, path2);
}
function flatMapDeep(value, mapFn) {
  return flatMapAny(mapFn, value, []);
}
var __knownSymbol$b = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$9 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$9 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$9, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$b("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$9 = (obj, it, method) => (it = obj[__knownSymbol$b("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$b("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function normalizeMigrateDefinition(migration) {
  return typeof migration.migrate == "function" ? normalizeIteratorValues(migration.migrate) : createAsyncIterableMutation(migration.migrate, {
    filter: migration.filter,
    documentTypes: migration.documentTypes
  });
}
function normalizeIteratorValues(asyncIterable) {
  return function(docs, context) {
    return __asyncGenerator$9(this, null, function* () {
      try {
        for (var iter = __forAwait$9(asyncIterable(docs, context)), more, temp, error; more = !(temp = yield new __await$9(iter.next())).done; more = !1) {
          const documentMutations = temp.value;
          yield normalizeMutation(documentMutations);
        }
      } catch (temp2) {
        error = [temp2];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await$9(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  };
}
function normalizeMutation(change) {
  return Array.isArray(change) ? change.flatMap((ch) => normalizeMutation(ch)) : isRawMutation(change) ? mutate.SanityEncoder.decodeAll([change]) : [change];
}
function isRawMutation(mutation) {
  return "createIfNotExists" in mutation || "createOrReplace" in mutation || "create" in mutation || "patch" in mutation || "delete" in mutation;
}
function createAsyncIterableMutation(migration, opts) {
  const documentTypesSet = new Set(opts.documentTypes);
  return function(docs, context) {
    return __asyncGenerator$9(this, null, function* () {
      try {
        for (var iter = __forAwait$9(docs()), more, temp, error; more = !(temp = yield new __await$9(iter.next())).done; more = !1) {
          const doc = temp.value;
          if (opts.documentTypes && !documentTypesSet.has(doc._type)) continue;
          const documentMutations = yield new __await$9(collectDocumentMutations(migration, doc, context));
          documentMutations.length > 0 && (yield documentMutations);
        }
      } catch (temp2) {
        error = [temp2];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await$9(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  };
}
async function collectDocumentMutations(migration, doc, context) {
  var _a;
  const documentMutations = Promise.resolve((_a = migration.document) == null ? void 0 : _a.call(migration, doc, context)), nodeMigrations = flatMapDeep(doc, async (value, path2) => {
    var _a2;
    const [nodeReturnValues, nodeTypeReturnValues] = await Promise.all([
      Promise.resolve((_a2 = migration.node) == null ? void 0 : _a2.call(migration, value, path2, context)),
      Promise.resolve(migrateNodeType(migration, value, path2, context))
    ]);
    return [...arrify__default.default(nodeReturnValues), ...arrify__default.default(nodeTypeReturnValues)].map(
      (change) => change && normalizeNodeMutation(path2, change)
    );
  });
  return (await Promise.all([...arrify__default.default(await documentMutations), ...nodeMigrations])).flat().flatMap((change) => change ? normalizeDocumentMutation(doc._id, change) : []);
}
function normalizeDocumentMutation(documentId, change) {
  return Array.isArray(change) ? change.flatMap((ch) => normalizeDocumentMutation(documentId, ch)) : isRawMutation(change) ? mutate.SanityEncoder.decodeAll([change])[0] : isTransaction(change) || isMutation(change) ? change : patch(documentId, change);
}
function normalizeNodeMutation(path2, change) {
  return Array.isArray(change) ? change.flatMap((ch) => normalizeNodeMutation(path2, ch)) : isRawMutation(change) ? mutate.SanityEncoder.decodeAll([change])[0] : isNodePatch(change) ? at(path2.concat(change.path), change.op) : isOperation(change) ? at(path2, change) : change;
}
function migrateNodeType(migration, value, path2, context) {
  var _a, _b, _c, _d, _e, _f;
  switch (getValueType(value)) {
    case "string":
      return (_a = migration.string) == null ? void 0 : _a.call(migration, value, path2, context);
    case "number":
      return (_b = migration.number) == null ? void 0 : _b.call(migration, value, path2, context);
    case "boolean":
      return (_c = migration.boolean) == null ? void 0 : _c.call(migration, value, path2, context);
    case "object":
      return (_d = migration.object) == null ? void 0 : _d.call(migration, value, path2, context);
    case "array":
      return (_e = migration.array) == null ? void 0 : _e.call(migration, value, path2, context);
    case "null":
      return (_f = migration.null) == null ? void 0 : _f.call(migration, value, path2, context);
    default:
      throw new Error("Unknown value type");
  }
}
function wrapDocumentsIteratorProducer(factory) {
  function documents() {
    return factory();
  }
  return documents[Symbol.asyncIterator] = () => {
    throw new Error(
      `The migration is attempting to iterate over the "documents" function, please call the function instead:

      // BAD:
      for await (const document of documents) {
        // ...
      }

      // GOOD:                        \u{1F447} This is a function and has to be called
      for await (const document of documents()) {
        // ...
      }
      `
    );
  }, documents;
}
function collectMigrationMutations(migration, documents, context) {
  return normalizeMigrateDefinition(migration)(wrapDocumentsIteratorProducer(documents), context);
}
const MUTATION_ENDPOINT_MAX_BODY_SIZE = 262144, DEFAULT_MUTATION_CONCURRENCY = 6, MAX_MUTATION_CONCURRENCY = 10;
var baseDebug = createDebug__default.default("sanity:migrate");
const debug$1 = baseDebug.extend("bufferThroughFile"), CHUNK_SIZE$1 = 1024;
function bufferThroughFile(source, filename, options) {
  const signal = options == null ? void 0 : options.signal;
  let writeHandle, readHandle, bufferDone = !1;
  signal == null || signal.addEventListener("abort", async () => {
    debug$1("Aborting bufferThroughFile"), await Promise.all([
      writeHandle && writeHandle.close(),
      readHandle && (await readHandle).close()
    ]);
  });
  let readerCount = 0, ready;
  async function pump(reader) {
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done || signal != null && signal.aborted)
          return;
        await writeHandle.write(value);
      }
    } finally {
      await writeHandle.close(), bufferDone = !0, reader.releaseLock();
    }
  }
  function createBufferedReader() {
    let totalBytesRead = 0;
    return async function tryReadFromBuffer(handle) {
      const { bytesRead, buffer } = await handle.read(
        new Uint8Array(CHUNK_SIZE$1),
        0,
        CHUNK_SIZE$1,
        totalBytesRead
      );
      return bytesRead === 0 && !bufferDone && !(signal != null && signal.aborted) ? (debug$1("Not enough data in buffer file, waiting for more data to be written"), tryReadFromBuffer(handle)) : (totalBytesRead += bytesRead, { bytesRead, buffer });
    };
  }
  function init() {
    return ready || (ready = (async () => {
      debug$1("Initializing bufferThroughFile"), writeHandle = await promises.open(filename, "w"), debug$1("Start buffering source stream to file"), pump(source.getReader()).then(() => {
        debug$1("Buffering source stream to buffer file");
      });
    })()), ready;
  }
  function getReadHandle() {
    return readHandle || (debug$1("Opening read handle on %s", filename), readHandle = promises.open(filename, "r")), readHandle;
  }
  function onReaderStart() {
    readerCount++;
  }
  async function onReaderEnd() {
    if (readerCount--, readerCount === 0 && readHandle) {
      const handle = readHandle;
      readHandle = null, debug$1("Closing read handle on %s", filename), await (await handle).close(), (options == null ? void 0 : options.keepFile) !== !0 && (debug$1("Removing buffer file", filename), await promises.unlink(filename));
    }
  }
  return () => {
    const readChunk = createBufferedReader();
    let didEnd = !1;
    function onEnd() {
      didEnd || (didEnd = !0, onReaderEnd());
    }
    return new ReadableStream({
      async start() {
        if (signal != null && signal.aborted)
          throw new Error("Cannot create new buffered readers on aborted stream");
        debug$1("Reader started reading from file handle"), onReaderStart(), await init(), await getReadHandle();
      },
      async pull(controller) {
        if (!readHandle)
          throw new Error("Cannot read from closed handle");
        const { bytesRead, buffer } = await readChunk(await readHandle);
        bytesRead === 0 && bufferDone ? (debug$1("Reader done reading from file handle"), await onEnd(), controller.close()) : controller.enqueue(buffer.subarray(0, bytesRead));
      },
      cancel() {
        onEnd();
      }
    });
  };
}
const objectToString = Object.prototype.toString, uint8ArrayStringified = "[object Uint8Array]";
function isUint8Array(value) {
  return value ? value.constructor === Uint8Array ? !0 : objectToString.call(value) === uint8ArrayStringified : !1;
}
function assertUint8Array(value) {
  if (!isUint8Array(value))
    throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
}
function concatUint8Arrays(arrays, totalLength) {
  if (arrays.length === 0)
    return new Uint8Array(0);
  totalLength != null || (totalLength = arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0));
  const returnValue = new Uint8Array(totalLength);
  let offset = 0;
  for (const array of arrays)
    assertUint8Array(array), returnValue.set(array, offset), offset += array.length;
  return returnValue;
}
function areUint8ArraysEqual(a, b) {
  if (assertUint8Array(a), assertUint8Array(b), a === b)
    return !0;
  if (a.length !== b.length)
    return !1;
  for (let index = 0; index < a.length; index++)
    if (a[index] !== b[index])
      return !1;
  return !0;
}
function peekInto(readable, options) {
  const { size } = options;
  return new Promise((resolve, reject) => {
    let totalBytesRead = 0, streamCompleted = !1;
    const chunks = [], reader = readable.getReader();
    function settled() {
      const head = concatUint8Arrays(chunks);
      resolve([
        head,
        new ReadableStream({
          start(controller) {
            controller.enqueue(head), streamCompleted && controller.close();
          },
          async pull(controller) {
            const { done, value } = await reader.read();
            done ? controller.close() : controller.enqueue(value);
          }
        })
      ]);
    }
    (async () => {
      for (; ; ) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          streamCompleted = !0;
          break;
        } else if (totalBytesRead += chunk.byteLength, chunks.push(chunk), totalBytesRead >= size)
          break;
      }
    })().then(settled, reject);
  });
}
function isGzip(buffer) {
  return buffer.length > 3 && buffer[0] === 31 && buffer[1] === 139 && buffer[2] === 8;
}
function isDeflate(buf) {
  return buf.length > 2 && buf[0] === 120 && (buf[1] === 1 || buf[1] === 156 || buf[1] === 218);
}
async function maybeDecompress(readable) {
  const [head, stream] = await peekInto(readable, { size: 10 });
  return isGzip(head) ? stream.pipeThrough(new DecompressionStream("gzip")) : isDeflate(head) ? stream.pipeThrough(new DecompressionStream("deflate-raw")) : stream;
}
const debug = baseDebug.extend("readFileAsWebStream"), CHUNK_SIZE = 1024 * 16;
function readFileAsWebStream(filename) {
  let fileHandle, position = 0;
  return new ReadableStream({
    async start() {
      debug("Starting readable stream from", filename), fileHandle = await promises.open(filename, "r");
    },
    async pull(controller) {
      const { bytesRead, buffer } = await fileHandle.read(
        new Uint8Array(CHUNK_SIZE),
        0,
        CHUNK_SIZE,
        position
      );
      bytesRead === 0 ? (await fileHandle.close(), debug("Closing readable stream from", filename), controller.close()) : (position += bytesRead, controller.enqueue(buffer.subarray(0, bytesRead)));
    },
    cancel() {
      return debug("Cancelling readable stream from", filename), fileHandle.close();
    }
  });
}
async function drain(stream) {
  const reader = stream.getReader();
  for (; ; ) {
    const { done } = await reader.read();
    if (done)
      return;
  }
}
var __defProp$5 = Object.defineProperty, __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => __defNormalProp$5(obj, typeof key != "symbol" ? key + "" : key, value);
const EMPTY = new Uint8Array();
class BufferList {
  constructor() {
    __publicField$1(this, "buffered"), __publicField$1(this, "shifted"), __publicField$1(this, "queue"), __publicField$1(this, "_offset"), this.buffered = 0, this.shifted = 0, this.queue = new FIFO__default.default(), this._offset = 0;
  }
  push(buffer) {
    this.buffered += buffer.byteLength, this.queue.push(buffer);
  }
  shiftFirst(size) {
    return this.buffered === 0 ? null : this._next(size);
  }
  shift(size) {
    if (size > this.buffered) return null;
    if (size === 0) return EMPTY;
    let chunk = this._next(size);
    if (size === chunk.byteLength) return chunk;
    const chunks = [chunk];
    for (; (size -= chunk.byteLength) > 0; )
      chunk = this._next(size), chunks.push(chunk);
    return concatUint8Arrays(chunks);
  }
  _next(size) {
    const buf = this.queue.peek(), rem = buf.byteLength - this._offset;
    if (size >= rem) {
      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
      return this.queue.shift(), this._offset = 0, this.buffered -= rem, this.shifted += rem, sub;
    }
    return this.buffered -= size, this.shifted += size, buf.subarray(this._offset, this._offset += size);
  }
}
const ZERO_OFFSET = 48, USTAR_MAGIC = new Uint8Array([117, 115, 116, 97, 114, 0]), GNU_MAGIC = new Uint8Array([117, 115, 116, 97, 114, 32]), GNU_VER = new Uint8Array([32, 0]), MAGIC_OFFSET = 257, VERSION_OFFSET = 263;
function decode(buf, filenameEncoding, allowUnknownFormat) {
  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET, name = decodeStr(buf, 0, 100, filenameEncoding);
  const mode = decodeOct(buf, 100, 8), uid = decodeOct(buf, 108, 8), gid = decodeOct(buf, 116, 8), size = decodeOct(buf, 124, 12), mtime = decodeOct(buf, 136, 12), type = toType(typeflag), linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding), uname = decodeStr(buf, 265, 32), gname = decodeStr(buf, 297, 32), devmajor = decodeOct(buf, 329, 8), devminor = decodeOct(buf, 337, 8), c = cksum(buf);
  if (c === 8 * 32) return null;
  if (c !== decodeOct(buf, 148, 8))
    throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
  if (isUSTAR(buf))
    buf[345] && (name = `${decodeStr(buf, 345, 155, filenameEncoding)}/${name}`);
  else if (!isGNU(buf) && !allowUnknownFormat)
    throw new Error("Invalid tar header: unknown format.");
  return typeflag === 0 && name && name[name.length - 1] === "/" && (typeflag = 5), {
    type,
    name,
    mode,
    uid,
    gid,
    size,
    mtime: mtime ? new Date(1e3 * mtime) : null,
    linkname,
    uname,
    gname,
    devmajor,
    devminor
  };
}
function isUSTAR(buf) {
  return areUint8ArraysEqual(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
}
function isGNU(buf) {
  return areUint8ArraysEqual(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && areUint8ArraysEqual(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
}
function clamp(index, len, defaultValue) {
  return typeof index != "number" ? defaultValue : (index = ~~index, index >= len ? len : index >= 0 || (index += len, index >= 0) ? index : 0);
}
function toType(flag) {
  switch (flag) {
    case 0:
      return "file";
    case 1:
      return "link";
    case 2:
      return "symlink";
    case 3:
      return "character-device";
    case 4:
      return "block-device";
    case 5:
      return "directory";
    case 6:
      return "fifo";
    case 7:
      return "contiguous-file";
    case 72:
      return "pax-header";
    case 55:
      return "pax-global-header";
    case 27:
      return "gnu-long-link-path";
    case 28:
    case 30:
      return "gnu-long-path";
    default:
      return null;
  }
}
function indexOf(block, num, offset, end) {
  for (; offset < end; offset++)
    if (block[offset] === num) return offset;
  return end;
}
function cksum(block) {
  let sum = 256;
  for (let i = 0; i < 148; i++) sum += block[i];
  for (let j = 156; j < 512; j++) sum += block[j];
  return sum;
}
function parse256(buf) {
  let positive;
  if (buf[0] === 128) positive = !0;
  else if (buf[0] === 255) positive = !1;
  else return null;
  const tuple = [];
  let i;
  for (i = buf.length - 1; i > 0; i--) {
    const byte = buf[i];
    positive ? tuple.push(byte) : tuple.push(255 - byte);
  }
  let sum = 0;
  const l = tuple.length;
  for (i = 0; i < l; i++)
    sum += tuple[i] * Math.pow(256, i);
  return positive ? sum : -1 * sum;
}
const decoders = {}, getCachedDecoder = (encoding) => (encoding in decoders || (decoders[encoding] = new TextDecoder(encoding)), decoders[encoding]);
function toString(uint8, encoding = "utf-8") {
  return getCachedDecoder(encoding).decode(uint8);
}
function decodeOct(val, offset, length) {
  if (val = val.subarray(offset, offset + length), offset = 0, val[offset] & 128)
    return parse256(val);
  for (; offset < val.length && val[offset] === 32; ) offset++;
  const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
  for (; offset < end && val[offset] === 0; ) offset++;
  return end === offset ? 0 : parseInt(toString(val.subarray(offset, end)), 8);
}
function decodeStr(val, offset, length, encoding) {
  return toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
}
const emptyReadableStream = () => new ReadableStream({
  pull(controller) {
    controller.close();
  }
});
function untar(stream, options = {}) {
  const buffer = new BufferList(), reader = stream.getReader();
  let readingChunk = !1;
  return new ReadableStream({
    async pull(controller) {
      var _a, _b;
      if (readingChunk)
        return;
      const { done, value } = await reader.read();
      done || buffer.push(value);
      const headerChunk = buffer.shift(512);
      if (!headerChunk)
        throw new Error("Unexpected end of tar file. Expected 512 bytes of headers.");
      const header = decode(
        headerChunk,
        (_a = options.filenameEncoding) != null ? _a : "utf-8",
        (_b = options.allowUnknownFormat) != null ? _b : !1
      );
      header ? header.size === null || header.size === 0 || header.type === "directory" ? controller.enqueue([header, emptyReadableStream()]) : (readingChunk = !0, controller.enqueue([
        header,
        entryStream(reader, header.size, buffer, () => {
          readingChunk = !1;
        })
      ])) : done && controller.close();
    }
  });
}
function entryStream(reader, expectedBytes, buffer, next) {
  let totalBytesRead = 0;
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await reader.read(), remaining = expectedBytes - totalBytesRead;
      done || buffer.push(value);
      const chunk = buffer.shiftFirst(remaining);
      if (!chunk)
        throw new Error("Premature end of tar stream");
      controller.enqueue(chunk), totalBytesRead += chunk.byteLength, (chunk == null ? void 0 : chunk.byteLength) === remaining && (discardPadding(buffer, expectedBytes), controller.close(), next());
    }
  });
}
function getPadding(size) {
  return size &= 511, size === 0 ? 0 : 512 - size;
}
function discardPadding(bl, size) {
  const overflow = getPadding(size);
  overflow > 0 && bl.shift(overflow);
}
var __knownSymbol$a = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$8 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$8 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$8, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$a("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
function streamToAsyncIterator(stream) {
  return __asyncGenerator$8(this, null, function* () {
    const reader = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = yield new __await$8(reader.read());
        if (done) return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  });
}
var __knownSymbol$9 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$7 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$7 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$7, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$9("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$8 = (obj, it, method) => (it = obj[__knownSymbol$9("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$9("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function fromExportArchive(path2) {
  return __asyncGenerator$7(this, null, function* () {
    try {
      for (var iter2 = __forAwait$8(streamToAsyncIterator(
        untar(yield new __await$7(maybeDecompress(readFileAsWebStream(path2))))
      )), more2, temp2, error2; more2 = !(temp2 = yield new __await$7(iter2.next())).done; more2 = !1) {
        const [header, entry] = temp2.value;
        if (header.type === "file" && header.name.endsWith(".ndjson"))
          try {
            for (var iter = __forAwait$8(streamToAsyncIterator(entry)), more, temp, error; more = !(temp = yield new __await$7(iter.next())).done; more = !1)
              yield temp.value;
          } catch (temp3) {
            error = [temp3];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await$7(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        else
          yield new __await$7(drain(entry));
      }
    } catch (temp22) {
      error2 = [temp22];
    } finally {
      try {
        more2 && (temp2 = iter2.return) && (yield new __await$7(temp2.call(iter2)));
      } finally {
        if (error2)
          throw error2[0];
      }
    }
  });
}
const endpoints = {
  users: {
    me: () => ({
      global: !0,
      path: "/users/me",
      method: "GET",
      searchParams: []
    })
  },
  data: {
    query: (dataset) => ({
      global: !1,
      method: "GET",
      path: `/query/${dataset}`,
      searchParams: []
    }),
    export: (dataset, documentTypes) => ({
      global: !1,
      method: "GET",
      path: `/data/export/${dataset}`,
      searchParams: documentTypes && (documentTypes == null ? void 0 : documentTypes.length) > 0 ? [["types", documentTypes.join(",")]] : []
    }),
    mutate: (dataset, options) => {
      const params = [
        (options == null ? void 0 : options.tag) && ["tag", options.tag],
        (options == null ? void 0 : options.returnIds) && ["returnIds", "true"],
        (options == null ? void 0 : options.returnDocuments) && ["returnDocuments", "true"],
        (options == null ? void 0 : options.autoGenerateArrayKeys) && ["autoGenerateArrayKeys", "true"],
        (options == null ? void 0 : options.visibility) && ["visibility", options.visibility],
        (options == null ? void 0 : options.dryRun) && ["dryRun", "true"]
      ].filter(Boolean);
      return {
        global: !1,
        method: "POST",
        path: `/data/mutate/${dataset}`,
        searchParams: params
      };
    }
  }
};
var __defProp$4 = Object.defineProperty, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp$4(obj, key + "", value);
class HTTPError extends Error {
  constructor(statusCode, message) {
    super(message), __publicField(this, "statusCode"), this.name = "HTTPError", this.statusCode = statusCode;
  }
}
async function assert2xx(res) {
  var _a, _b;
  if (res.status < 200 || res.status > 299) {
    const jsonResponse = await res.json().catch(() => null);
    let message;
    throw jsonResponse != null && jsonResponse.error ? (_a = jsonResponse == null ? void 0 : jsonResponse.error) != null && _a.description ? message = `${((_b = jsonResponse == null ? void 0 : jsonResponse.error) == null ? void 0 : _b.type) || res.status}: ${jsonResponse.error.description}` : message = `${jsonResponse.error}: ${jsonResponse.message}` : message = `HTTP Error ${res.status}: ${res.statusText}`, new HTTPError(res.status, message);
  }
}
async function fetchStream({ url, init }) {
  const response = await fetch(url, init);
  if (await assert2xx(response), response.body === null) throw new Error("No response received");
  return response.body;
}
async function fetchAsyncIterator(options) {
  return streamToAsyncIterator(await fetchStream(options));
}
var __defProp$3 = Object.defineProperty, __defProps$3 = Object.defineProperties, __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$3 = Object.getOwnPropertySymbols, __hasOwnProp$3 = Object.prototype.hasOwnProperty, __propIsEnum$3 = Object.prototype.propertyIsEnumerable, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b))
      __propIsEnum$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  return a;
}, __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
function getUserAgent() {
  if (typeof window > "u")
    try {
      const pkg = require("../../package.json");
      return `${pkg.name}@${pkg.version}`;
    } catch (err) {
    }
  return null;
}
function normalizeApiHost(apiHost) {
  return apiHost.replace(/^https?:\/\//, "");
}
function toFetchOptions(req) {
  const { endpoint, apiVersion, tag, projectId, apiHost, token, body } = req, requestInit = {
    method: endpoint.method || "GET",
    headers: {
      "Content-Type": "application/json"
    },
    body
  }, ua = getUserAgent();
  ua && (requestInit.headers = __spreadProps$3(__spreadValues$3({}, requestInit.headers), {
    "User-Agent": ua
  })), token && (requestInit.headers = __spreadProps$3(__spreadValues$3({}, requestInit.headers), {
    Authorization: `bearer ${token}`
  }));
  const normalizedApiHost = normalizeApiHost(apiHost), path2 = `/${apiVersion}${endpoint.path}`, host = endpoint.global ? normalizedApiHost : `${projectId}.${normalizedApiHost}`, searchParams = new URLSearchParams([
    ...endpoint.searchParams,
    ...tag ? [["tag", tag]] : []
  ]).toString();
  return {
    url: `https://${host}/${path2}${searchParams ? `?${searchParams}` : ""}`,
    init: requestInit
  };
}
function fromExportEndpoint(options) {
  var _a;
  return fetchStream(
    toFetchOptions({
      projectId: options.projectId,
      apiVersion: options.apiVersion,
      token: options.token,
      apiHost: (_a = options.apiHost) != null ? _a : "api.sanity.io",
      tag: "sanity.migration.export",
      endpoint: endpoints.data.export(options.dataset, options.documentTypes)
    })
  );
}
const safeJsonParser = createSafeJsonParser.createSafeJsonParser({
  errorLabel: "Error streaming dataset"
});
function asyncIterableToStream(it) {
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await it.next();
      done ? controller.close() : controller.enqueue(value);
    }
  });
}
var __knownSymbol$8 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$6 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$6 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$6, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$8("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$7 = (obj, it, method) => (it = obj[__knownSymbol$8("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$8("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function isSystemDocumentId(id) {
  return id.startsWith("_.");
}
function parseGroqFilter(filter2) {
  try {
    return groqJs.parse(`*[${filter2}]`);
  } catch (err) {
    throw err.message = `Failed to parse GROQ filter "${filter2}": ${err.message}`, err;
  }
}
async function matchesFilter(parsedFilter, document) {
  return (await (await groqJs.evaluate(parsedFilter, { dataset: [document] })).get()).length === 1;
}
function applyFilters(migration, documents) {
  return __asyncGenerator$6(this, null, function* () {
    const documentTypes = migration.documentTypes, parsedFilter = migration.filter ? parseGroqFilter(migration.filter) : void 0;
    try {
      for (var iter = __forAwait$7(documents), more, temp, error; more = !(temp = yield new __await$6(iter.next())).done; more = !1) {
        const doc = temp.value;
        isSystemDocumentId(doc._id) || documentTypes && documentTypes.length > 0 && !documentTypes.includes(doc._type) || parsedFilter && !(yield new __await$6(matchesFilter(parsedFilter, doc))) || (yield doc);
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$6(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
const MAX_FETCH_CONCURRENCY = 10, limitClientConcurrency = client.createClientConcurrencyLimiter(MAX_FETCH_CONCURRENCY);
var __defProp$2 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b))
      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  return a;
}, __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
function createContextClient(config) {
  return restrictClient(
    limitClientConcurrency(
      client$1.createClient(__spreadProps$2(__spreadValues$2({}, config), { useCdn: !1, requestTagPrefix: "sanity.migration" }))
    )
  );
}
const ALLOWED_PROPERTIES = [
  "fetch",
  "clone",
  "config",
  "withConfig",
  "getDocument",
  "getDocuments",
  "users",
  "projects"
];
function restrictClient(client2) {
  return new Proxy(client2, {
    get: (target, property) => {
      switch (property) {
        case "clone":
          return (...args) => restrictClient(target.clone(...args));
        case "config":
          return (...args) => {
            const result = target.config(...args);
            return args[0] ? restrictClient(result) : result;
          };
        case "withConfig":
          return (...args) => restrictClient(target.withConfig(...args));
        default: {
          if (ALLOWED_PROPERTIES.includes(property))
            return target[property];
          throw new Error(
            `Client method "${String(
              property
            )}" can not be called during a migration. Only ${ALLOWED_PROPERTIES.join(
              ", "
            )} are allowed.`
          );
        }
      }
    }
  });
}
var __knownSymbol$7 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __forAwait$6 = (obj, it, method) => (it = obj[__knownSymbol$7("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$7("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function createFilteredDocumentsClient(getFilteredDocumentsReadableStream) {
  function getAllDocumentsFromBuffer() {
    return parse(decodeText(streamToAsyncIterator(getFilteredDocumentsReadableStream())), {
      parse: safeJsonParser
    });
  }
  async function getDocumentsFromBuffer(ids) {
    const found = {};
    let remaining = ids.length;
    try {
      for (var iter = __forAwait$6(getAllDocumentsFromBuffer()), more, temp, error; more = !(temp = await iter.next()).done; more = !1) {
        const doc = temp.value;
        if (ids.includes(doc._id) && (remaining--, found[doc._id] = doc), remaining === 0) break;
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && await temp.call(iter);
      } finally {
        if (error)
          throw error[0];
      }
    }
    return ids.map((id) => found[id]);
  }
  async function getDocumentFromBuffer(id) {
    return (await getDocumentsFromBuffer([id]))[0];
  }
  return {
    getDocument: getDocumentFromBuffer,
    getDocuments: getDocumentsFromBuffer
  };
}
async function createBufferFile() {
  const bufferDir = path__default.default.join(
    node_os.tmpdir(),
    "sanity-migrate",
    `${Date.now()}-${Math.random().toString(36).slice(2)}`
  );
  return await promises.mkdir(bufferDir, { recursive: !0 }), path__default.default.join(bufferDir, "snapshot.ndjson");
}
var __defProp$1 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __knownSymbol$6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __typeError2 = (msg) => {
  throw TypeError(msg);
}, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b))
      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  return a;
}, __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b)), __await$5 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$5 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$5, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$6("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __yieldStar2 = (value) => {
  var obj = value[__knownSymbol$6("asyncIterator")], isAwait = !1, method, it = {};
  return obj == null ? (obj = value[__knownSymbol$6("iterator")](), method = (k) => it[k] = (x) => obj[k](x)) : (obj = obj.call(value), method = (k) => it[k] = (v) => {
    if (isAwait) {
      if (isAwait = !1, k === "throw") throw v;
      return v;
    }
    return isAwait = !0, {
      done: !1,
      value: new __await$5(new Promise((resolve) => {
        var x = obj[k](v);
        x instanceof Object || __typeError2("Object expected"), resolve(x);
      }), 1)
    };
  }), it[__knownSymbol$6("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
function dryRun(config, migration) {
  return __asyncGenerator$5(this, null, function* () {
    const source = config.exportPath ? fromExportArchive(config.exportPath) : streamToAsyncIterator(
      yield new __await$5(fromExportEndpoint(__spreadProps$1(__spreadValues$1({}, config.api), { documentTypes: migration.documentTypes })))
    ), filteredDocuments = applyFilters(
      migration,
      parse(decodeText(source), { parse: safeJsonParser })
    ), abortController = new AbortController(), createReader = bufferThroughFile(
      asyncIterableToStream(stringify(filteredDocuments)),
      yield new __await$5(createBufferFile()),
      { signal: abortController.signal }
    ), client2 = createContextClient(__spreadProps$1(__spreadValues$1({}, config.api), { useCdn: !1 })), filteredDocumentsClient = createFilteredDocumentsClient(createReader);
    yield* __yieldStar(__yieldStar2(collectMigrationMutations(
      migration,
      () => parse(decodeText(streamToAsyncIterator(createReader())), { parse: safeJsonParser }),
      {
        client: client2,
        filtered: filteredDocumentsClient,
        dryRun: !0
      }
    ))), abortController.abort();
  });
}
var __knownSymbol$5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$4 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$4 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$4, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$5("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$5 = (obj, it, method) => (it = obj[__knownSymbol$5("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$5("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function concatStr(it) {
  return __asyncGenerator$4(this, null, function* () {
    let buf = "";
    try {
      for (var iter = __forAwait$5(it), more, temp, error; more = !(temp = yield new __await$4(iter.next())).done; more = !1) {
        const chunk = temp.value;
        buf += chunk;
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$4(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    yield buf;
  });
}
var __knownSymbol$4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __forAwait$4 = (obj, it, method) => (it = obj[__knownSymbol$4("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$4("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
async function lastValueFrom(it, options) {
  const defaultGiven = "defaultValue" in {};
  let latestValue, didYield = !1;
  try {
    for (var iter = __forAwait$4(it), more, temp, error; more = !(temp = await iter.next()).done; more = !1) {
      const value = temp.value;
      didYield = !0, latestValue = value;
    }
  } catch (temp2) {
    error = [temp2];
  } finally {
    try {
      more && (temp = iter.return) && await temp.call(iter);
    } finally {
      if (error)
        throw error[0];
    }
  }
  if (!didYield) {
    if (defaultGiven)
      return options.defaultValue;
    throw new Error(
      "No value yielded from async iterable. If this iterable is empty, provide a default value."
    );
  }
  return latestValue;
}
async function mapAsync(it, project, concurrency) {
  const { pMapIterable } = await import("p-map");
  return pMapIterable(it, (v) => project(v), {
    concurrency
  });
}
var __knownSymbol$3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$3 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$3 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$3, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$3("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$3 = (obj, it, method) => (it = obj[__knownSymbol$3("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$3("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function tap(it, interceptor) {
  return __asyncGenerator$3(this, null, function* () {
    try {
      for (var iter = __forAwait$3(it), more, temp, error; more = !(temp = yield new __await$3(iter.next())).done; more = !1) {
        const chunk = temp.value;
        interceptor(chunk), yield chunk;
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$3(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __knownSymbol$2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$2 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$2 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$2, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$2("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$2 = (obj, it, method) => (it = obj[__knownSymbol$2("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$2("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
const PADDING_SIZE = 16;
function isTransactionPayload(payload) {
  return payload && payload.mutations && Array.isArray(payload.mutations);
}
function batchMutations(mutations, maxBatchSize) {
  return __asyncGenerator$2(this, null, function* () {
    let currentBatch = [], currentBatchSize = 0;
    try {
      for (var iter = __forAwait$2(mutations), more, temp, error; more = !(temp = yield new __await$2(iter.next())).done; more = !1) {
        const mutation = temp.value;
        if (isTransactionPayload(mutation)) {
          yield { mutations: currentBatch }, yield mutation, currentBatch = [], currentBatchSize = 0;
          continue;
        }
        const mutationSize = JSON.stringify(mutation).length;
        if (mutationSize >= maxBatchSize + PADDING_SIZE) {
          currentBatch.length && (yield { mutations: currentBatch }), yield { mutations: [...arrify__default.default(mutation)] }, currentBatch = [], currentBatchSize = 0;
          continue;
        }
        currentBatchSize += mutationSize, currentBatchSize >= maxBatchSize + PADDING_SIZE && (yield { mutations: currentBatch }, currentBatch = [], currentBatchSize = 0), currentBatch.push(...arrify__default.default(mutation));
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$2(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    currentBatch.length > 0 && (yield { mutations: currentBatch });
  });
}
var __knownSymbol$1 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __await$1 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator$1 = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await$1, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol$1("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait$1 = (obj, it, method) => (it = obj[__knownSymbol$1("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol$1("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function toSanityMutations(it) {
  return __asyncGenerator$1(this, null, function* () {
    try {
      for (var iter = __forAwait$1(it), more, temp, error; more = !(temp = yield new __await$1(iter.next())).done; more = !1) {
        const mutation = temp.value;
        for (const mut of arrify__default.default(mutation)) {
          if (isTransaction(mut)) {
            yield {
              transactionId: mut.id,
              mutations: mutate.SanityEncoder.encodeAll(mut.mutations)
            };
            continue;
          }
          yield mutate.SanityEncoder.encodeAll(arrify__default.default(mut));
        }
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await$1(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var __defProp2 = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp2 = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name), __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp2.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b)), __await2 = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
}, __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await2, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol2("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
}, __forAwait = (obj, it, method) => (it = obj[__knownSymbol2("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol2("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
function toFetchOptionsIterable(apiConfig, mutations) {
  return __asyncGenerator(this, null, function* () {
    var _a;
    try {
      for (var iter = __forAwait(mutations), more, temp, error; more = !(temp = yield new __await2(iter.next())).done; more = !1) {
        const transaction2 = temp.value;
        yield toFetchOptions({
          projectId: apiConfig.projectId,
          apiVersion: apiConfig.apiVersion,
          token: apiConfig.token,
          tag: "sanity.migration.mutate",
          apiHost: (_a = apiConfig.apiHost) != null ? _a : "api.sanity.io",
          endpoint: endpoints.data.mutate(apiConfig.dataset, {
            returnIds: !0,
            visibility: "async",
            autoGenerateArrayKeys: !0
          }),
          body: JSON.stringify(transaction2)
        });
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await2(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
async function run(config, migration) {
  var _a, _b, _c;
  const stats = {
    documents: 0,
    mutations: 0,
    pending: 0,
    queuedBatches: 0,
    completedTransactions: [],
    currentTransactions: []
  }, filteredDocuments = applyFilters(
    migration,
    parse(
      decodeText(
        streamToAsyncIterator(
          await fromExportEndpoint(__spreadProps(__spreadValues({}, config.api), { documentTypes: migration.documentTypes }))
        )
      ),
      { parse: safeJsonParser }
    )
  ), abortController = new AbortController(), createReader = bufferThroughFile(
    asyncIterableToStream(stringify(filteredDocuments)),
    await createBufferFile(),
    { signal: abortController.signal }
  ), client2 = createContextClient(__spreadProps(__spreadValues({}, config.api), {
    useCdn: !1,
    requestTagPrefix: "sanity.migration"
  })), filteredDocumentsClient = createFilteredDocumentsClient(createReader), mutations = tap(collectMigrationMutations(migration, () => tap(
    parse(decodeText(streamToAsyncIterator(createReader())), {
      parse: safeJsonParser
    }),
    () => {
      var _a2;
      (_a2 = config.onProgress) == null || _a2.call(config, __spreadProps(__spreadValues({}, stats), { documents: ++stats.documents }));
    }
  ), {
    client: client2,
    filtered: filteredDocumentsClient,
    dryRun: !1
  }), (muts) => {
    var _a2;
    stats.currentTransactions = arrify__default.default(muts), (_a2 = config.onProgress) == null || _a2.call(config, __spreadProps(__spreadValues({}, stats), {
      mutations: ++stats.mutations
    }));
  }), concurrency = (_a = config == null ? void 0 : config.concurrency) != null ? _a : DEFAULT_MUTATION_CONCURRENCY;
  if (concurrency > MAX_MUTATION_CONCURRENCY)
    throw new Error(`Concurrency exceeds maximum allowed value (${MAX_MUTATION_CONCURRENCY})`);
  const batches = tap(
    batchMutations(toSanityMutations(mutations), MUTATION_ENDPOINT_MAX_BODY_SIZE),
    () => {
      var _a2;
      (_a2 = config.onProgress) == null || _a2.call(config, __spreadProps(__spreadValues({}, stats), { queuedBatches: ++stats.queuedBatches }));
    }
  ), submit = async (opts) => lastValueFrom(parseJSON(concatStr(decodeText(await fetchAsyncIterator(opts))))), commits = await mapAsync(
    toFetchOptionsIterable(config.api, batches),
    (opts) => {
      var _a2;
      return (_a2 = config.onProgress) == null || _a2.call(config, __spreadProps(__spreadValues({}, stats), { pending: ++stats.pending })), submit(opts);
    },
    concurrency
  );
  try {
    for (var iter = __forAwait(commits), more, temp, error; more = !(temp = await iter.next()).done; more = !1) {
      const result = temp.value;
      stats.completedTransactions.push(result), (_b = config.onProgress) == null || _b.call(config, __spreadValues({}, stats));
    }
  } catch (temp2) {
    error = [temp2];
  } finally {
    try {
      more && (temp = iter.return) && await temp.call(iter);
    } finally {
      if (error)
        throw error[0];
    }
  }
  (_c = config.onProgress) == null || _c.call(config, __spreadProps(__spreadValues({}, stats), {
    done: !0
  })), abortController.abort();
}
function* fromDocuments(documents) {
  for (const document of documents)
    yield document;
}
exports.DEFAULT_MUTATION_CONCURRENCY = DEFAULT_MUTATION_CONCURRENCY;
exports.MAX_MUTATION_CONCURRENCY = MAX_MUTATION_CONCURRENCY;
exports.append = append;
exports.at = at;
exports.collectMigrationMutations = collectMigrationMutations;
exports.create = create;
exports.createIfNotExists = createIfNotExists;
exports.createOrReplace = createOrReplace;
exports.dec = dec;
exports.decodeText = decodeText;
exports.defineMigration = defineMigration;
exports.del = del;
exports.delay = delay;
exports.delete_ = delete_;
exports.diffMatchPatch = diffMatchPatch;
exports.dryRun = dryRun;
exports.filter = filter;
exports.fromDocuments = fromDocuments;
exports.fromExportArchive = fromExportArchive;
exports.fromExportEndpoint = fromExportEndpoint;
exports.inc = inc;
exports.insert = insert;
exports.insertAfter = insertAfter;
exports.insertBefore = insertBefore;
exports.map = map;
exports.parse = parse;
exports.parseJSON = parseJSON;
exports.patch = patch;
exports.prepend = prepend;
exports.replace = replace;
exports.run = run;
exports.safeJsonParser = safeJsonParser;
exports.set = set;
exports.setIfMissing = setIfMissing;
exports.split = split;
exports.stringify = stringify;
exports.stringifyJSON = stringifyJSON;
exports.take = take;
exports.toArray = toArray;
exports.toFetchOptionsIterable = toFetchOptionsIterable;
exports.transaction = transaction;
exports.truncate = truncate;
exports.unset = unset;
//# sourceMappingURL=index.js.map
