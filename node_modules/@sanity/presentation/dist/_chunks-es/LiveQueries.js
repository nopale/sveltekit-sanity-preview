import { jsx, Fragment } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { createCompatibilityActors, getQueryCacheKey } from "./PresentationToolGrantsCheck.js";
import { useQueryParams, useRevalidate } from "./hooks.js";
import { createClient } from "@sanity/client";
import { applySourceDocuments, getPublishedId } from "@sanity/client/csm";
import { createConnectionMachine } from "@sanity/comlink";
import isEqual from "fast-deep-equal";
import { useState, useEffect, useMemo, useDeferredValue, memo } from "react";
import { useProjectId, useDataset, useClient } from "sanity";
import { useEffectEvent } from "use-effect-event";
import { MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL } from "./index.js";
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function LoaderQueries(props) {
  const {
    liveDocument: _liveDocument,
    controller,
    perspective: activePerspective,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink, setComlink] = useState(), [liveQueries, setLiveQueries] = useState({}), projectId = useProjectId(), dataset = useDataset();
  useEffect(() => {
    const interval = setInterval(() => setLiveQueries((liveQueries_0) => {
      if (Object.keys(liveQueries_0).length < 1)
        return liveQueries_0;
      const now = Date.now();
      if (!Object.values(liveQueries_0).some((liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat))
        return liveQueries_0;
      const next = {};
      for (const [key, value] of Object.entries(liveQueries_0))
        value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
      return next;
    }), MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL);
    return () => clearInterval(interval);
  }, []), useEffect(() => {
    if (controller) {
      const comlink_0 = controller.createChannel({
        name: "presentation",
        connectTo: "loaders",
        heartbeat: !0
      }, createConnectionMachine().provide({
        actors: createCompatibilityActors()
      }));
      return setComlink(comlink_0), comlink_0.onStatus(onLoadersConnection), comlink_0.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink_0.on("loader/query-listen", (data_0) => {
        if (data_0.projectId === projectId && data_0.dataset === dataset) {
          if (typeof data_0.heartbeat == "number" && data_0.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(`Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`);
          setLiveQueries((prev) => {
            var _a;
            return __spreadProps(__spreadValues({}, prev), {
              [getQueryCacheKey(data_0.query, data_0.params)]: {
                perspective: data_0.perspective,
                query: data_0.query,
                params: data_0.params,
                receivedAt: Date.now(),
                heartbeat: (_a = data_0.heartbeat) != null ? _a : !1
              }
            });
          });
        }
      }), comlink_0.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [syncTagsInUse] = useState(() => /* @__PURE__ */ new Set()), [lastLiveEventId, setLastLiveEventId] = useState(null), studioClient = useClient({
    apiVersion: "2023-10-16"
  }), clientConfig = useMemo(() => studioClient.config(), [studioClient]), client = useMemo(() => studioClient.withConfig({
    resultSourceMap: "withKeyArraySelector"
  }), [studioClient]);
  useEffect(() => {
    if (comlink) {
      const {
        projectId: projectId_0,
        dataset: dataset_0
      } = clientConfig;
      comlink.post("loader/perspective", {
        projectId: projectId_0,
        dataset: dataset_0,
        perspective: activePerspective
      });
    }
  }, [comlink, clientConfig, activePerspective]);
  const handleSyncTags = useEffectEvent((event) => {
    const flattenedSyncTags = Array.from(syncTagsInUse).flat();
    event.tags.some((tag) => flattenedSyncTags.includes(tag)) ? setLastLiveEventId(event.id) : console.log("No matching tags found", event.tags, {
      flattenedSyncTags
    });
  });
  useEffect(() => {
    const subscription = createClient(client.config()).withConfig({
      // Necessary for the live drafts to work
      apiVersion: "vX"
    }).live.events({
      includeDrafts: !0,
      tag: "presentation-loader"
    }).subscribe({
      next: (event_0) => {
        event_0.type === "message" ? handleSyncTags(event_0) : event_0.type === "restart" ? setLastLiveEventId(event_0.id) : event_0.type === "reconnect" && setLastLiveEventId(null);
      },
      // eslint-disable-next-line no-console
      error: (err) => console.error("Error validating EventSource URL:", err)
    });
    return () => subscription.unsubscribe();
  }, [client, handleSyncTags]);
  const liveDocument = useDeferredValue(_liveDocument);
  return /* @__PURE__ */ jsx(Fragment, { children: Object.entries(liveQueries).map(([key_0, {
    query,
    params,
    perspective
  }]) => /* @__PURE__ */ jsx(QuerySubscription, { projectId: clientConfig.projectId, dataset: clientConfig.dataset, perspective, query, params, comlink, client, liveDocument, lastLiveEventId, syncTagsInUse }, `${key_0}${perspective}`)) });
}
function QuerySubscriptionComponent(props) {
  const $ = c(14), {
    projectId,
    dataset,
    perspective,
    query,
    client,
    liveDocument,
    comlink,
    lastLiveEventId,
    syncTagsInUse
  } = props, params = useQueryParams(props.params), {
    result,
    resultSourceMap,
    syncTags: tags
  } = useQuerySubscription({
    client,
    liveDocument,
    params,
    perspective,
    query,
    lastLiveEventId
  }) || {};
  let t0;
  $[0] !== dataset || $[1] !== projectId ? (t0 = (comlink_0, perspective_0, query_0, params_0, result_0, resultSourceMap_0, tags_0) => {
    comlink_0 == null || comlink_0.post("loader/query-change", {
      projectId,
      dataset,
      perspective: perspective_0,
      query: query_0,
      params: params_0,
      result: result_0,
      resultSourceMap: resultSourceMap_0,
      tags: tags_0
    });
  }, $[0] = dataset, $[1] = projectId, $[2] = t0) : t0 = $[2];
  const handleQueryChange = useEffectEvent(t0);
  let t1, t2;
  return $[3] !== comlink || $[4] !== handleQueryChange || $[5] !== params || $[6] !== perspective || $[7] !== query || $[8] !== result || $[9] !== resultSourceMap || $[10] !== syncTagsInUse || $[11] !== tags ? (t1 = () => {
    if (resultSourceMap && handleQueryChange(comlink, perspective, query, params, result, resultSourceMap, tags), Array.isArray(tags))
      return syncTagsInUse.add(tags), () => {
        syncTagsInUse.delete(tags);
      };
  }, t2 = [comlink, handleQueryChange, params, perspective, query, result, resultSourceMap, syncTagsInUse, tags], $[3] = comlink, $[4] = handleQueryChange, $[5] = params, $[6] = perspective, $[7] = query, $[8] = result, $[9] = resultSourceMap, $[10] = syncTagsInUse, $[11] = tags, $[12] = t1, $[13] = t2) : (t1 = $[12], t2 = $[13]), useEffect(t1, t2), null;
}
const QuerySubscription = memo(QuerySubscriptionComponent);
QuerySubscription.displayName = "Memo(QuerySubscription)";
function useQuerySubscription(props) {
  const $ = c(25), {
    liveDocument,
    client,
    query,
    params,
    perspective,
    lastLiveEventId
  } = props, [snapshot, setSnapshot] = useState(null), [error, setError] = useState(null);
  if (error)
    throw error;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    refreshInterval: 0
  }, $[0] = t0) : t0 = $[0];
  const [revalidate, startRefresh] = useRevalidate(t0), shouldRefetch = revalidate === "refresh" || revalidate === "inflight" || lastLiveEventId !== (snapshot == null ? void 0 : snapshot.lastLiveEventId);
  let t1, t2;
  $[1] !== client || $[2] !== lastLiveEventId || $[3] !== params || $[4] !== perspective || $[5] !== query || $[6] !== shouldRefetch || $[7] !== startRefresh ? (t1 = () => {
    if (!shouldRefetch)
      return;
    let fulfilled;
    fulfilled = !1;
    let fetching;
    fetching = !1;
    const controller = new AbortController(), effect = async function() {
      const {
        signal
      } = controller;
      fetching = !0;
      const {
        result,
        resultSourceMap,
        syncTags
      } = await client.fetch(query, params, {
        lastLiveEventId,
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1,
        returnQuery: !1
      });
      fetching = !1, signal.aborted || (setSnapshot((prev) => ({
        result: isEqual(prev == null ? void 0 : prev.result, result) ? prev == null ? void 0 : prev.result : result,
        resultSourceMap: isEqual(prev == null ? void 0 : prev.resultSourceMap, resultSourceMap) ? prev == null ? void 0 : prev.resultSourceMap : resultSourceMap,
        syncTags: isEqual(prev == null ? void 0 : prev.syncTags, syncTags) ? prev == null ? void 0 : prev.syncTags : syncTags,
        lastLiveEventId
      })), fulfilled = !0);
    }, onFinally = startRefresh();
    return effect().catch((error_0) => {
      fetching = !1, error_0.name !== "AbortError" && setError(error_0);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, t2 = [client, lastLiveEventId, params, perspective, query, shouldRefetch, startRefresh], $[1] = client, $[2] = lastLiveEventId, $[3] = params, $[4] = perspective, $[5] = query, $[6] = shouldRefetch, $[7] = startRefresh, $[8] = t1, $[9] = t2) : (t1 = $[8], t2 = $[9]), useEffect(t1, t2);
  let t3;
  $[10] !== snapshot ? (t3 = snapshot != null ? snapshot : {}, $[10] = snapshot, $[11] = t3) : t3 = $[11];
  const {
    result: result_0,
    resultSourceMap: resultSourceMap_0,
    syncTags: syncTags_0
  } = t3;
  let t4;
  bb0: {
    if (liveDocument && resultSourceMap_0) {
      let t52;
      $[12] !== liveDocument || $[13] !== perspective || $[14] !== resultSourceMap_0 || $[15] !== result_0 ? (t52 = turboChargeResultIfSourceMap(liveDocument, result_0, perspective, resultSourceMap_0), $[12] = liveDocument, $[13] = perspective, $[14] = resultSourceMap_0, $[15] = result_0, $[16] = t52) : t52 = $[16];
      let t6;
      $[17] !== resultSourceMap_0 || $[18] !== syncTags_0 || $[19] !== t52 ? (t6 = {
        result: t52,
        resultSourceMap: resultSourceMap_0,
        syncTags: syncTags_0
      }, $[17] = resultSourceMap_0, $[18] = syncTags_0, $[19] = t52, $[20] = t6) : t6 = $[20], t4 = t6;
      break bb0;
    }
    let t5;
    $[21] !== resultSourceMap_0 || $[22] !== result_0 || $[23] !== syncTags_0 ? (t5 = {
      result: result_0,
      resultSourceMap: resultSourceMap_0,
      syncTags: syncTags_0
    }, $[21] = resultSourceMap_0, $[22] = result_0, $[23] = syncTags_0, $[24] = t5) : t5 = $[24], t4 = t5;
  }
  return t4;
}
function turboChargeResultIfSourceMap(liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return applySourceDocuments(
    result,
    resultSourceMap,
    (sourceDocument) => {
      if (
        // If _projectId is set, it's a cross dataset reference and we should skip it
        !sourceDocument._projectId && liveDocument != null && liveDocument._id && getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id)
      )
        return liveDocument;
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (changedValue, {
      previousValue
    }) => typeof changedValue == "number" && typeof previousValue == "string" ? `${changedValue}` : changedValue,
    perspective
  );
}
export {
  LoaderQueries as default,
  turboChargeResultIfSourceMap
};
//# sourceMappingURL=LiveQueries.js.map
