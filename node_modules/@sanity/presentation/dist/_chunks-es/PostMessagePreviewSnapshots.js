import { memo, useMemo, useEffect } from "react";
import { Subject, switchMap, combineLatest, share, skipWhile, NEVER, merge, takeUntil, filter, map, debounceTime } from "rxjs";
import { useDocumentPreviewStore, useSchema, getDraftId, getPublishedId } from "sanity";
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const PostMessagePreviews = (props) => {
  const {
    comlink,
    refs,
    perspective
  } = props, documentPreviewStore = useDocumentPreviewStore(), schema = useSchema(), refsSubject = useMemo(() => new Subject(), []), previews$ = useMemo(() => refsSubject.asObservable().pipe(switchMap((refs_0) => combineLatest(refs_0.map((ref) => {
    const draftRef = __spreadProps(__spreadValues({}, ref), {
      _id: getDraftId(ref._id)
    }), draft$ = perspective === "previewDrafts" ? documentPreviewStore.observeForPreview(draftRef, schema.get(draftRef._type)).pipe(
      // Share to prevent double subscribe in the merge
      share(),
      // Don't emit if no snapshot is returned
      skipWhile((p) => p.snapshot === null)
    ) : (
      // Don't emit if not displaying drafts
      NEVER
    ), publishedRef = __spreadProps(__spreadValues({}, ref), {
      _id: getPublishedId(ref._id)
    }), published$ = documentPreviewStore.observeForPreview(publishedRef, schema.get(publishedRef._type));
    return merge(published$.pipe(takeUntil(draft$)), draft$).pipe(filter((p_0) => !!p_0.snapshot), map((p_1) => {
      const snapshot = p_1.snapshot;
      return {
        _id: getPublishedId(snapshot._id),
        title: snapshot.title,
        subtitle: snapshot.subtitle,
        description: snapshot.description,
        imageUrl: snapshot.imageUrl
      };
    }));
  }))), debounceTime(0)), [documentPreviewStore, refsSubject, schema, perspective]);
  return useEffect(() => {
    const sub = previews$.subscribe((snapshots) => {
      comlink.post("presentation/preview-snapshots", {
        snapshots
      });
    });
    return () => {
      sub.unsubscribe();
    };
  }, [comlink, previews$]), useEffect(() => {
    refsSubject.next(refs);
  }, [refs, refsSubject]), null;
};
var PostMessagePreviewSnapshots = memo(PostMessagePreviews);
export {
  PostMessagePreviewSnapshots as default
};
//# sourceMappingURL=PostMessagePreviewSnapshots.js.map
