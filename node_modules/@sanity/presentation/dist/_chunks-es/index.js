var __defProp = Object.defineProperty, __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value);
import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { useState, useEffect, createContext, useContext, createElement, useLayoutEffect, lazy, Suspense } from "react";
import { useDocumentStore, isRecord, isReference, defineLocaleResourceBundle, useTranslation, defineDocumentFieldAction, useWorkspace, pathToString, getPublishedId, definePlugin, isDocumentSchemaType } from "sanity";
import { ComposeIcon, InfoOutlineIcon, ChevronRightIcon, WarningOutlineIcon, ErrorOutlineIcon, DesktopIcon, MasterDetailIcon } from "@sanity/icons";
import { Flex, Box, Text, Card, Spinner, Stack, rem } from "@sanity/ui";
import { styled } from "styled-components";
import get from "lodash/get.js";
import { Observable, switchMap, isObservable, from, map, of, combineLatest, mergeAll, scan } from "rxjs";
import { useIntentLink, useRouter, encodeJsonParams, route } from "sanity/router";
import { useEffectEvent } from "use-effect-event";
import { uuid } from "@sanity/uuid";
const DEFAULT_TOOL_ICON = ComposeIcon, DEFAULT_TOOL_NAME = "presentation", DEFAULT_TOOL_TITLE = "Presentation", COMMENTS_INSPECTOR_NAME = "sanity/structure/comments", EDIT_INTENT_MODE = "presentation", MAX_TIME_TO_OVERLAYS_CONNECTION = 3e3, API_VERSION = "2023-10-16", MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL = 1e3, LIVE_QUERY_CACHE_BATCH_SIZE = 100, LIVE_QUERY_CACHE_SIZE = 2048, POPUP_CHECK_INTERVAL = 1e3;
var __defProp$4 = Object.defineProperty, __defProps$4 = Object.defineProperties, __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$4 = Object.getOwnPropertySymbols, __hasOwnProp$4 = Object.prototype.hasOwnProperty, __propIsEnum$4 = Object.prototype.propertyIsEnumerable, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$4.call(b, prop) && __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b))
      __propIsEnum$4.call(b, prop) && __defNormalProp$4(a, prop, b[prop]);
  return a;
}, __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
function keysOf(value) {
  return Object.keys(value);
}
function setKey(source, key, value) {
  return __spreadProps$4(__spreadValues$4({}, source), {
    [key]: value
  });
}
function props(options = {}) {
  return (source) => new Observable((observer) => source.subscribe(observer)).pipe(switchMap((object2) => {
    const keyObservables = keysOf(object2).map((key) => {
      const value = object2[key];
      return isObservable(value) ? from(value).pipe(map((val) => [key, val])) : of([key, value]);
    });
    return options.wait ? combineLatest(keyObservables).pipe(map((pairs) => pairs.reduce((acc, [key, value]) => setKey(acc, key, value), {}))) : from(keyObservables).pipe(mergeAll(), scan((acc, [key, value]) => setKey(acc, key, value), {}));
  }));
}
var __defProp$3 = Object.defineProperty, __defProps$3 = Object.defineProperties, __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$3 = Object.getOwnPropertySymbols, __hasOwnProp$3 = Object.prototype.hasOwnProperty, __propIsEnum$3 = Object.prototype.propertyIsEnumerable, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b))
      __propIsEnum$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  return a;
}, __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
const INITIAL_STATE = {
  locations: []
};
function getDocumentId(value) {
  return isReference(value) ? value._ref : "_id" in value ? value._id : void 0;
}
function cleanPreviewable(id, previewable) {
  const clean = id ? __spreadProps$3(__spreadValues$3({}, previewable), {
    _id: id
  }) : __spreadValues$3({}, previewable);
  return clean._type === "reference" && (delete clean._type, delete clean._ref, delete clean._weak, delete clean._dataset, delete clean._projectId, delete clean._strengthenOnPublish), clean;
}
function listen(id, fields, store5) {
  const query = `*[_id==$id][0]{${fields.join(", ")}}`, params = {
    id
  };
  return store5.listenQuery(query, params, {
    perspective: "previewDrafts"
  });
}
function observeDocument(value, paths, store5) {
  if (!value || typeof value != "object")
    return of(value);
  const id = getDocumentId(value), currentValue = cleanPreviewable(id, value), headlessPaths = paths.filter((path) => !(path[0] in currentValue));
  if (id && headlessPaths.length) {
    const fields = [...new Set(headlessPaths.map((path) => path[0]))];
    return listen(id, fields, store5).pipe(switchMap((snapshot) => snapshot ? observeDocument(snapshot, paths, store5) : of(null)));
  }
  const leads = {};
  paths.forEach((path) => {
    const [head, ...tail] = path;
    leads[head] || (leads[head] = []), leads[head].push(tail);
  });
  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head].filter((tail) => tail.length > 0);
    return tails.length === 0 ? res[head] = isRecord(value) ? value[head] : void 0 : res[head] = observeDocument(value[head], tails, store5), res;
  }, currentValue);
  return of(next).pipe(props({
    wait: !0
  }));
}
function observeForLocations(documentId, resolver, documentStore) {
  const {
    select
  } = resolver, paths = Object.values(select).map((value) => String(value).split(".")) || [];
  return observeDocument({
    _type: "reference",
    _ref: documentId
  }, paths, documentStore).pipe(map((doc2) => Object.keys(select).reduce((acc, key) => (acc[key] = get(doc2, select[key]), acc), {})), map(resolver.resolve));
}
function useDocumentLocations(props2) {
  const $ = c(17), {
    id,
    resolvers,
    type
  } = props2, documentStore = useDocumentStore(), [locationsState, setLocationsState] = useState(INITIAL_STATE), resolver = resolvers && (typeof resolvers == "function" ? resolvers : resolvers[type]), [locationsStatus, setLocationsStatus] = useState(resolver ? "resolving" : "empty");
  let t0;
  bb0: {
    if (!resolver) {
      t0 = void 0;
      break bb0;
    }
    if (typeof resolver == "function") {
      let t13;
      if ($[0] !== documentStore || $[1] !== id || $[2] !== resolver || $[3] !== type) {
        const _result = resolver({
          id,
          type
        }, {
          documentStore
        });
        t13 = isObservable(_result) ? _result : of(_result), $[0] = documentStore, $[1] = id, $[2] = resolver, $[3] = type, $[4] = t13;
      } else
        t13 = $[4];
      t0 = t13;
      break bb0;
    }
    if ("select" in resolver && "resolve" in resolver) {
      let t13;
      $[5] !== documentStore || $[6] !== id || $[7] !== resolver ? (t13 = observeForLocations(id, resolver, documentStore), $[5] = documentStore, $[6] = id, $[7] = resolver, $[8] = t13) : t13 = $[8], t0 = t13;
      break bb0;
    }
    let t12;
    $[9] !== resolver ? (t12 = of(resolver), $[9] = resolver, $[10] = t12) : t12 = $[10], t0 = t12;
  }
  const result = t0;
  let t1, t2;
  $[11] !== result ? (t1 = () => {
    const sub = result == null ? void 0 : result.subscribe((state) => {
      setLocationsState(state || INITIAL_STATE), setLocationsStatus(state ? "resolved" : "empty");
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, t2 = [result], $[11] = result, $[12] = t1, $[13] = t2) : (t1 = $[12], t2 = $[13]), useEffect(t1, t2);
  let t3;
  return $[14] !== locationsState || $[15] !== locationsStatus ? (t3 = {
    state: locationsState,
    status: locationsStatus
  }, $[14] = locationsState, $[15] = locationsStatus, $[16] = t3) : t3 = $[16], t3;
}
const presentationLocaleNamespace = "presentation", presentationUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: presentationLocaleNamespace,
  resources: () => import("./resources.js")
}), PresentationContext = createContext(null);
function usePresentationTool(t0) {
  const throwOnMissingContext = t0 === void 0 ? !0 : t0, presentation = useContext(PresentationContext);
  if (throwOnMissingContext && !presentation)
    throw new Error("Presentation context is missing");
  return presentation;
}
function useCurrentPresentationToolName() {
  var _a, _b;
  return (_b = (_a = usePresentationTool(!1)) == null ? void 0 : _a.name) != null ? _b : void 0;
}
var __defProp$2 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b))
      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  return a;
}, __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const TONE_ICONS = {
  positive: InfoOutlineIcon,
  caution: WarningOutlineIcon,
  critical: ErrorOutlineIcon
};
function LocationsBanner(props2) {
  const $ = c(33), {
    documentId,
    isResolving,
    options,
    schemaType,
    showPresentationTitle
  } = props2, {
    locations,
    message,
    tone
  } = props2.state, len = (locations == null ? void 0 : locations.length) || 0, {
    t
  } = useTranslation(presentationLocaleNamespace), presentation = useContext(PresentationContext), presentationName = presentation == null ? void 0 : presentation.name, [expanded, setExpanded] = useState(!1);
  let t0;
  $[0] !== len ? (t0 = () => {
    len && setExpanded(_temp$1);
  }, $[0] = len, $[1] = t0) : t0 = $[1];
  const toggle = t0;
  let t1;
  $[2] !== isResolving || $[3] !== len || $[4] !== message || $[5] !== t ? (t1 = isResolving ? t("locations-banner.resolving.text") : message || t("locations-banner.locations-count", {
    count: len
  }), $[2] = isResolving, $[3] = len, $[4] = message, $[5] = t, $[6] = t1) : t1 = $[6];
  const title = t1;
  let t2;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    margin: -1
  }, $[7] = t2) : t2 = $[7];
  let t3;
  $[8] !== locations || $[9] !== options || $[10] !== showPresentationTitle || $[11] !== title || $[12] !== tone ? (t3 = !locations && /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, padding: 3, children: [
    tone && /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: createElement(TONE_ICONS[tone]) }) }),
    /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsxs(Text, { size: 1, weight: "medium", children: [
      showPresentationTitle && /* @__PURE__ */ jsxs(Fragment, { children: [
        options.title || DEFAULT_TOOL_TITLE,
        " \xB7 "
      ] }),
      title
    ] }) })
  ] }), $[8] = locations, $[9] = options, $[10] = showPresentationTitle, $[11] = title, $[12] = tone, $[13] = t3) : t3 = $[13];
  let t4;
  $[14] !== documentId || $[15] !== expanded || $[16] !== isResolving || $[17] !== len || $[18] !== locations || $[19] !== options || $[20] !== (presentation == null ? void 0 : presentation.params) || $[21] !== presentationName || $[22] !== schemaType || $[23] !== showPresentationTitle || $[24] !== title || $[25] !== toggle ? (t4 = locations && /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Card, { as: len ? "button" : void 0, onClick: toggle, padding: 3, radius: 1, tone: "inherit", children: /* @__PURE__ */ jsxs(Flex, { gap: 3, children: [
      /* @__PURE__ */ jsx(Box, { flex: "none", children: isResolving ? /* @__PURE__ */ jsx(Spinner, { size: 1 }) : /* @__PURE__ */ jsx(Text, { size: 1, children: len === 0 ? /* @__PURE__ */ jsx(InfoOutlineIcon, {}) : /* @__PURE__ */ jsx(ChevronRightIcon, { style: {
        transform: `rotate(${expanded ? "90deg" : 0})`,
        transition: "transform 100ms ease-in-out"
      } }) }) }),
      /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsxs(Text, { size: 1, weight: "medium", children: [
        showPresentationTitle && /* @__PURE__ */ jsxs(Fragment, { children: [
          options.title || DEFAULT_TOOL_TITLE,
          " \xB7 "
        ] }),
        title
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsx(Stack, { hidden: !expanded, marginTop: 1, space: 1, children: locations.map((l, index) => /* @__PURE__ */ jsx(LocationItem, { active: (options.name || DEFAULT_TOOL_NAME) === presentationName && l.href === (presentation == null ? void 0 : presentation.params.preview), documentId, documentType: schemaType.name, node: l, toolName: options.name || DEFAULT_TOOL_NAME }, index)) })
  ] }), $[14] = documentId, $[15] = expanded, $[16] = isResolving, $[17] = len, $[18] = locations, $[19] = options, $[20] = presentation == null ? void 0 : presentation.params, $[21] = presentationName, $[22] = schemaType, $[23] = showPresentationTitle, $[24] = title, $[25] = toggle, $[26] = t4) : t4 = $[26];
  let t5;
  $[27] !== t3 || $[28] !== t4 ? (t5 = /* @__PURE__ */ jsxs("div", { style: t2, children: [
    t3,
    t4
  ] }), $[27] = t3, $[28] = t4, $[29] = t5) : t5 = $[29];
  let t6;
  return $[30] !== t5 || $[31] !== tone ? (t6 = /* @__PURE__ */ jsx(Card, { padding: 1, radius: 2, border: !0, tone, children: t5 }), $[30] = t5, $[31] = tone, $[32] = t6) : t6 = $[32], t6;
}
function _temp$1(v) {
  return !v;
}
function LocationItem(props2) {
  const $ = c(26), {
    documentId,
    documentType,
    node,
    active,
    toolName
  } = props2, presentation = useContext(PresentationContext), currentPresentationToolName = useCurrentPresentationToolName(), isCurrentTool = toolName === currentPresentationToolName, navigate = presentation == null ? void 0 : presentation.navigate, t0 = presentation == null ? void 0 : presentation.structureParams;
  let t1;
  $[0] !== documentId || $[1] !== documentType || $[2] !== node.href || $[3] !== t0 || $[4] !== toolName ? (t1 = {
    intent: "edit",
    params: __spreadProps$2(__spreadValues$2({
      id: documentId,
      type: documentType,
      mode: "presentation",
      presentation: toolName
    }, t0), {
      preview: node.href
    })
  }, $[0] = documentId, $[1] = documentType, $[2] = node.href, $[3] = t0, $[4] = toolName, $[5] = t1) : t1 = $[5];
  const presentationLinkProps = useIntentLink(t1);
  let t2;
  $[6] !== navigate || $[7] !== node.href ? (t2 = () => {
    navigate == null || navigate({}, {
      preview: node.href
    });
  }, $[6] = navigate, $[7] = node.href, $[8] = t2) : t2 = $[8];
  const handleCurrentToolClick = t2;
  let t3;
  $[9] !== isCurrentTool || $[10] !== presentationLinkProps ? (t3 = isCurrentTool ? {} : presentationLinkProps, $[9] = isCurrentTool, $[10] = presentationLinkProps, $[11] = t3) : t3 = $[11];
  const t4 = isCurrentTool ? handleCurrentToolClick : presentationLinkProps.onClick;
  let t5;
  $[12] === Symbol.for("react.memo_cache_sentinel") ? (t5 = /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(DesktopIcon, {}) }) }), $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== node.title ? (t6 = /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: node.title }), $[13] = node.title, $[14] = t6) : t6 = $[14];
  let t7;
  $[15] !== node.href ? (t7 = /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: node.href }), $[15] = node.href, $[16] = t7) : t7 = $[16];
  let t8;
  $[17] !== t6 || $[18] !== t7 ? (t8 = /* @__PURE__ */ jsxs(Flex, { gap: 3, children: [
    t5,
    /* @__PURE__ */ jsxs(Stack, { flex: 1, space: 2, children: [
      t6,
      t7
    ] })
  ] }), $[17] = t6, $[18] = t7, $[19] = t8) : t8 = $[19];
  let t9;
  return $[20] !== active || $[21] !== node.href || $[22] !== t3 || $[23] !== t4 || $[24] !== t8 ? (t9 = /* @__PURE__ */ createElement(Card, __spreadProps$2(__spreadValues$2({}, t3), { as: "a", key: node.href, onClick: t4, padding: 3, radius: 1, pressed: active, tone: "inherit" }), t8), $[20] = active, $[21] = node.href, $[22] = t3, $[23] = t4, $[24] = t8, $[25] = t9) : t9 = $[25], t9;
}
const PresentationDocumentContext = createContext(null), LocationStack = styled(Stack)`
  min-height: ${rem(42)};

  & + &:empty {
    display: none;
  }
`;
function PresentationDocumentHeader(props2) {
  var _a;
  const $ = c(20), {
    documentId,
    options,
    schemaType
  } = props2, context = useContext(PresentationDocumentContext), t0 = ((_a = options.resolve) == null ? void 0 : _a.locations) || options.locate;
  let t1;
  $[0] !== documentId || $[1] !== schemaType.name || $[2] !== t0 ? (t1 = {
    id: documentId,
    resolvers: t0,
    type: schemaType.name
  }, $[0] = documentId, $[1] = schemaType.name, $[2] = t0, $[3] = t1) : t1 = $[3];
  const {
    state,
    status
  } = useDocumentLocations(t1);
  if (context && context.options[0] !== options || status === "empty")
    return null;
  let t2;
  $[4] !== (context == null ? void 0 : context.options) ? (t2 = (context == null ? void 0 : context.options) || [], $[4] = context == null ? void 0 : context.options, $[5] = t2) : t2 = $[5];
  const contextOptions = t2;
  let t3;
  if ($[6] !== contextOptions || $[7] !== documentId || $[8] !== schemaType || $[9] !== state || $[10] !== status) {
    let t42;
    $[12] !== contextOptions.length || $[13] !== documentId || $[14] !== schemaType || $[15] !== state || $[16] !== status ? (t42 = (options_0, idx) => /* @__PURE__ */ jsx(LocationsBanner, { documentId, isResolving: status === "resolving", options: options_0, schemaType, showPresentationTitle: contextOptions.length > 1, state }, idx), $[12] = contextOptions.length, $[13] = documentId, $[14] = schemaType, $[15] = state, $[16] = status, $[17] = t42) : t42 = $[17], t3 = contextOptions.map(t42), $[6] = contextOptions, $[7] = documentId, $[8] = schemaType, $[9] = state, $[10] = status, $[11] = t3;
  } else
    t3 = $[11];
  let t4;
  return $[18] !== t3 ? (t4 = /* @__PURE__ */ jsx(LocationStack, { marginBottom: 5, space: 5, children: /* @__PURE__ */ jsx(Stack, { space: 2, children: t3 }) }), $[18] = t3, $[19] = t4) : t4 = $[19], t4;
}
function PresentationDocumentProvider(props2) {
  const $ = c(14), {
    children,
    options
  } = props2, parent = useContext(PresentationDocumentContext), parentRegister = parent == null ? void 0 : parent.register, [optionsArray, setOptionsArray] = useState(_temp);
  let t0;
  $[0] !== parentRegister ? (t0 = (options_0) => parentRegister ? parentRegister(options_0) : (setOptionsArray((prev) => [options_0].concat(prev)), () => {
    setOptionsArray((prev_0) => prev_0.filter((o) => o !== options_0));
  }), $[0] = parentRegister, $[1] = t0) : t0 = $[1];
  const register = t0;
  let t1;
  const t2 = (parent == null ? void 0 : parent.options) || optionsArray;
  let t3;
  $[2] !== register || $[3] !== t2 ? (t3 = {
    options: t2,
    register
  }, $[2] = register, $[3] = t2, $[4] = t3) : t3 = $[4], t1 = t3;
  const context = t1;
  let t4;
  $[5] !== register ? (t4 = (options_1) => register(options_1), $[5] = register, $[6] = t4) : t4 = $[6];
  const registerEffectEvent = useEffectEvent(t4);
  let t5, t6;
  $[7] !== options || $[8] !== registerEffectEvent ? (t5 = () => registerEffectEvent(options), t6 = [registerEffectEvent, options], $[7] = options, $[8] = registerEffectEvent, $[9] = t5, $[10] = t6) : (t5 = $[9], t6 = $[10]), useLayoutEffect(t5, t6);
  let t7;
  return $[11] !== children || $[12] !== context ? (t7 = /* @__PURE__ */ jsx(PresentationDocumentContext.Provider, { value: context, children }), $[11] = children, $[12] = context, $[13] = t7) : t7 = $[13], t7;
}
function _temp() {
  return [];
}
function useOpenInStructureAction(props2) {
  const $ = c(14), {
    documentId,
    documentType,
    path
  } = props2, workspace = useWorkspace(), {
    navigateIntent
  } = useRouter(), presentation = useContext(PresentationContext);
  let t0, t1;
  $[0] !== documentId || $[1] !== documentType || $[2] !== workspace.tools ? (t1 = findStructureTool(workspace.tools, documentId, documentType), $[0] = documentId, $[1] = documentType, $[2] = workspace.tools, $[3] = t1) : t1 = $[3], t0 = t1;
  const defaultStructureTool = t0;
  let t2;
  $[4] !== documentId || $[5] !== documentType || $[6] !== navigateIntent || $[7] !== path ? (t2 = () => {
    navigateIntent("edit", {
      id: documentId,
      type: documentType,
      mode: "structure",
      path: pathToString(path)
    });
  }, $[4] = documentId, $[5] = documentType, $[6] = navigateIntent, $[7] = path, $[8] = t2) : t2 = $[8];
  const handleAction = t2, t3 = !presentation || path.length > 0 || !defaultStructureTool, t4 = (defaultStructureTool == null ? void 0 : defaultStructureTool.icon) || MasterDetailIcon, t5 = `Open in ${(defaultStructureTool == null ? void 0 : defaultStructureTool.title) || "Structure"}`;
  let t6;
  return $[9] !== handleAction || $[10] !== t3 || $[11] !== t4 || $[12] !== t5 ? (t6 = {
    type: "action",
    hidden: t3,
    icon: t4,
    title: t5,
    onAction: handleAction,
    renderAsButton: !0
  }, $[9] = handleAction, $[10] = t3, $[11] = t4, $[12] = t5, $[13] = t6) : t6 = $[13], t6;
}
const openInStructure = defineDocumentFieldAction({
  name: "presentation/openInStructure",
  useAction: useOpenInStructureAction
});
function findStructureTool(tools, documentId, documentType) {
  var _a;
  const results = tools.map((t) => {
    var _a2;
    const match = (_a2 = t.canHandleIntent) == null ? void 0 : _a2.call(t, "edit", {
      id: documentId,
      type: documentType,
      mode: "structure"
    }, {});
    return {
      tool: t,
      match
    };
  }), modeMatches = results.filter((t) => isRecord(t.match) && t.match.mode);
  return modeMatches.length > 0 ? modeMatches[0].tool : (_a = results.filter((t) => t.match)[0]) == null ? void 0 : _a.tool;
}
var __defProp$1 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b))
      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  return a;
}, __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b)), __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
const preservedSearchParamKeys = ["preview", "perspective", "viewport"];
function getIntentState(intent, params, routerState, payload) {
  const _a = params, {
    id,
    mode,
    path,
    presentation,
    type
  } = _a, searchParams = __objRest(_a, [
    "id",
    "mode",
    "path",
    "presentation",
    "type"
  ]), preservedSearchParams = ((routerState == null ? void 0 : routerState._searchParams) || []).filter(([key]) => preservedSearchParamKeys.includes(key)).reduce((acc, [key, value]) => __spreadProps$1(__spreadValues$1({}, acc), {
    [key]: value
  }), {}), _searchParams = __spreadValues$1(__spreadValues$1({}, preservedSearchParams), searchParams);
  return intent === "edit" && id ? (_searchParams.preview = _searchParams.preview || new URLSearchParams(window.location.search).get("preview") || "/", {
    type: type || "*",
    id: getPublishedId(id),
    path,
    _searchParams: Object.entries(_searchParams)
  }) : intent === "create" ? (_searchParams.preview = _searchParams.preview || new URLSearchParams(window.location.search).get("preview") || "/", payload && typeof payload == "object" && (_searchParams.templateParams = encodeJsonParams(payload)), {
    type: type || "*",
    id: id || uuid(),
    _searchParams: Object.entries(_searchParams)
  }) : {
    intent,
    params,
    payload
  };
}
function PresentationSpinner() {
  const $ = c(1);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", style: {
    width: "100%"
  }, children: /* @__PURE__ */ jsx(Spinner, {}) }), $[0] = t0) : t0 = $[0], t0;
}
const router = route.create("/", {
  __unsafe_disableScopedSearchParams: !0
}, [route.intents("/intent"), route.create(":type", [route.create(":id", [route.create(":path")])])]), PresentationTool = lazy(() => import("./PresentationToolGrantsCheck.js").then(function(n) {
  return n.PresentationToolGrantsCheck;
})), BroadcastDisplayedDocument = lazy(() => import("./BroadcastDisplayedDocument.js"));
function defineLocations(resolver) {
  return resolver;
}
function defineDocuments(resolvers) {
  return resolvers;
}
const presentationTool = definePlugin((options) => {
  var _a;
  const toolName = options.name || DEFAULT_TOOL_NAME;
  "locate" in options && console.warn("Presentation\u2019s `locate` option is deprecated. Use `resolve.locations` instead.");
  const hasLocationsResolver = !!((_a = options.resolve) != null && _a.locations || options.locate);
  function PresentationDocumentInput(props2) {
    const $ = c(19), value = props2.value;
    let t0;
    $[0] !== (value == null ? void 0 : value._id) ? (t0 = value != null && value._id ? getPublishedId(value == null ? void 0 : value._id) : void 0, $[0] = value == null ? void 0 : value._id, $[1] = t0) : t0 = $[1];
    const documentId = t0;
    if (isDocumentSchemaType(props2.schemaType)) {
      let t12;
      $[2] !== documentId || $[3] !== props2.schemaType ? (t12 = hasLocationsResolver && documentId && /* @__PURE__ */ jsx(PresentationDocumentHeader, { documentId, options, schemaType: props2.schemaType }), $[2] = documentId, $[3] = props2.schemaType, $[4] = t12) : t12 = $[4];
      let t2;
      $[5] === Symbol.for("react.memo_cache_sentinel") ? (t2 = /* @__PURE__ */ jsx(PresentationSpinner, {}), $[5] = t2) : t2 = $[5];
      let t3;
      $[6] !== props2 ? (t3 = props2.renderDefault(props2), $[6] = props2, $[7] = t3) : t3 = $[7];
      let t4;
      $[8] !== t3 ? (t4 = /* @__PURE__ */ jsx(Suspense, { fallback: t2, children: t3 }), $[8] = t3, $[9] = t4) : t4 = $[9];
      let t5;
      $[10] !== documentId || $[11] !== value ? (t5 = /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(BroadcastDisplayedDocument, { value }, documentId) }, "broadcast-displayed-document"), $[10] = documentId, $[11] = value, $[12] = t5) : t5 = $[12];
      let t6;
      return $[13] !== t12 || $[14] !== t4 || $[15] !== t5 ? (t6 = /* @__PURE__ */ jsxs(PresentationDocumentProvider, { options, children: [
        t12,
        t4,
        t5
      ] }), $[13] = t12, $[14] = t4, $[15] = t5, $[16] = t6) : t6 = $[16], t6;
    }
    let t1;
    return $[17] !== props2 ? (t1 = props2.renderDefault(props2), $[17] = props2, $[18] = t1) : t1 = $[18], t1;
  }
  function canHandleCreateIntent(params) {
    return !("type" in params) || "presentation" in params && params.presentation !== toolName ? !1 : "template" in params ? {
      template: !0
    } : !0;
  }
  function canHandleEditIntent(params) {
    return !("type" in params) || !("id" in params) || "presentation" in params && params.presentation !== toolName ? !1 : "mode" in params ? {
      mode: params.mode === EDIT_INTENT_MODE
    } : !0;
  }
  return {
    i18n: {
      bundles: [presentationUsEnglishLocaleBundle]
    },
    document: {
      unstable_fieldActions: (prev) => [
        ...prev.filter((a) => a.name !== openInStructure.name),
        // prevent duplication
        openInStructure
      ]
    },
    form: {
      components: {
        input: PresentationDocumentInput
      }
    },
    tools: [{
      icon: options.icon || DEFAULT_TOOL_ICON,
      name: toolName,
      title: options.title,
      component: PresentationTool,
      options,
      canHandleIntent(intent, params) {
        return intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : !1;
      },
      getIntentState,
      router
    }]
  };
}), PresentationNavigateContext = createContext(null);
function usePresentationNavigate() {
  const navigate = useContext(PresentationNavigateContext);
  if (!navigate)
    throw new Error("Presentation navigate context is missing");
  return navigate;
}
const PresentationParamsContext = createContext(null);
function usePresentationParams(t0) {
  const throwOnMissingContext = t0 === void 0 ? !0 : t0, params = useContext(PresentationParamsContext);
  if (throwOnMissingContext && !params)
    throw new Error("Presentation params context is missing");
  return params;
}
const SharedStateContext = createContext(null), useSharedState = (key, value) => {
  const $ = c(5), context = useContext(SharedStateContext);
  if (!context)
    throw new Error("Preview Snapshots context is missing");
  const {
    setValue
  } = context;
  let t0, t1;
  $[0] !== key || $[1] !== setValue || $[2] !== value ? (t0 = () => {
    setValue(key, value);
  }, t1 = [key, value, setValue], $[0] = key, $[1] = setValue, $[2] = value, $[3] = t0, $[4] = t1) : (t0 = $[3], t1 = $[4]), useEffect(t0, t1);
};
var store;
function getGlobalConfig(config2) {
  var _a, _b, _c;
  return {
    lang: (_a = config2 == null ? void 0 : config2.lang) != null ? _a : store == null ? void 0 : store.lang,
    message: config2 == null ? void 0 : config2.message,
    abortEarly: (_b = config2 == null ? void 0 : config2.abortEarly) != null ? _b : store == null ? void 0 : store.abortEarly,
    abortPipeEarly: (_c = config2 == null ? void 0 : config2.abortPipeEarly) != null ? _c : store == null ? void 0 : store.abortPipeEarly,
    skipPipe: config2 == null ? void 0 : config2.skipPipe
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2 == null ? void 0 : store2.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3 == null ? void 0 : store3.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  var _a;
  return (_a = store4 == null ? void 0 : store4.get(reference)) == null ? void 0 : _a.get(lang);
}
function _stringify(input) {
  var _a, _b, _c;
  let type = typeof input;
  return type === "object" && (type = (_c = input && ((_b = (_a = Object.getPrototypeOf(input)) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name)) != null ? _c : "null"), type === "string" ? `"${input}"` : type === "number" || type === "bigint" || type === "boolean" ? `${input}` : type;
}
function _addIssue(context, label, dataset, config2, other) {
  var _a, _b, _c, _d, _e, _f;
  const input = other && "input" in other ? other.input : dataset.value, expected = (_a = other == null ? void 0 : other.expected) != null ? _a : context.expects, received = (_b = other == null ? void 0 : other.received) != null ? _b : _stringify(input), issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other == null ? void 0 : other.path,
    issues: other == null ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly,
    skipPipe: config2.skipPipe
  }, isSchema = context.kind === "schema", message = (
    // @ts-expect-error
    (_f = (_e = (_d = (_c = context.message) != null ? _c : getSpecificMessage(context.reference, issue.lang)) != null ? _d : isSchema ? getSchemaMessage(issue.lang) : null) != null ? _e : config2.message) != null ? _f : getGlobalMessage(issue.lang)
  );
  message && (issue.message = typeof message == "function" ? message(issue) : message), isSchema && (dataset.typed = !1), dataset.issues ? dataset.issues.push(issue) : dataset.issues = [issue];
}
function _isAllowedObjectKey(key) {
  return key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    /**
     * The error issues.
     */
    __publicField(this, "issues");
    this.name = "ValiError", this.issues = issues;
  }
};
function minLength(requirement, message) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${requirement}`,
    requirement,
    message,
    _run(dataset, config2) {
      return dataset.typed && dataset.value.length < this.requirement && _addIssue(this, "length", dataset, config2, {
        received: `${dataset.value.length}`
      }), dataset;
    }
  };
}
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback == "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
function fallback(schema, fallback2) {
  return __spreadProps(__spreadValues({}, schema), {
    fallback: fallback2,
    _run(dataset, config2) {
      return schema._run(dataset, config2), dataset.issues ? {
        typed: !0,
        value: getFallback(this, dataset, config2)
      } : dataset;
    }
  });
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default == "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message,
    _run(dataset, config2) {
      return typeof dataset.value == "boolean" ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries,
    message,
    _run(dataset, config2) {
      var _a;
      const input = dataset.value;
      if (input && typeof input == "object") {
        dataset.typed = !0, dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key], valueDataset = this.entries[key]._run({
            typed: !1,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues)
              issue.path ? issue.path.unshift(pathItem) : issue.path = [pathItem], (_a = dataset.issues) == null || _a.push(issue);
            if (dataset.issues || (dataset.issues = valueDataset.issues), config2.abortEarly) {
              dataset.typed = !1;
              break;
            }
          }
          valueDataset.typed || (dataset.typed = !1), (valueDataset.value !== void 0 || key in input) && (dataset.value[key] = valueDataset.value);
        }
      } else
        _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${wrapped.expects} | undefined`,
    async: !1,
    wrapped,
    _run(dataset, config2) {
      return dataset.value === void 0 && ("default" in this && (dataset.value = getDefault(this, dataset, config2)), dataset.value === void 0) ? (dataset.typed = !0, dataset) : this.wrapped._run(dataset, config2);
    }
  };
  return 0 in args && (schema.default = args[0]), schema;
}
function picklist(options, message) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: options.map(_stringify).join(" | ") || "never",
    async: !1,
    options,
    message,
    _run(dataset, config2) {
      return this.options.includes(dataset.value) ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key,
    value: value2,
    message,
    _run(dataset, config2) {
      var _a, _b;
      const input = dataset.value;
      if (input && typeof input == "object") {
        dataset.typed = !0, dataset.value = {};
        for (const entryKey in input)
          if (_isAllowedObjectKey(entryKey)) {
            const entryValue = input[entryKey], keyDataset = this.key._run({
              typed: !1,
              value: entryKey
            }, config2);
            if (keyDataset.issues) {
              const pathItem = {
                type: "record",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues)
                issue.path = [pathItem], (_a = dataset.issues) == null || _a.push(issue);
              if (dataset.issues || (dataset.issues = keyDataset.issues), config2.abortEarly) {
                dataset.typed = !1;
                break;
              }
            }
            const valueDataset = this.value._run({
              typed: !1,
              value: entryValue
            }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "record",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues)
                issue.path ? issue.path.unshift(pathItem) : issue.path = [pathItem], (_b = dataset.issues) == null || _b.push(issue);
              if (dataset.issues || (dataset.issues = valueDataset.issues), config2.abortEarly) {
                dataset.typed = !1;
                break;
              }
            }
            (!keyDataset.typed || !valueDataset.typed) && (dataset.typed = !1), keyDataset.typed && (dataset.value[keyDataset.value] = valueDataset.value);
          }
      } else
        _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message,
    _run(dataset, config2) {
      return typeof dataset.value == "string" ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(dataset) {
      return dataset.typed = !0, dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema._run({
    typed: !1,
    value: input
  }, getGlobalConfig(config2));
  if (dataset.issues)
    throw new ValiError(dataset.issues);
  return dataset.value;
}
function pipe(...pipe2) {
  return __spreadProps(__spreadValues({}, pipe2[0]), {
    pipe: pipe2,
    _run(dataset, config2) {
      for (let index = 0; index < pipe2.length; index++) {
        dataset = pipe2[index]._run(dataset, config2);
        const nextAction = pipe2[index + 1];
        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!
        (nextAction == null ? void 0 : nextAction.kind) === "schema" || (nextAction == null ? void 0 : nextAction.kind) === "transformation")) {
          dataset.typed = !1;
          break;
        }
      }
      return dataset;
    }
  });
}
var __defProp2 = Object.defineProperty, __defProps2 = Object.defineProperties, __getOwnPropDescs2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols2 = Object.getOwnPropertySymbols, __hasOwnProp2 = Object.prototype.hasOwnProperty, __propIsEnum2 = Object.prototype.propertyIsEnumerable, __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp2.call(b, prop) && __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b))
      __propIsEnum2.call(b, prop) && __defNormalProp2(a, prop, b[prop]);
  return a;
}, __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
const ACTION_IFRAME_LOADED = "ACTION_IFRAME_LOADED", ACTION_IFRAME_REFRESH = "ACTION_IFRAME_REFRESH", ACTION_IFRAME_RELOAD = "ACTION_IFRAME_RELOAD", ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE = "ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE", presentationReducer = (state, action) => {
  switch (action.type) {
    case ACTION_IFRAME_LOADED:
      return state.iframe.status === "loaded" ? state : __spreadProps2(__spreadValues2({}, state), {
        iframe: __spreadProps2(__spreadValues2({}, state.iframe), {
          status: "loaded"
        })
      });
    case ACTION_IFRAME_REFRESH:
      return state.iframe.status === "refreshing" ? state : __spreadProps2(__spreadValues2({}, state), {
        iframe: __spreadProps2(__spreadValues2({}, state.iframe), {
          status: "refreshing"
        })
      });
    case ACTION_IFRAME_RELOAD:
      return state.iframe.status === "reloading" ? state : __spreadProps2(__spreadValues2({}, state), {
        iframe: __spreadProps2(__spreadValues2({}, state.iframe), {
          status: "reloading"
        })
      });
    case ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE:
      return toggleVisualEditingOverlays(state, action);
    default:
      return state;
  }
}, toggleVisualEditingOverlays = (state, action) => state.visualEditing.overlaysEnabled === action.enabled ? state : __spreadProps2(__spreadValues2({}, state), {
  visualEditing: __spreadProps2(__spreadValues2({}, state.visualEditing), {
    overlaysEnabled: action.enabled
  })
}), mainDocumentSchema = fallback(boolean(), !1), iframeStatusSchema = picklist(["loading", "loaded", "refreshing", "reloading"]), initStateSchema = object({
  mainDocument: mainDocumentSchema,
  iframe: object({
    status: iframeStatusSchema
  }),
  visualEditing: object({
    overlaysEnabled: boolean()
  })
}), INITIAL_PRESENTATION_STATE = {
  mainDocument: !1,
  iframe: {
    status: "loading"
  },
  visualEditing: {
    overlaysEnabled: !1
  }
};
function presentationReducerInit(state) {
  return parse(initStateSchema, __spreadValues2(__spreadValues2({}, INITIAL_PRESENTATION_STATE), state));
}
export {
  ACTION_IFRAME_LOADED,
  ACTION_IFRAME_REFRESH,
  ACTION_IFRAME_RELOAD,
  ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE,
  API_VERSION,
  COMMENTS_INSPECTOR_NAME,
  DEFAULT_TOOL_NAME,
  EDIT_INTENT_MODE,
  LIVE_QUERY_CACHE_BATCH_SIZE,
  LIVE_QUERY_CACHE_SIZE,
  MAX_TIME_TO_OVERLAYS_CONNECTION,
  MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL,
  POPUP_CHECK_INTERVAL,
  PresentationContext,
  PresentationNavigateContext,
  PresentationParamsContext,
  PresentationSpinner,
  SharedStateContext,
  defineDocuments,
  defineLocations,
  minLength,
  object,
  optional,
  pipe,
  presentationLocaleNamespace,
  presentationReducer,
  presentationReducerInit,
  presentationTool,
  record,
  string,
  unknown,
  usePresentationNavigate,
  usePresentationParams,
  usePresentationTool,
  useSharedState
};
//# sourceMappingURL=index.js.map
