"use strict";
var jsxRuntime = require("react/jsx-runtime"), reactCompilerRuntime = require("react-compiler-runtime"), PresentationToolGrantsCheck = require("./PresentationToolGrantsCheck.cjs"), hooks = require("./hooks.cjs"), csm = require("@sanity/client/csm"), comlink = require("@sanity/comlink"), mendoza = require("mendoza"), LRUCache = require("mnemonist/lru-cache-with-delete"), react = require("react"), sanity = require("sanity"), index = require("./index.cjs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var LRUCache__default = /* @__PURE__ */ _interopDefaultCompat(LRUCache), __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function LoaderQueries(props) {
  const {
    liveDocument,
    controller,
    perspective: activePerspective,
    documentsOnPage,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink$1, setComlink] = react.useState(), [liveQueries, setLiveQueries] = react.useState({}), projectId = sanity.useProjectId(), dataset = sanity.useDataset();
  react.useEffect(() => {
    const interval = setInterval(() => setLiveQueries((liveQueries_0) => {
      if (Object.keys(liveQueries_0).length < 1)
        return liveQueries_0;
      const now = Date.now();
      if (!Object.values(liveQueries_0).some((liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat))
        return liveQueries_0;
      const next = {};
      for (const [key, value] of Object.entries(liveQueries_0))
        value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
      return next;
    }), index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL);
    return () => clearInterval(interval);
  }, []), react.useEffect(() => {
    if (controller) {
      const comlink_0 = controller.createChannel({
        name: "presentation",
        connectTo: "loaders",
        heartbeat: !0
      }, comlink.createConnectionMachine().provide({
        actors: PresentationToolGrantsCheck.createCompatibilityActors()
      }));
      return setComlink(comlink_0), comlink_0.onStatus(onLoadersConnection), comlink_0.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink_0.on("loader/query-listen", (data_0) => {
        if (data_0.projectId === projectId && data_0.dataset === dataset) {
          if (typeof data_0.heartbeat == "number" && data_0.heartbeat < index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(`Loader query listen heartbeat interval must be at least ${index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`);
          setLiveQueries((prev) => {
            var _a;
            return __spreadProps(__spreadValues({}, prev), {
              [PresentationToolGrantsCheck.getQueryCacheKey(data_0.query, data_0.params)]: {
                perspective: data_0.perspective,
                query: data_0.query,
                params: data_0.params,
                receivedAt: Date.now(),
                heartbeat: (_a = data_0.heartbeat) != null ? _a : !1
              }
            });
          });
        }
      }), comlink_0.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [cache] = react.useState(() => new LRUCache__default.default(index.LIVE_QUERY_CACHE_SIZE)), studioClient = sanity.useClient({
    apiVersion: "2023-10-16"
  }), clientConfig = react.useMemo(() => studioClient.config(), [studioClient]), client = react.useMemo(() => studioClient.withConfig({
    resultSourceMap: "withKeyArraySelector"
  }), [studioClient]);
  react.useEffect(() => {
    if (comlink$1) {
      const {
        projectId: projectId_0,
        dataset: dataset_0
      } = clientConfig;
      comlink$1.post("loader/perspective", {
        projectId: projectId_0,
        dataset: dataset_0,
        perspective: activePerspective
      });
    }
  }, [comlink$1, clientConfig, activePerspective]);
  const turboIds = react.useMemo(() => {
    const documentsActuallyInUse = documentsOnPage.map(({
      _id
    }) => _id), ids = [...new Set(documentsActuallyInUse)], max = cache.capacity;
    return ids.length >= max && (ids.length = max), ids;
  }, [cache.capacity, documentsOnPage]), [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = react.useState(0);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(Turbo, { cache, client, turboIds, setDocumentsCacheLastUpdated }),
    Object.entries(liveQueries).map(([key_0, {
      query,
      params,
      perspective
    }]) => /* @__PURE__ */ jsxRuntime.jsx(QuerySubscription, { cache, projectId: clientConfig.projectId, dataset: clientConfig.dataset, perspective, query, params, comlink: comlink$1, client, refreshInterval: activePerspective ? 2e3 : 0, liveDocument, documentsCacheLastUpdated }, `${key_0}${perspective}`))
  ] });
}
const Turbo = react.memo(function(props) {
  const $ = reactCompilerRuntime.c(22), {
    cache,
    client,
    turboIds,
    setDocumentsCacheLastUpdated
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = [], $[0] = t0) : t0 = $[0];
  const [batch, setBatch] = react.useState(t0);
  let t1, t2;
  $[1] !== batch || $[2] !== cache || $[3] !== turboIds ? (t1 = () => {
    const batchSet = new Set(batch.flat()), nextBatch = /* @__PURE__ */ new Set();
    for (const turboId of turboIds)
      !batchSet.has(turboId) && !cache.has(turboId) && nextBatch.add(turboId);
    const nextBatchSlice = [...nextBatch].slice(0, index.LIVE_QUERY_CACHE_BATCH_SIZE);
    nextBatchSlice.length !== 0 && setBatch((prevBatch) => [...prevBatch.slice(-index.LIVE_QUERY_CACHE_BATCH_SIZE), nextBatchSlice]);
  }, t2 = [batch, cache, turboIds], $[1] = batch, $[2] = cache, $[3] = turboIds, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), react.useEffect(t1, t2);
  let t3, t4;
  $[6] !== cache || $[7] !== client || $[8] !== setDocumentsCacheLastUpdated ? (t3 = () => {
    const subscription = client.listen("*", {}, {
      events: ["mutation"],
      effectFormat: "mendoza",
      includePreviousRevision: !1,
      includeResult: !1,
      tag: "presentation-loader"
    }).subscribe((update) => {
      var _a, _b;
      if (update.type === "mutation" && update.transition === "disappear" && cache.delete(update.documentId) && setDocumentsCacheLastUpdated(Date.now()), update.type !== "mutation" || !((_b = (_a = update.effects) == null ? void 0 : _a.apply) != null && _b.length))
        return;
      const cachedDocument = cache.peek(update.documentId);
      if (cachedDocument) {
        const patchDoc = __spreadValues({}, cachedDocument);
        delete patchDoc._rev;
        const patchedDocument = mendoza.applyPatch(patchDoc, update.effects.apply);
        cache.set(update.documentId, patchedDocument), setDocumentsCacheLastUpdated(Date.now());
      }
    });
    return () => subscription.unsubscribe();
  }, t4 = [cache, client, setDocumentsCacheLastUpdated], $[6] = cache, $[7] = client, $[8] = setDocumentsCacheLastUpdated, $[9] = t3, $[10] = t4) : (t3 = $[9], t4 = $[10]), react.useEffect(t3, t4);
  let t5;
  if ($[11] !== batch || $[12] !== cache || $[13] !== client || $[14] !== setDocumentsCacheLastUpdated) {
    let t62;
    $[16] !== cache || $[17] !== client || $[18] !== setDocumentsCacheLastUpdated ? (t62 = (ids) => /* @__PURE__ */ jsxRuntime.jsx(GetDocuments, { cache, client, ids, setDocumentsCacheLastUpdated }, JSON.stringify(ids)), $[16] = cache, $[17] = client, $[18] = setDocumentsCacheLastUpdated, $[19] = t62) : t62 = $[19], t5 = batch.map(t62), $[11] = batch, $[12] = cache, $[13] = client, $[14] = setDocumentsCacheLastUpdated, $[15] = t5;
  } else
    t5 = $[15];
  let t6;
  return $[20] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t5 }), $[20] = t5, $[21] = t6) : t6 = $[21], t6;
}), GetDocuments = react.memo(function(props) {
  const $ = reactCompilerRuntime.c(6), {
    client,
    cache,
    ids,
    setDocumentsCacheLastUpdated
  } = props;
  let t0, t1;
  return $[0] !== cache || $[1] !== client || $[2] !== ids || $[3] !== setDocumentsCacheLastUpdated ? (t0 = () => {
    const missingIds = ids.filter((id) => !cache.has(id));
    missingIds.length !== 0 && client.getDocuments(missingIds).then((documents) => {
      for (const doc of documents)
        doc && doc != null && doc._id && (cache.set(doc._id, doc), setDocumentsCacheLastUpdated(Date.now()));
    }, console.error);
  }, t1 = [cache, client, ids, setDocumentsCacheLastUpdated], $[0] = cache, $[1] = client, $[2] = ids, $[3] = setDocumentsCacheLastUpdated, $[4] = t0, $[5] = t1) : (t0 = $[4], t1 = $[5]), react.useEffect(t0, t1), null;
});
GetDocuments.displayName = "GetDocuments";
function QuerySubscription(props) {
  const $ = reactCompilerRuntime.c(20), {
    cache,
    projectId,
    dataset,
    perspective,
    query,
    client,
    refreshInterval,
    liveDocument,
    comlink: comlink2,
    documentsCacheLastUpdated
  } = props, params = hooks.useQueryParams(props.params);
  let t0;
  $[0] !== cache || $[1] !== client || $[2] !== documentsCacheLastUpdated || $[3] !== liveDocument || $[4] !== params || $[5] !== perspective || $[6] !== query || $[7] !== refreshInterval ? (t0 = {
    cache,
    client,
    liveDocument,
    params,
    perspective,
    query,
    refreshInterval,
    documentsCacheLastUpdated
  }, $[0] = cache, $[1] = client, $[2] = documentsCacheLastUpdated, $[3] = liveDocument, $[4] = params, $[5] = perspective, $[6] = query, $[7] = refreshInterval, $[8] = t0) : t0 = $[8];
  const data = useQuerySubscription(t0), result = data == null ? void 0 : data.result, resultSourceMap = data == null ? void 0 : data.resultSourceMap, tags = data == null ? void 0 : data.tags;
  let t1, t2;
  return $[9] !== comlink2 || $[10] !== dataset || $[11] !== params || $[12] !== perspective || $[13] !== projectId || $[14] !== query || $[15] !== result || $[16] !== resultSourceMap || $[17] !== tags ? (t1 = () => {
    resultSourceMap && (comlink2 == null || comlink2.post("loader/query-change", {
      projectId,
      dataset,
      perspective,
      query,
      params,
      result,
      resultSourceMap,
      tags
    }));
  }, t2 = [comlink2, dataset, params, perspective, projectId, query, result, resultSourceMap, tags], $[9] = comlink2, $[10] = dataset, $[11] = params, $[12] = perspective, $[13] = projectId, $[14] = query, $[15] = result, $[16] = resultSourceMap, $[17] = tags, $[18] = t1, $[19] = t2) : (t1 = $[18], t2 = $[19]), react.useEffect(t1, t2), null;
}
function useQuerySubscription(props) {
  const {
    cache,
    liveDocument,
    client,
    refreshInterval,
    query,
    params,
    perspective,
    documentsCacheLastUpdated
  } = props, [snapshot, setSnapshot] = react.useState(null), {
    projectId: projectId_0,
    dataset: dataset_0
  } = react.useMemo(() => {
    const {
      projectId,
      dataset
    } = client.config();
    return {
      projectId,
      dataset
    };
  }, [client]), [error, setError] = react.useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = hooks.useRevalidate({
    refreshInterval
  }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  return react.useEffect(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = !1, fetching = !1;
    const controller = new AbortController();
    async function effect() {
      const {
        signal
      } = controller;
      fetching = !0;
      const {
        result,
        resultSourceMap,
        syncTags
      } = await client.fetch(query, params, {
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1
      });
      fetching = !1, signal.aborted || (setSnapshot({
        result,
        resultSourceMap,
        tags: syncTags
      }), fulfilled = !0);
    }
    const onFinally = startRefresh();
    return effect().catch((error_0) => {
      fetching = !1, error_0.name !== "AbortError" && setError(error_0);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [client, dataset_0, liveDocument, params, perspective, projectId_0, query, shouldRefetch, startRefresh]), react.useMemo(() => documentsCacheLastUpdated && snapshot != null && snapshot.resultSourceMap ? {
    result: turboChargeResultIfSourceMap(cache, liveDocument, snapshot.result, perspective, snapshot.resultSourceMap),
    resultSourceMap: snapshot.resultSourceMap
  } : snapshot, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot]);
}
let warnedAboutCrossDatasetReference = !1;
function turboChargeResultIfSourceMap(cache, liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return csm.applySourceDocuments(
    result,
    resultSourceMap,
    (sourceDocument) => {
      if (sourceDocument._projectId) {
        warnedAboutCrossDatasetReference || (console.warn("Cross dataset references are not supported yet, ignoring source document", sourceDocument), warnedAboutCrossDatasetReference = !0);
        return;
      }
      return liveDocument != null && liveDocument._id && csm.getPublishedId(liveDocument._id) === csm.getPublishedId(sourceDocument._id) ? liveDocument : cache.get(sourceDocument._id);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (changedValue, {
      previousValue
    }) => typeof changedValue == "number" && typeof previousValue == "string" ? `${changedValue}` : changedValue,
    perspective
  );
}
exports.default = LoaderQueries;
exports.turboChargeResultIfSourceMap = turboChargeResultIfSourceMap;
//# sourceMappingURL=LoaderQueries.cjs.map
