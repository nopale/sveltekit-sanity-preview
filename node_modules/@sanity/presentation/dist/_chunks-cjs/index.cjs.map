{"version":3,"file":"index.cjs","sources":["../../src/constants.ts","../../src/util/props.ts","../../src/useDocumentLocations.ts","../../src/i18n/index.ts","../../src/PresentationContext.ts","../../src/usePresentationTool.ts","../../src/document/useCurrentPresentationToolName.ts","../../src/document/LocationsBanner.tsx","../../src/document/PresentationDocumentContext.ts","../../src/document/PresentationDocumentHeader.tsx","../../src/document/PresentationDocumentProvider.tsx","../../src/fieldActions/openInStructure.ts","../../src/getIntentState.ts","../../src/PresentationSpinner.tsx","../../src/router.ts","../../src/plugin.tsx","../../src/PresentationNavigateContext.ts","../../src/usePresentationNavigate.ts","../../src/PresentationParamsContext.ts","../../src/usePresentationParams.ts","../../src/overlays/SharedStateContext.tsx","../../src/overlays/useSharedState.ts","../../../../node_modules/.pnpm/valibot@0.31.1/node_modules/valibot/dist/index.js","../../src/reducers/presentationReducer.ts"],"sourcesContent":["import {ComposeIcon} from '@sanity/icons'\n\nexport const DEFAULT_TOOL_ICON = ComposeIcon\nexport const DEFAULT_TOOL_NAME = 'presentation'\nexport const DEFAULT_TOOL_TITLE = 'Presentation'\n\n// @todo import from core sanity package\nexport const COMMENTS_INSPECTOR_NAME = 'sanity/structure/comments'\n\nexport const EDIT_INTENT_MODE = 'presentation'\n\n// How long we wait until an iframe is loaded until we consider it to be slow and possibly failed\nexport const MAX_TIME_TO_OVERLAYS_CONNECTION = 3_000 // ms\n\n// The API version to use when using `@sanity/client`\nexport const API_VERSION = '2023-10-16'\n\n// Heartbeats shouldn't fire on intervals that are so short it causes performance issues\nexport const MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL = 1000 // ms\n\n// Batch size for fetching documents building up the cache\nexport const LIVE_QUERY_CACHE_BATCH_SIZE = 100\n\n// Total cache size for documents that are live queried\nexport const LIVE_QUERY_CACHE_SIZE = 2048\n\n// The interval at which we check if existing popups have been closed\nexport const POPUP_CHECK_INTERVAL = 1000 // ms\n\ndeclare global {\n  const PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS: unknown\n}\n\n// Feature flag that uses the new Live Draft Content API instead of the Listen API + Mendoza events\nexport const LIVE_DRAFT_EVENTS_ENABLED =\n  typeof PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS === 'string'\n    ? PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS === 'true'\n    : // @ts-expect-error: env vars are not typed\n      process.env.SANITY_STUDIO_PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS === 'true'\n","import {\n  combineLatest,\n  from,\n  isObservable,\n  map,\n  mergeAll,\n  Observable,\n  of,\n  scan,\n  switchMap,\n} from 'rxjs'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Props<K extends keyof any, T> = {\n  [P in K]: T | Observable<T>\n}\n\nfunction keysOf<T extends object>(value: T) {\n  return Object.keys(value) as (keyof T)[]\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setKey(source: Record<string, unknown>, key: any, value: unknown) {\n  return {\n    ...source,\n    [key]: value,\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function props<K extends keyof any, T>(options: {wait?: boolean} = {}) {\n  return (source: Observable<Props<K, T>>): Observable<Record<string, unknown>> => {\n    return new Observable<Props<K, T>>((observer) => source.subscribe(observer)).pipe(\n      switchMap((object) => {\n        const keyObservables = keysOf(object).map((key) => {\n          const value = object[key]\n          return isObservable(value) ? from(value).pipe(map((val) => [key, val])) : of([key, value])\n        })\n\n        return options.wait\n          ? combineLatest(keyObservables).pipe(\n              map((pairs) => pairs.reduce((acc, [key, value]) => setKey(acc, key, value), {})),\n            )\n          : from(keyObservables).pipe(\n              mergeAll(),\n              scan((acc, [key, value]) => setKey(acc, key, value), {}),\n            )\n      }),\n    )\n  }\n}\n","import {get} from 'lodash'\nimport {useEffect, useMemo, useState} from 'react'\nimport {isObservable, map, Observable, of, switchMap} from 'rxjs'\nimport {\n  isRecord,\n  isReference,\n  useDocumentStore,\n  type DocumentStore,\n  type Previewable,\n  type SanityDocument,\n} from './internals'\nimport type {\n  DocumentLocationResolver,\n  DocumentLocationResolverObject,\n  DocumentLocationResolvers,\n  DocumentLocationsState,\n  DocumentLocationsStatus,\n} from './types'\nimport {props} from './util/props'\n\nconst INITIAL_STATE: DocumentLocationsState = {locations: []}\n\nfunction getDocumentId(value: Previewable) {\n  if (isReference(value)) {\n    return value._ref\n  }\n  return '_id' in value ? value._id : undefined\n}\n\nfunction cleanPreviewable(id: string | undefined, previewable: Previewable) {\n  const clean: Record<string, unknown> = id ? {...previewable, _id: id} : {...previewable}\n\n  if (clean['_type'] === 'reference') {\n    delete clean['_type']\n    delete clean['_ref']\n    delete clean['_weak']\n    delete clean['_dataset']\n    delete clean['_projectId']\n    delete clean['_strengthenOnPublish']\n  }\n\n  return clean\n}\n\nfunction listen(id: string, fields: string[], store: DocumentStore) {\n  const projection = fields.join(', ')\n  const query = `*[_id==$id][0]{${projection}}`\n  const params = {id}\n  return store.listenQuery(query, params, {\n    perspective: 'previewDrafts',\n  }) as Observable<SanityDocument | null>\n}\n\nfunction observeDocument(\n  value: Previewable | null,\n  paths: string[][],\n  store: DocumentStore,\n): Observable<Record<string, unknown> | null> {\n  if (!value || typeof value !== 'object') {\n    return of(value)\n  }\n\n  const id = getDocumentId(value)\n  const currentValue = cleanPreviewable(id, value)\n\n  const headlessPaths = paths.filter((path) => !(path[0] in currentValue))\n\n  if (id && headlessPaths.length) {\n    const fields = [...new Set(headlessPaths.map((path: string[]) => path[0]))]\n    return listen(id, fields, store).pipe(\n      switchMap((snapshot) => {\n        if (snapshot) {\n          return observeDocument(snapshot, paths, store)\n        }\n        return of(null)\n      }),\n    )\n  }\n\n  const leads: Record<string, string[][]> = {}\n  paths.forEach((path) => {\n    const [head, ...tail] = path\n    if (!leads[head]) {\n      leads[head] = []\n    }\n    leads[head].push(tail)\n  })\n  const next = Object.keys(leads).reduce((res: Record<string, unknown>, head) => {\n    const tails = leads[head].filter((tail) => tail.length > 0)\n    if (tails.length === 0) {\n      res[head] = isRecord(value) ? (value as Record<string, unknown>)[head] : undefined\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      res[head] = observeDocument((value as any)[head], tails, store)\n    }\n    return res\n  }, currentValue)\n\n  return of(next).pipe(props({wait: true}))\n}\n\nfunction observeForLocations(\n  documentId: string,\n  resolver: DocumentLocationResolverObject<string>,\n  documentStore: DocumentStore,\n) {\n  const {select} = resolver\n  const paths = Object.values(select).map((value) => String(value).split('.')) || []\n  const doc = {_type: 'reference', _ref: documentId}\n  return observeDocument(doc, paths, documentStore).pipe(\n    map((doc) => {\n      return Object.keys(select).reduce<Record<string, unknown>>((acc, key) => {\n        acc[key] = get(doc, select[key])\n        return acc\n      }, {})\n    }),\n    map(resolver.resolve),\n  )\n}\n\nexport function useDocumentLocations(props: {\n  id: string\n  resolvers?: DocumentLocationResolver | DocumentLocationResolvers\n  type: string\n}): {\n  state: DocumentLocationsState\n  status: DocumentLocationsStatus\n} {\n  const {id, resolvers, type} = props\n  const documentStore = useDocumentStore()\n  const [locationsState, setLocationsState] = useState<DocumentLocationsState>(INITIAL_STATE)\n\n  const resolver = resolvers && (typeof resolvers === 'function' ? resolvers : resolvers[type])\n\n  const [locationsStatus, setLocationsStatus] = useState<DocumentLocationsStatus>(\n    resolver ? 'resolving' : 'empty',\n  )\n\n  const result = useMemo(() => {\n    if (!resolver) return undefined\n\n    // Original/advanced resolver which requires explicit use of Observables\n    if (typeof resolver === 'function') {\n      const params = {id, type}\n      const context = {documentStore}\n      const _result = resolver(params, context)\n      return isObservable(_result) ? _result : of(_result)\n    }\n\n    // Simplified resolver pattern which abstracts away Observable logic\n    if ('select' in resolver && 'resolve' in resolver) {\n      return observeForLocations(id, resolver, documentStore)\n    }\n\n    // Resolver is explicitly provided state\n    return of(resolver)\n  }, [documentStore, id, resolver, type])\n\n  useEffect(() => {\n    const sub = result?.subscribe((state) => {\n      setLocationsState(state || INITIAL_STATE)\n      setLocationsStatus(state ? 'resolved' : 'empty')\n    })\n\n    return () => sub?.unsubscribe()\n  }, [result])\n\n  return {\n    state: locationsState,\n    status: locationsStatus,\n  }\n}\n","import {defineLocaleResourceBundle} from 'sanity'\n\n/**\n * The locale namespace for the presentation tool\n *\n * @public\n */\nexport const presentationLocaleNamespace = 'presentation' as const\n\n/**\n * The default locale bundle for the presentation tool, which is US English.\n *\n * @internal\n */\nexport const presentationUsEnglishLocaleBundle = defineLocaleResourceBundle({\n  locale: 'en-US',\n  namespace: presentationLocaleNamespace,\n  resources: () => import('./resources'),\n})\n","import {createContext} from 'react'\nimport type {\n  PresentationNavigate,\n  PresentationParams,\n  PresentationSearchParams,\n  StructureDocumentPaneParams,\n} from './types'\n\nexport interface PresentationContextValue {\n  devMode: boolean\n  name: string\n  navigate: PresentationNavigate\n  params: PresentationParams\n  structureParams: StructureDocumentPaneParams\n  searchParams: PresentationSearchParams\n}\n\nexport const PresentationContext = createContext<PresentationContextValue | null>(null)\n","import {useContext} from 'react'\nimport {PresentationContext, type PresentationContextValue} from './PresentationContext'\n\nexport function usePresentationTool(throwOnMissingContext?: true): PresentationContextValue\nexport function usePresentationTool(throwOnMissingContext: false): PresentationContextValue | null\nexport function usePresentationTool(throwOnMissingContext = true): PresentationContextValue | null {\n  const presentation = useContext(PresentationContext)\n\n  if (throwOnMissingContext && !presentation) {\n    throw new Error('Presentation context is missing')\n  }\n\n  return presentation\n}\n","import {usePresentationTool} from '../usePresentationTool'\n\nexport function useCurrentPresentationToolName(): string | undefined {\n  return usePresentationTool(false)?.name ?? undefined\n}\n","import {\n  ChevronRightIcon,\n  DesktopIcon,\n  ErrorOutlineIcon,\n  InfoOutlineIcon,\n  WarningOutlineIcon,\n} from '@sanity/icons'\nimport {Box, Card, Flex, Spinner, Stack, Text} from '@sanity/ui'\nimport {\n  createElement,\n  useCallback,\n  useContext,\n  useState,\n  type ComponentType,\n  type ReactNode,\n} from 'react'\nimport {useTranslation, type ObjectSchemaType} from 'sanity'\nimport {useIntentLink} from 'sanity/router'\nimport {DEFAULT_TOOL_NAME, DEFAULT_TOOL_TITLE} from '../constants'\nimport {presentationLocaleNamespace} from '../i18n'\nimport {PresentationContext} from '../PresentationContext'\nimport type {DocumentLocation, DocumentLocationsState, PresentationPluginOptions} from '../types'\nimport {useCurrentPresentationToolName} from './useCurrentPresentationToolName'\n\nconst TONE_ICONS: Record<'positive' | 'caution' | 'critical', ComponentType> = {\n  positive: InfoOutlineIcon,\n  caution: WarningOutlineIcon,\n  critical: ErrorOutlineIcon,\n}\n\nexport function LocationsBanner(props: {\n  documentId: string\n  isResolving: boolean\n  options: PresentationPluginOptions\n  schemaType: ObjectSchemaType\n  showPresentationTitle: boolean\n  state: DocumentLocationsState\n}): ReactNode {\n  const {documentId, isResolving, options, schemaType, showPresentationTitle} = props\n  const {locations, message, tone} = props.state\n  const len = locations?.length || 0\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n  const presentation = useContext(PresentationContext)\n  const presentationName = presentation?.name\n  const [expanded, setExpanded] = useState(false)\n  const toggle = useCallback(() => {\n    if (!len) return\n    setExpanded((v) => !v)\n  }, [len])\n\n  const title = isResolving\n    ? t('locations-banner.resolving.text')\n    : message || t('locations-banner.locations-count', {count: len})\n\n  return (\n    <Card padding={1} radius={2} border tone={tone}>\n      <div style={{margin: -1}}>\n        {!locations && (\n          <Flex align=\"flex-start\" gap={3} padding={3}>\n            {tone && (\n              <Box flex=\"none\">\n                <Text size={1}>{createElement(TONE_ICONS[tone])}</Text>\n              </Box>\n            )}\n            <Box flex={1}>\n              <Text size={1} weight=\"medium\">\n                {showPresentationTitle && <>{options.title || DEFAULT_TOOL_TITLE} &middot; </>}\n                {title}\n              </Text>\n            </Box>\n          </Flex>\n        )}\n        {locations && (\n          <>\n            <Card\n              as={len ? 'button' : undefined}\n              onClick={toggle}\n              padding={3}\n              radius={1}\n              tone=\"inherit\"\n            >\n              <Flex gap={3}>\n                <Box flex=\"none\">\n                  {isResolving ? (\n                    <Spinner size={1} />\n                  ) : (\n                    <Text size={1}>\n                      {len === 0 ? (\n                        <InfoOutlineIcon />\n                      ) : (\n                        <ChevronRightIcon\n                          style={{\n                            transform: `rotate(${expanded ? '90deg' : 0})`,\n                            transition: 'transform 100ms ease-in-out',\n                          }}\n                        />\n                      )}\n                    </Text>\n                  )}\n                </Box>\n                <Box flex={1}>\n                  <Text size={1} weight=\"medium\">\n                    {showPresentationTitle && <>{options.title || DEFAULT_TOOL_TITLE} &middot; </>}\n                    {title}\n                  </Text>\n                </Box>\n              </Flex>\n            </Card>\n            <Stack hidden={!expanded} marginTop={1} space={1}>\n              {locations.map((l, index) => (\n                <LocationItem\n                  active={\n                    (options.name || DEFAULT_TOOL_NAME) === presentationName &&\n                    l.href === presentation?.params.preview\n                  }\n                  documentId={documentId}\n                  documentType={schemaType.name}\n                  key={index}\n                  node={l}\n                  toolName={options.name || DEFAULT_TOOL_NAME}\n                />\n              ))}\n            </Stack>\n          </>\n        )}\n      </div>\n    </Card>\n  )\n}\n\nfunction LocationItem(props: {\n  active: boolean\n  documentId: string\n  documentType: string\n  node: DocumentLocation\n  toolName: string\n}) {\n  const {documentId, documentType, node, active, toolName} = props\n  const presentation = useContext(PresentationContext)\n  const currentPresentationToolName = useCurrentPresentationToolName()\n  const isCurrentTool = toolName === currentPresentationToolName\n  const navigate = presentation?.navigate\n\n  const presentationLinkProps = useIntentLink({\n    intent: 'edit',\n    params: {\n      id: documentId,\n      type: documentType,\n      mode: 'presentation',\n      presentation: toolName,\n      ...presentation?.structureParams,\n      preview: node.href,\n    },\n  })\n\n  const handleCurrentToolClick = useCallback(() => {\n    navigate?.({}, {preview: node.href})\n  }, [node.href, navigate])\n\n  return (\n    <Card\n      {...(isCurrentTool ? {} : presentationLinkProps)}\n      as=\"a\"\n      key={node.href}\n      onClick={isCurrentTool ? handleCurrentToolClick : presentationLinkProps.onClick}\n      padding={3}\n      radius={1}\n      pressed={active}\n      tone=\"inherit\"\n    >\n      <Flex gap={3}>\n        <Box flex=\"none\">\n          <Text size={1}>\n            <DesktopIcon />\n          </Text>\n        </Box>\n        <Stack flex={1} space={2}>\n          <Text size={1} weight=\"medium\">\n            {node.title}\n          </Text>\n          <Text muted size={1} textOverflow=\"ellipsis\">\n            {node.href}\n          </Text>\n        </Stack>\n      </Flex>\n    </Card>\n  )\n}\n","import {createContext} from 'react'\nimport type {PresentationDocumentContextValue} from './types'\n\nexport const PresentationDocumentContext = createContext<PresentationDocumentContextValue | null>(\n  null,\n)\n","import {rem, Stack} from '@sanity/ui'\nimport {useContext, type ReactNode} from 'react'\nimport {type ObjectSchemaType} from 'sanity'\nimport {styled} from 'styled-components'\nimport {type PublishedId} from '../internals'\nimport type {PresentationPluginOptions} from '../types'\nimport {useDocumentLocations} from '../useDocumentLocations'\nimport {LocationsBanner} from './LocationsBanner'\nimport {PresentationDocumentContext} from './PresentationDocumentContext'\n\nconst LocationStack = styled(Stack)`\n  min-height: ${rem(42)};\n\n  & + &:empty {\n    display: none;\n  }\n`\n\nexport function PresentationDocumentHeader(props: {\n  documentId: PublishedId\n  options: PresentationPluginOptions\n  schemaType: ObjectSchemaType\n}): ReactNode {\n  const {documentId, options, schemaType} = props\n\n  const context = useContext(PresentationDocumentContext)\n  const {state, status} = useDocumentLocations({\n    id: documentId,\n    resolvers: options.resolve?.locations || options.locate,\n    type: schemaType.name,\n  })\n\n  if ((context && context.options[0] !== options) || status === 'empty') {\n    return null\n  }\n\n  const contextOptions = context?.options || []\n\n  return (\n    <LocationStack marginBottom={5} space={5}>\n      <Stack space={2}>\n        {contextOptions.map((options, idx) => (\n          <LocationsBanner\n            documentId={documentId}\n            isResolving={status === 'resolving'}\n            key={idx}\n            options={options}\n            schemaType={schemaType}\n            showPresentationTitle={contextOptions.length > 1}\n            state={state}\n          />\n        ))}\n      </Stack>\n    </LocationStack>\n  )\n}\n","import {\n  useCallback,\n  useContext,\n  useLayoutEffect,\n  useMemo,\n  useState,\n  type ReactElement,\n  type ReactNode,\n} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {PresentationPluginOptions} from '../types'\nimport {PresentationDocumentContext} from './PresentationDocumentContext'\nimport type {PresentationDocumentContextValue} from './types'\n\n/** @internal */\nexport function PresentationDocumentProvider(props: {\n  children?: ReactNode\n  options: PresentationPluginOptions\n}): ReactElement {\n  const {children, options} = props\n  const parent = useContext(PresentationDocumentContext)\n  const parentRegister = parent?.register\n\n  const [optionsArray, setOptionsArray] = useState<PresentationPluginOptions[]>(() => [])\n\n  const register = useCallback(\n    (options: PresentationPluginOptions) => {\n      if (parentRegister) {\n        return parentRegister(options)\n      }\n\n      setOptionsArray((prev) => [options].concat(prev))\n\n      return () => {\n        setOptionsArray((prev) => prev.filter((o) => o !== options))\n      }\n    },\n    [parentRegister],\n  )\n\n  const context: PresentationDocumentContextValue = useMemo(\n    () => ({\n      options: parent?.options || optionsArray,\n      register,\n    }),\n    [optionsArray, parent, register],\n  )\n\n  const registerEffectEvent = useEffectEvent((options: PresentationPluginOptions) =>\n    register(options),\n  )\n  useLayoutEffect(() => registerEffectEvent(options), [registerEffectEvent, options])\n\n  return (\n    <PresentationDocumentContext.Provider value={context}>\n      {children}\n    </PresentationDocumentContext.Provider>\n  )\n}\n","import {MasterDetailIcon} from '@sanity/icons'\nimport {useContext, useMemo} from 'react'\nimport {type DocumentFieldActionGroup, type DocumentFieldActionProps, type Tool} from 'sanity'\nimport {useRouter} from 'sanity/router'\nimport {\n  defineDocumentFieldAction,\n  isRecord,\n  pathToString,\n  useWorkspace,\n  type DocumentFieldActionItem,\n} from '../internals'\nimport {PresentationContext} from '../PresentationContext'\n\nfunction useOpenInStructureAction(\n  props: DocumentFieldActionProps,\n): DocumentFieldActionItem | DocumentFieldActionGroup {\n  const {documentId, documentType, path} = props\n\n  const workspace = useWorkspace()\n  const {navigateIntent} = useRouter()\n  const presentation = useContext(PresentationContext)\n\n  const defaultStructureTool = useMemo(\n    () => findStructureTool(workspace.tools, documentId, documentType),\n    [documentId, documentType, workspace.tools],\n  )\n  const handleAction = () => {\n    navigateIntent('edit', {\n      id: documentId,\n      type: documentType,\n      mode: 'structure',\n      path: pathToString(path),\n    })\n  }\n\n  return {\n    type: 'action',\n    hidden: !presentation || path.length > 0 || !defaultStructureTool,\n    icon: defaultStructureTool?.icon || MasterDetailIcon,\n    title: `Open in ${defaultStructureTool?.title || 'Structure'}`,\n    onAction: handleAction,\n    renderAsButton: true,\n  }\n}\n\nexport const openInStructure = defineDocumentFieldAction({\n  name: 'presentation/openInStructure',\n  useAction: useOpenInStructureAction,\n})\n\nfunction findStructureTool(\n  tools: Tool[],\n  documentId: string,\n  documentType: string,\n): Tool | undefined {\n  const results = tools.map((t) => {\n    const match = t.canHandleIntent?.(\n      'edit',\n      {\n        id: documentId,\n        type: documentType,\n        mode: 'structure',\n      },\n      {},\n    )\n\n    return {tool: t, match}\n  })\n\n  const modeMatches = results.filter((t) => isRecord(t.match) && t.match['mode'])\n\n  if (modeMatches.length > 0) {\n    return modeMatches[0].tool\n  }\n\n  const matches = results.filter((t) => t.match)\n\n  return matches[0]?.tool\n}\n","import {uuid} from '@sanity/uuid'\nimport {type RouterState, type SearchParam} from 'sanity/router'\nimport {encodeJsonParams, getPublishedId} from './internals'\nimport type {PresentationSearchParams, PresentationStateParams} from './types'\n\nconst preservedSearchParamKeys: Array<keyof PresentationSearchParams> = [\n  'preview',\n  'perspective',\n  'viewport',\n]\n\n/**\n * @internal\n */\nexport function getIntentState(\n  intent: string,\n  params: Record<string, string>,\n  routerState: RouterState | undefined,\n  payload: unknown,\n):\n  | (PresentationStateParams & {_searchParams: SearchParam[]})\n  | {intent: string; params: Record<string, string>; payload: unknown} {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {id, mode, path, presentation, type, ...searchParams} = params\n\n  const preservedSearchParams = (routerState?._searchParams || [])\n    // @todo Casting https://github.com/microsoft/TypeScript/issues/14520\n    .filter(([key]) => preservedSearchParamKeys.includes(key as keyof PresentationSearchParams))\n    .reduce((acc, [key, value]) => ({...acc, [key]: value}), {} as Record<string, string>)\n\n  const _searchParams = {\n    ...preservedSearchParams,\n    ...searchParams,\n  }\n\n  if (intent === 'edit' && id) {\n    _searchParams['preview'] =\n      _searchParams['preview'] || new URLSearchParams(window.location.search).get('preview') || '/'\n    return {\n      type: type || '*',\n      id: getPublishedId(id),\n      path,\n      _searchParams: Object.entries(_searchParams),\n    }\n  }\n\n  if (intent === 'create') {\n    _searchParams['preview'] =\n      _searchParams['preview'] || new URLSearchParams(window.location.search).get('preview') || '/'\n\n    if (payload && typeof payload === 'object') {\n      _searchParams['templateParams'] = encodeJsonParams(payload as Record<string, unknown>)\n    }\n\n    return {\n      type: type || '*',\n      id: id || uuid(),\n      _searchParams: Object.entries(_searchParams),\n    }\n  }\n  return {intent, params, payload}\n}\n","import {Flex, Spinner} from '@sanity/ui'\n\nexport function PresentationSpinner(): React.JSX.Element {\n  return (\n    <Flex align=\"center\" direction=\"column\" height=\"fill\" justify=\"center\" style={{width: '100%'}}>\n      <Spinner />\n    </Flex>\n  )\n}\n","import {route} from 'sanity/router'\n\nexport const router = route.create('/', {__unsafe_disableScopedSearchParams: true}, [\n  route.intents('/intent'),\n  route.create(':type', [route.create(':id', [route.create(':path')])]),\n])\n","import type {SanityDocument} from '@sanity/client'\nimport {lazy, Suspense} from 'react'\nimport {definePlugin, isDocumentSchemaType, type InputProps} from 'sanity'\nimport {DEFAULT_TOOL_ICON, DEFAULT_TOOL_NAME, EDIT_INTENT_MODE} from './constants'\nimport {PresentationDocumentHeader} from './document/PresentationDocumentHeader'\nimport {PresentationDocumentProvider} from './document/PresentationDocumentProvider'\nimport {openInStructure} from './fieldActions/openInStructure'\nimport {getIntentState} from './getIntentState'\nimport {presentationUsEnglishLocaleBundle} from './i18n'\nimport {getPublishedId} from './internals'\nimport {PresentationSpinner} from './PresentationSpinner'\nimport {router} from './router'\nimport type {\n  DocumentLocationResolverObject,\n  DocumentLocationsState,\n  DocumentResolver,\n  PresentationPluginOptions,\n} from './types'\n\nconst PresentationTool = lazy(() => import('./PresentationToolGrantsCheck'))\nconst BroadcastDisplayedDocument = lazy(() => import('./loader/BroadcastDisplayedDocument'))\n\n/**\n * Define locations for a given document type.\n * This function doesn't do anything itself, it is used to provide type information.\n * @param resolver - resolver that return locations for a document.\n * @public\n */\nexport function defineLocations<K extends string>(\n  resolver: DocumentLocationResolverObject<K> | DocumentLocationsState,\n): typeof resolver {\n  return resolver\n}\n\n/**\n * Define documents for a given location.\n * This function doesn't do anything itself, it is used to provide type information.\n * @param resolvers - resolvers that return documents.\n * @public\n */\nexport function defineDocuments(resolvers: DocumentResolver[]): typeof resolvers {\n  return resolvers\n}\n\nexport const presentationTool = definePlugin<PresentationPluginOptions>((options) => {\n  const toolName = options.name || DEFAULT_TOOL_NAME\n\n  if ('locate' in options) {\n    // eslint-disable-next-line no-console\n    console.warn('Presentationâ€™s `locate` option is deprecated. Use `resolve.locations` instead.')\n  }\n\n  const hasLocationsResolver = !!(options.resolve?.locations || options.locate)\n\n  function PresentationDocumentInput(props: InputProps) {\n    const value = props.value as SanityDocument\n    const documentId = value?._id ? getPublishedId(value?._id) : undefined\n\n    if (isDocumentSchemaType(props.schemaType)) {\n      return (\n        <PresentationDocumentProvider options={options}>\n          {hasLocationsResolver && documentId && (\n            <PresentationDocumentHeader\n              documentId={documentId}\n              options={options}\n              schemaType={props.schemaType}\n            />\n          )}\n          <Suspense fallback={<PresentationSpinner />}>{props.renderDefault(props)}</Suspense>\n          <Suspense key=\"broadcast-displayed-document\">\n            <BroadcastDisplayedDocument key={documentId} value={value} />\n          </Suspense>\n        </PresentationDocumentProvider>\n      )\n    }\n\n    return props.renderDefault(props)\n  }\n\n  function canHandleCreateIntent(params: Record<string, unknown>) {\n    // We can't handle create intents without a `type` parameter\n    if (!('type' in params)) {\n      return false\n    }\n\n    if ('presentation' in params && params['presentation'] !== toolName) {\n      return false\n    }\n\n    return 'template' in params ? {template: true} : true\n  }\n\n  function canHandleEditIntent(params: Record<string, unknown>) {\n    // We can't handle edit intents without `type` or `id` parameters\n    if (!('type' in params) || !('id' in params)) {\n      return false\n    }\n\n    if ('presentation' in params && params['presentation'] !== toolName) {\n      return false\n    }\n\n    return 'mode' in params ? {mode: params['mode'] === EDIT_INTENT_MODE} : true\n  }\n\n  return {\n    i18n: {\n      bundles: [presentationUsEnglishLocaleBundle],\n    },\n    document: {\n      unstable_fieldActions: (prev) => {\n        return [\n          ...prev.filter((a) => a.name !== openInStructure.name), // prevent duplication\n          openInStructure,\n        ]\n      },\n    },\n\n    form: {\n      components: {\n        input: PresentationDocumentInput,\n      },\n    },\n\n    tools: [\n      {\n        icon: options.icon || DEFAULT_TOOL_ICON,\n        name: toolName,\n        title: options.title,\n        component: PresentationTool,\n        options,\n        canHandleIntent(intent, params) {\n          if (intent === 'create') return canHandleCreateIntent(params)\n          if (intent === 'edit') return canHandleEditIntent(params)\n          return false\n        },\n        getIntentState,\n        router,\n      },\n    ],\n  }\n})\n","import {createContext} from 'react'\n\nexport type PresentationNavigateContextValue = (\n  preview: string | undefined,\n  document?: {type: string; id: string},\n) => void\n\nexport const PresentationNavigateContext = createContext<PresentationNavigateContextValue | null>(\n  null,\n)\n","import {useContext} from 'react'\nimport {\n  PresentationNavigateContext,\n  type PresentationNavigateContextValue,\n} from './PresentationNavigateContext'\n\nexport function usePresentationNavigate(): PresentationNavigateContextValue {\n  const navigate = useContext(PresentationNavigateContext)\n\n  if (!navigate) {\n    throw new Error('Presentation navigate context is missing')\n  }\n\n  return navigate\n}\n\nexport type {PresentationNavigateContextValue}\n","import {createContext} from 'react'\nimport type {PresentationParams} from './types'\n\nexport const PresentationParamsContext = createContext<PresentationParams | null>(null)\n","import {useContext} from 'react'\nimport {PresentationParamsContext} from './PresentationParamsContext'\nimport type {PresentationParams} from './types'\n\n/** @public */\nexport function usePresentationParams(throwOnMissingContext?: true): PresentationParams\n/** @public */\nexport function usePresentationParams(throwOnMissingContext: false): PresentationParams | null\n/** @public */\nexport function usePresentationParams(throwOnMissingContext = true): PresentationParams | null {\n  const params = useContext(PresentationParamsContext)\n\n  if (throwOnMissingContext && !params) {\n    throw new Error('Presentation params context is missing')\n  }\n\n  return params\n}\n","import type {Serializable} from '@repo/visual-editing-helpers'\nimport {createContext} from 'react'\n\nexport interface SharedStateContextValue {\n  removeValue: (key: string) => void\n  setValue: (key: string, value: Serializable) => void\n}\n\nexport const SharedStateContext = createContext<SharedStateContextValue | null>(null)\n","import type {Serializable} from '@repo/visual-editing-helpers'\nimport {useContext, useEffect} from 'react'\nimport {SharedStateContext} from './SharedStateContext'\n\nexport const useSharedState = (key: string, value: Serializable): undefined => {\n  const context = useContext(SharedStateContext)\n\n  if (!context) {\n    throw new Error('Preview Snapshots context is missing')\n  }\n\n  const {setValue} = context\n\n  useEffect(() => {\n    setValue(key, value)\n  }, [key, value, setValue])\n\n  return undefined\n}\n","// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly,\n    skipPipe: config2?.skipPipe\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2)\n    store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3)\n    store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4)\n    store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference))\n    store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  let type = typeof input;\n  if (type === \"object\") {\n    type = (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type === \"string\" ? `\"${input}\"` : type === \"number\" || type === \"bigint\" || type === \"boolean\" ? `${input}` : type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly,\n    skipPipe: config2.skipPipe\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = (\n    // @ts-expect-error\n    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang)\n  );\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isAllowedObjectKey/_isAllowedObjectKey.ts\nfunction _isAllowedObjectKey(key) {\n  return key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (\"key\" in item && (typeof item.key === \"string\" || typeof item.key === \"number\")) {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/every/every.ts\nfunction every(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every\",\n    reference: every,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/some/some.ts\nfunction some(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some\",\n    reference: some,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    action,\n    _run(dataset) {\n      dataset.value = action(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    action,\n    async _run(dataset) {\n      dataset.value = await action(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, dataset, config2) }\n      ) : dataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date && !isNaN(dataset.value.getTime())) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isAllowedObjectKey(key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isAllowedObjectKey(entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"record\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"record\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isAllowedObjectKey(key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"record\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"record\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key: items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key: items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(items.length).map(async (value2, key) => {\n              return [\n                key + items.length,\n                value2,\n                await rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        dataset = pipe2[index]._run(dataset, config2);\n        const nextAction = pipe2[index + 1];\n        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!\n        nextAction?.kind === \"schema\" || nextAction?.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        dataset = await pipe2[index]._run(dataset, config2);\n        const nextAction = pipe2[index + 1];\n        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!\n        nextAction?.kind === \"schema\" || nextAction?.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isAllowedObjectKey,\n  _isLuhnAlgo,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_,\n  every,\n  excludes,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  readonly,\n  record,\n  recordAsync,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  some,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_\n};\n","import type {Dispatch, Reducer} from 'react'\nimport {boolean, fallback, object, parse, picklist} from 'valibot'\n\nexport interface PresentationState {\n  mainDocument: boolean\n  iframe: {\n    status: 'loading' | 'loaded' | 'refreshing' | 'reloading'\n  }\n  visualEditing: {\n    overlaysEnabled: boolean\n  }\n}\n\nexport const ACTION_IFRAME_LOADED = 'ACTION_IFRAME_LOADED'\nexport const ACTION_IFRAME_REFRESH = 'ACTION_IFRAME_REFRESH'\nexport const ACTION_IFRAME_RELOAD = 'ACTION_IFRAME_RELOAD'\nexport const ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE = 'ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE'\n\nexport interface IframeLoadedAction {\n  type: typeof ACTION_IFRAME_LOADED\n}\nexport interface IframeRefreshAction {\n  type: typeof ACTION_IFRAME_REFRESH\n}\nexport interface IframeReloadAction {\n  type: typeof ACTION_IFRAME_RELOAD\n}\nexport interface VisualEditingOverlaysToggleAction {\n  type: typeof ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE\n  enabled: boolean\n}\n\nexport type PresentationAction =\n  | IframeLoadedAction\n  | IframeRefreshAction\n  | IframeReloadAction\n  | VisualEditingOverlaysToggleAction\n\nexport const presentationReducer: Reducer<\n  Readonly<PresentationState>,\n  Readonly<PresentationAction>\n> = (state, action) => {\n  switch (action.type) {\n    case ACTION_IFRAME_LOADED:\n      return state.iframe.status === 'loaded'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'loaded',\n            },\n          }\n    case ACTION_IFRAME_REFRESH:\n      return state.iframe.status === 'refreshing'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'refreshing',\n            },\n          }\n    case ACTION_IFRAME_RELOAD:\n      return state.iframe.status === 'reloading'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'reloading',\n            },\n          }\n    case ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE:\n      return toggleVisualEditingOverlays(state, action)\n    default:\n      return state\n  }\n}\n\nconst toggleVisualEditingOverlays: Reducer<\n  Readonly<PresentationState>,\n  Readonly<VisualEditingOverlaysToggleAction>\n> = (state, action) => {\n  if (state.visualEditing.overlaysEnabled === action.enabled) return state\n  return {\n    ...state,\n    visualEditing: {\n      ...state.visualEditing,\n      overlaysEnabled: action.enabled,\n    },\n  }\n}\n\nconst mainDocumentSchema = fallback(boolean(), false)\n\nconst iframeStatusSchema = picklist(['loading', 'loaded', 'refreshing', 'reloading'])\n\nconst initStateSchema = object({\n  mainDocument: mainDocumentSchema,\n  iframe: object({\n    status: iframeStatusSchema,\n  }),\n  visualEditing: object({overlaysEnabled: boolean()}),\n})\n\nconst INITIAL_PRESENTATION_STATE = {\n  mainDocument: false,\n  iframe: {\n    status: 'loading',\n  },\n  visualEditing: {\n    overlaysEnabled: false,\n  },\n} as const satisfies PresentationState\n\nexport function presentationReducerInit(\n  state: Readonly<Partial<PresentationState>>,\n): Readonly<PresentationState> {\n  return parse(initStateSchema, {...INITIAL_PRESENTATION_STATE, ...state})\n}\n\nexport type DispatchPresentationAction = Dispatch<Readonly<PresentationAction>>\n"],"names":["DEFAULT_TOOL_ICON","ComposeIcon","DEFAULT_TOOL_NAME","DEFAULT_TOOL_TITLE","COMMENTS_INSPECTOR_NAME","EDIT_INTENT_MODE","MAX_TIME_TO_OVERLAYS_CONNECTION","API_VERSION","MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL","LIVE_QUERY_CACHE_BATCH_SIZE","LIVE_QUERY_CACHE_SIZE","POPUP_CHECK_INTERVAL","keysOf","value","Object","keys","setKey","source","key","__spreadProps","props","options","Observable","observer","subscribe","pipe","switchMap","object","keyObservables","map","isObservable","from","val","of","wait","combineLatest","pairs","reduce","acc","mergeAll","scan","INITIAL_STATE","locations","getDocumentId","isReference","_ref","_id","undefined","cleanPreviewable","id","previewable","clean","__spreadValues","listen","fields","store","query","join","params","listenQuery","perspective","observeDocument","paths","currentValue","headlessPaths","filter","path","length","Set","snapshot","leads","forEach","head","tail","push","next","res","tails","isRecord","observeForLocations","documentId","resolver","documentStore","select","values","String","split","_type","doc","get","resolve","useDocumentLocations","$","_c","resolvers","type","useDocumentStore","locationsState","setLocationsState","useState","locationsStatus","setLocationsStatus","t0","bb0","t1","_result","result","t2","sub","state","unsubscribe","useEffect","t3","status","presentationLocaleNamespace","presentationUsEnglishLocaleBundle","defineLocaleResourceBundle","locale","namespace","resources","PresentationContext","createContext","usePresentationTool","throwOnMissingContext","presentation","useContext","Error","useCurrentPresentationToolName","name","TONE_ICONS","positive","InfoOutlineIcon","caution","WarningOutlineIcon","critical","ErrorOutlineIcon","LocationsBanner","isResolving","schemaType","showPresentationTitle","message","tone","len","t","useTranslation","presentationName","expanded","setExpanded","_temp","toggle","count","title","Symbol","for","margin","jsxs","Flex","jsx","Box","Text","createElement","t4","Fragment","Card","Spinner","ChevronRightIcon","transform","transition","Stack","l","index","href","preview","t5","t6","v","LocationItem","documentType","node","active","toolName","currentPresentationToolName","isCurrentTool","navigate","structureParams","intent","mode","presentationLinkProps","useIntentLink","handleCurrentToolClick","onClick","DesktopIcon","t7","t8","t9","PresentationDocumentContext","LocationStack","styled","rem","PresentationDocumentHeader","context","locate","contextOptions","options_0","idx","PresentationDocumentProvider","children","parent","parentRegister","register","optionsArray","setOptionsArray","prev","concat","prev_0","o","options_1","registerEffectEvent","useEffectEvent","useLayoutEffect","useOpenInStructureAction","workspace","useWorkspace","navigateIntent","useRouter","tools","findStructureTool","defaultStructureTool","pathToString","handleAction","icon","MasterDetailIcon","hidden","onAction","renderAsButton","openInStructure","defineDocumentFieldAction","useAction","results","match","canHandleIntent","tool","modeMatches","matches","preservedSearchParamKeys","getIntentState","routerState","payload","searchParams","preservedSearchParams","_searchParams","includes","URLSearchParams","window","location","search","getPublishedId","entries","encodeJsonParams","uuid","PresentationSpinner","width","router","route","create","__unsafe_disableScopedSearchParams","intents","PresentationTool","lazy","BroadcastDisplayedDocument","defineLocations","defineDocuments","presentationTool","definePlugin","console","warn","hasLocationsResolver","PresentationDocumentInput","isDocumentSchemaType","renderDefault","Suspense","canHandleCreateIntent","template","canHandleEditIntent","i18n","bundles","document","unstable_fieldActions","a","form","components","input","component","PresentationNavigateContext","usePresentationNavigate","PresentationParamsContext","usePresentationParams","SharedStateContext","useSharedState","setValue","getGlobalConfig","config2","lang","abortEarly","abortPipeEarly","skipPipe","store2","getGlobalMessage","store3","getSchemaMessage","store4","getSpecificMessage","reference","_stringify","getPrototypeOf","constructor","_addIssue","label","dataset","other","expected","expects","received","issue","kind","requirement","issues","isSchema","typed","_isAllowedObjectKey","ValiError","minLength","async","_run","getFallback","schema","fallback","fallback2","getDefault","default","boolean","value2","valueDataset","pathItem","origin","unshift","optional","wrapped","args","picklist","record","entryKey","entryValue","keyDataset","string","unknown","parse","pipe2","nextAction","ACTION_IFRAME_LOADED","ACTION_IFRAME_REFRESH","ACTION_IFRAME_RELOAD","ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE","presentationReducer","action","iframe","toggleVisualEditingOverlays","visualEditing","overlaysEnabled","enabled","mainDocumentSchema","iframeStatusSchema","initStateSchema","mainDocument","INITIAL_PRESENTATION_STATE","presentationReducerInit"],"mappings":"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","x_google_ignoreList":[22]}