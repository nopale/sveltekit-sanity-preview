{"version":3,"file":"PostMessageSchema.cjs","sources":["../../src/overlays/schema/helpers.ts","../../src/overlays/schema/SchemaIcon.tsx","../../src/overlays/schema/extract.ts","../../src/overlays/schema/PostMessageSchema.tsx"],"sourcesContent":["import {\n  type ArraySchemaType,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type SchemaType as SanitySchemaType,\n  type Schema as SchemaDef,\n  type StringSchemaType,\n} from '@sanity/types'\nimport {type SchemaType} from 'groq-js'\n\nexport function isFieldRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let required = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'required') {\n            required = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (required) {\n        return true\n      }\n    }\n\n    if (typeof rule === 'object' && rule !== null && '_required' in rule) {\n      if (rule._required === 'required') {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction isType(\n  typeDef: SanitySchemaType | ObjectField | ObjectFieldType,\n  typeName: string,\n): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\nexport function isObjectType(typeDef: SanitySchemaType): typeDef is ObjectSchemaType {\n  return isType(typeDef, 'object') || typeDef.jsonType === 'object' || 'fields' in typeDef\n}\nexport function isArrayType(typeDef: SanitySchemaType): typeDef is ArraySchemaType {\n  return isType(typeDef, 'array')\n}\nexport function isReferenceType(typeDef: SanitySchemaType): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\n// @todo\nexport function isCrossDatasetReferenceType(typeDef: SanitySchemaType): boolean {\n  return isType(typeDef, 'crossDatasetReference')\n}\nexport function isStringType(typeDef: SanitySchemaType): typeDef is StringSchemaType {\n  return isType(typeDef, 'string')\n}\nexport function isNumberType(typeDef: SanitySchemaType): typeDef is NumberSchemaType {\n  return isType(typeDef, 'number')\n}\n\n// Traverse the type tree and return the \"last\" type, ie deepest type in the tree\nexport function lastType(typeDef: SanitySchemaType): SanitySchemaType | undefined {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (!type.type) {\n      return type\n    }\n    type = type.type\n  }\n\n  return undefined\n}\n\n// Traverse the type tree and gather all the fields\nexport function gatherFields(type: SanitySchemaType | ObjectSchemaType): ObjectField[] {\n  if ('fields' in type) {\n    return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n  }\n\n  return []\n}\n\n// Sorts the types by their dependencies by using a topological sort depth-first algorithm.\nexport function sortByDependencies(compiledSchema: SchemaDef): string[] {\n  const seen = new Set<SanitySchemaType>()\n\n  // Walks the dependencies of a schema type and adds them to the dependencies set\n  function walkDependencies(\n    schemaType: SanitySchemaType,\n    dependencies: Set<SanitySchemaType>,\n  ): void {\n    if (seen.has(schemaType)) {\n      return\n    }\n    seen.add(schemaType)\n\n    if ('fields' in schemaType) {\n      for (const field of gatherFields(schemaType)) {\n        const last = lastType(field.type)\n        if (last!.name === 'document') {\n          dependencies.add(last!)\n          continue\n        }\n\n        let schemaTypeName: string | undefined\n        if (schemaType.type!.type) {\n          schemaTypeName = field.type.type!.name\n        } else if ('jsonType' in schemaType.type!) {\n          schemaTypeName = field.type.jsonType\n        }\n\n        if (schemaTypeName === 'object' || schemaTypeName === 'block') {\n          if (isReferenceType(field.type)) {\n            field.type.to.forEach((ref) => dependencies.add(ref.type!))\n          } else {\n            dependencies.add(field.type)\n          }\n        }\n        walkDependencies(field.type, dependencies)\n      }\n    } else if ('of' in schemaType) {\n      for (const item of schemaType.of) {\n        walkDependencies(item, dependencies)\n      }\n    }\n  }\n  const dependencyMap = new Map<SanitySchemaType, Set<SanitySchemaType>>()\n  compiledSchema.getTypeNames().forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName)\n    if (schemaType === undefined || schemaType.type === null) {\n      return\n    }\n    const dependencies = new Set<SanitySchemaType>()\n\n    walkDependencies(schemaType, dependencies)\n    dependencyMap.set(schemaType, dependencies)\n    seen.clear() // Clear the seen set for the next type\n  })\n\n  // Sorts the types by their dependencies\n  const typeNames: string[] = []\n  // holds a temporary mark for types that are currently being visited, to detect cyclic dependencies\n  const currentlyVisiting = new Set<SanitySchemaType>()\n\n  // holds a permanent mark for types that have been already visited\n  const visited = new Set<SanitySchemaType>()\n\n  // visit implements a depth-first search\n  function visit(type: SanitySchemaType) {\n    if (visited.has(type)) {\n      return\n    }\n    // If we find a type that is already in the temporary mark, we have a cyclic dependency.\n    if (currentlyVisiting.has(type)) {\n      return\n    }\n    // mark this as a temporary mark, meaning it's being visited\n    currentlyVisiting.add(type)\n    const deps = dependencyMap.get(type)\n    if (deps !== undefined) {\n      deps.forEach((dep) => visit(dep))\n    }\n    currentlyVisiting.delete(type)\n    visited.add(type)\n\n    if (!typeNames.includes(type.name)) {\n      typeNames.unshift(type.name)\n    }\n  }\n  // Visit all types in the dependency map\n  for (const [type] of dependencyMap) {\n    visit(type)\n  }\n\n  return typeNames\n}\n","import {type SchemaType as SanitySchemaType} from '@sanity/types'\nimport {ThemeProvider, type ThemeContextValue} from '@sanity/ui'\nimport {createElement, type FunctionComponent} from 'react'\nimport {ServerStyleSheet, StyleSheetManager} from 'styled-components'\n\nexport const SchemaIcon: FunctionComponent<{\n  schemaType: SanitySchemaType\n  theme: ThemeContextValue\n}> = function SchemaIcon({schemaType, theme: themeContext}) {\n  const {theme, scheme, tone} = themeContext\n  const sheet = new ServerStyleSheet()\n\n  return schemaType.icon ? (\n    <StyleSheetManager sheet={sheet.instance}>\n      <ThemeProvider theme={theme} scheme={scheme} tone={tone}>\n        {createElement(schemaType.icon)}\n      </ThemeProvider>\n    </StyleSheetManager>\n  ) : null\n}\n","import type {\n  SchemaArrayNode,\n  SchemaBooleanNode,\n  SchemaInlineNode,\n  SchemaNode,\n  SchemaNullNode,\n  SchemaNumberNode,\n  SchemaObjectField,\n  SchemaObjectNode,\n  SchemaStringNode,\n  SchemaType,\n  SchemaUnionNode,\n  SchemaUnionNodeOptions,\n  SchemaUnionOption,\n  SchemaUnknownNode,\n} from '@repo/visual-editing-helpers'\nimport type {InsertMenuOptions} from '@sanity/insert-menu'\nimport type {\n  ArraySchemaType,\n  NumberSchemaType,\n  ObjectSchemaType,\n  ReferenceSchemaType,\n  SchemaType as SanitySchemaType,\n  StringSchemaType,\n} from '@sanity/types'\nimport type {ThemeContextValue} from '@sanity/ui'\nimport {createElement} from 'react'\nimport {renderToString} from 'react-dom/server'\nimport type {Workspace} from 'sanity'\nimport {\n  gatherFields,\n  isArrayType,\n  isCrossDatasetReferenceType,\n  isFieldRequired,\n  isNumberType,\n  isObjectType,\n  isReferenceType,\n  isStringType,\n  lastType,\n  sortByDependencies,\n} from './helpers'\nimport {SchemaIcon} from './SchemaIcon'\n\nconst documentDefaultFields = (typeName: string): Record<string, SchemaObjectField> => ({\n  _id: {\n    type: 'objectField',\n    name: '_id',\n    value: {\n      type: 'string',\n    },\n  },\n  _type: {\n    type: 'objectField',\n    name: '_type',\n    value: {\n      type: 'string',\n      value: typeName,\n    },\n  },\n  _createdAt: {\n    type: 'objectField',\n    name: '_createdAt',\n    value: {\n      type: 'string',\n    },\n  },\n  _updatedAt: {\n    type: 'objectField',\n    name: '_updatedAt',\n    value: {\n      type: 'string',\n    },\n  },\n  _rev: {\n    type: 'objectField',\n    name: '_rev',\n    value: {\n      type: 'string',\n    },\n  },\n})\n\nfunction createStringNodeDefintion(\n  stringSchemaType: StringSchemaType,\n): SchemaStringNode | SchemaUnionNode<SchemaStringNode> {\n  const listOptions = stringSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'string',\n        value: typeof v === 'string' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'string',\n  }\n}\n\nfunction createNumberNodeDefintion(\n  numberSchemaType: NumberSchemaType,\n): SchemaNumberNode | SchemaUnionNode<SchemaNumberNode> {\n  const listOptions = numberSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'number',\n        value: typeof v === 'number' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'number',\n  }\n}\n\nfunction createReferenceNode(name: string, inArray: boolean = false): SchemaObjectNode {\n  const fields: Record<string, SchemaObjectField> = {\n    _ref: {\n      type: 'objectField',\n      name: '_ref',\n      value: {\n        type: 'string',\n      },\n    },\n    _type: {\n      type: 'objectField',\n      name: '_type',\n      value: {\n        type: 'string',\n        value: 'reference',\n      },\n    },\n    _weak: {\n      type: 'objectField',\n      name: '_weak',\n      value: {\n        type: 'boolean',\n      },\n      optional: true,\n    },\n  }\n\n  if (inArray) {\n    fields['_key'] = {\n      type: 'objectField',\n      name: '_key',\n      value: {\n        type: 'string',\n      },\n    } satisfies SchemaObjectField\n  }\n\n  return {\n    type: 'object',\n    fields,\n    dereferencesTo: name,\n  } satisfies SchemaObjectNode\n}\n\nfunction createReferenceNodeDefintion(\n  reference: ReferenceSchemaType,\n): SchemaObjectNode | SchemaUnionNode<SchemaObjectNode> {\n  const references = gatherReferenceNames(reference)\n  if (references.length === 1) {\n    return createReferenceNode(references[0])\n  }\n\n  return {\n    type: 'union',\n    of: references.map((name) => ({\n      type: 'unionOption',\n      name,\n      value: createReferenceNode(name),\n    })),\n  }\n}\n\n// Traverse the reference type tree and gather all the reference names\nfunction gatherReferenceNames(type: ReferenceSchemaType): string[] {\n  const allReferences = gatherReferenceTypes(type)\n  // Remove duplicates\n  return [...new Set([...allReferences.map((ref) => ref.name)])]\n}\n\nfunction gatherReferenceTypes(type: ReferenceSchemaType): ObjectSchemaType[] {\n  const refTo = 'to' in type ? type.to : []\n  if ('type' in type && isReferenceType(type.type!)) {\n    return [...gatherReferenceTypes(type.type), ...refTo]\n  }\n\n  return refTo\n}\n\nconst typesMap = new Map<string, Omit<SchemaStringNode, 'name'> | Omit<SchemaBooleanNode, 'name'>>([\n  ['text', {type: 'string'}],\n  ['url', {type: 'string'}],\n  ['datetime', {type: 'string'}],\n  ['date', {type: 'string'}],\n  ['boolean', {type: 'boolean'}],\n  ['email', {type: 'string'}],\n])\n\nexport function extractSchema(workspace: Workspace, theme: ThemeContextValue): SchemaType[] {\n  const inlineFields = new Set<SanitySchemaType>()\n  const {schema: schemaDef, basePath} = workspace\n\n  const sortedSchemaTypeNames = sortByDependencies(schemaDef)\n  return sortedSchemaTypeNames\n    .map((typeName) => {\n      const schemaType = schemaDef.get(typeName)\n      if (schemaType === undefined) {\n        return\n      }\n      const base = convertBaseType(schemaType)\n\n      if (base === null) {\n        return\n      }\n\n      if (base.type === 'type') {\n        inlineFields.add(schemaType)\n      }\n\n      return base\n    })\n    .filter((type: SchemaType | undefined): type is SchemaType => type !== undefined)\n\n  function extractIcon(schemaType: SanitySchemaType): string | undefined {\n    if (!schemaType.icon) return undefined\n    return renderToString(createElement(SchemaIcon, {schemaType, theme}))\n  }\n\n  function convertBaseType(schemaType: SanitySchemaType): SchemaType | null {\n    let typeName: string | undefined\n    if (schemaType.type) {\n      typeName = schemaType.type.name\n    } else if ('jsonType' in schemaType) {\n      typeName = schemaType.jsonType\n    }\n\n    if (typeName === 'document') {\n      const object = createObject(schemaType)\n      if (object.type === 'unknown') {\n        return null\n      }\n\n      return {\n        type: 'document',\n        name: schemaType.name,\n        title: typeof schemaType.title === 'string' ? schemaType.title : undefined,\n        icon: extractIcon(schemaType),\n        fields: {\n          ...documentDefaultFields(schemaType.name),\n          ...object.fields,\n        },\n      }\n    }\n\n    const value = convertSchemaType(schemaType)\n    if (value.type === 'unknown') {\n      return null\n    }\n\n    if (value.type === 'object') {\n      return {\n        name: schemaType.name,\n        type: 'type',\n        value: {\n          type: 'object',\n          fields: {\n            _type: {\n              type: 'objectField',\n              name: '_type',\n              value: {\n                type: 'string',\n                value: schemaType.name,\n              },\n            },\n            ...value.fields,\n          },\n        },\n      }\n    }\n\n    return {\n      name: schemaType.name,\n      title: typeof schemaType.title === 'string' ? schemaType.title : undefined,\n      type: 'type',\n      value,\n    }\n  }\n\n  function createObject(\n    schemaType: ObjectSchemaType | SanitySchemaType,\n  ): SchemaObjectNode | SchemaUnknownNode {\n    const fields: Record<string, SchemaObjectField> = {}\n\n    for (const field of gatherFields(schemaType)) {\n      const value = convertSchemaType(field.type)\n      if (value === null) {\n        continue\n      }\n\n      fields[field.name] = {\n        type: 'objectField',\n        name: field.name,\n        title: typeof field.type.title === 'string' ? field.type.title : undefined,\n        value,\n        optional: isFieldRequired(field) === false,\n      }\n    }\n\n    return {\n      type: 'object',\n      fields,\n    }\n  }\n\n  function convertSchemaType(schemaType: SanitySchemaType): SchemaNode {\n    if (lastType(schemaType)?.name === 'document') {\n      return createReferenceNode(schemaType.name)\n    }\n\n    if (inlineFields.has(schemaType.type!)) {\n      return {type: 'inline', name: schemaType.type!.name} satisfies SchemaInlineNode\n    }\n\n    if (schemaType.type?.type?.name === 'object') {\n      return {type: 'inline', name: schemaType.type.name} satisfies SchemaInlineNode\n    }\n\n    if (isStringType(schemaType)) {\n      return createStringNodeDefintion(schemaType)\n    }\n\n    if (isNumberType(schemaType)) {\n      return createNumberNodeDefintion(schemaType)\n    }\n\n    const mapped = typesMap.get(schemaType.type?.name || '')\n    if (mapped) {\n      return mapped\n    }\n\n    if (schemaType.type && typesMap.has(schemaType.type.name)) {\n      return typesMap.get(schemaType.type.name)!\n    }\n\n    // Cross dataset references are not supported\n    if (isCrossDatasetReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies SchemaUnknownNode // we don't support cross-dataset references at the moment\n    }\n\n    if (isReferenceType(schemaType)) {\n      return createReferenceNodeDefintion(schemaType)\n    }\n\n    if (isArrayType(schemaType)) {\n      return createArray(schemaType)\n    }\n\n    if (isObjectType(schemaType)) {\n      return createObject(schemaType)\n    }\n\n    throw new Error(`Type \"${schemaType.name}\" not found`)\n  }\n\n  function createUnionNodeOptions(\n    schemaType: ArraySchemaType,\n    of: SchemaUnionOption<SchemaNode>[],\n  ): SchemaUnionNodeOptions | undefined {\n    const {options} = schemaType\n    if (!options) return undefined\n    const opts = {\n      ...options,\n    }\n    if (options.insertMenu) {\n      opts.insertMenu = {\n        ...options.insertMenu,\n        views: (options.insertMenu as InsertMenuOptions).views?.map((view) =>\n          view.name === 'grid'\n            ? {\n                name: 'grid',\n                previewImageUrls: view.previewImageUrl\n                  ? of.reduce(\n                      (acc, {name}) => {\n                        const url = view.previewImageUrl?.(name)\n                        if (!url) return acc\n                        // If the URL is relative, make it absolute\n                        try {\n                          new URL(url)\n                          acc[name] = url\n                        } catch {\n                          acc[name] = new URL(\n                            url,\n                            `${window.location.origin}${basePath ? `${basePath}/` : ''}`,\n                          ).toString()\n                        }\n                        return acc\n                      },\n                      {} as Record<string, string | undefined>,\n                    )\n                  : undefined,\n              }\n            : view,\n        ),\n      }\n    }\n    return opts\n  }\n\n  function createArray(\n    arraySchemaType: ArraySchemaType,\n  ): SchemaArrayNode | SchemaUnionNode | SchemaNullNode {\n    const of: SchemaUnionOption[] = []\n    for (const item of arraySchemaType.of) {\n      let field = convertSchemaType(item)\n      const option = {\n        type: 'unionOption',\n        icon: extractIcon(item),\n        name: item.name,\n        title: typeof item.title === 'string' ? item.title : undefined,\n        value: field,\n      } satisfies SchemaUnionOption\n      if (field.type === 'inline') {\n        field = {\n          type: 'object',\n          fields: {\n            _key: createKeyField(),\n          },\n          rest: field,\n        } satisfies SchemaObjectNode\n      } else if (field.type === 'object') {\n        field.rest = {\n          type: 'object',\n          fields: {\n            _key: createKeyField(),\n          },\n        }\n      }\n      option.value = field\n      of.push(option)\n    }\n\n    if (of.length === 0) {\n      return {type: 'null'}\n    }\n\n    if (of.length > 1) {\n      return {\n        type: 'union',\n        of,\n        options: createUnionNodeOptions(arraySchemaType, of),\n      }\n    }\n\n    const {name, title, value} = of[0]\n    return {\n      type: 'array',\n      of: {\n        type: 'arrayItem',\n        name,\n        title: typeof title === 'string' ? title : undefined,\n        value,\n      },\n    }\n  }\n}\n\nfunction createKeyField(): SchemaObjectField<SchemaStringNode> {\n  return {\n    type: 'objectField',\n    name: '_key',\n    value: {\n      type: 'string',\n    },\n  }\n}\n","import type {UnresolvedPath} from '@repo/visual-editing-helpers'\nimport type {ClientPerspective} from '@sanity/client'\nimport {useRootTheme} from '@sanity/ui'\nimport {memo, useEffect} from 'react'\nimport {API_VERSION} from '../../constants'\nimport {useClient, useWorkspace} from '../../internals'\nimport type {VisualEditingConnection} from '../../types'\nimport {extractSchema} from './extract'\n\nexport interface PostMessageSchemaProps {\n  comlink: VisualEditingConnection\n  perspective: ClientPerspective\n}\n\nfunction getDocumentPathArray(paths: UnresolvedPath[]) {\n  const documentPathMap = paths.reduce(\n    (acc, {id, path}) => {\n      if (acc[id]) {\n        acc[id].add(path)\n      } else {\n        acc[id] = new Set<string>([path])\n      }\n      return acc\n    },\n    {} as Record<string, Set<string>>,\n  )\n\n  return Object.entries(documentPathMap)\n}\n\n/**\n * Experimental approach for sending a representation of the workspace schema\n * over postMessage so it can be used to enrich the Visual Editing experience\n */\nfunction PostMessageSchema(props: PostMessageSchemaProps): JSX.Element | null {\n  const {comlink, perspective} = props\n\n  const workspace = useWorkspace()\n  const theme = useRootTheme()\n\n  // Send a representation of the schema to the visual editing context\n  useEffect(() => {\n    const schema = extractSchema(workspace, theme)\n    /**\n     * @deprecated switch to explict schema fetching (using\n     * 'visual-editing/schema') at next major\n     */\n    comlink.post('presentation/schema', {schema})\n\n    return comlink.on('visual-editing/schema', () => ({schema}))\n  }, [comlink, theme, workspace])\n\n  const client = useClient({apiVersion: API_VERSION})\n\n  // Resolve union types from an array of unresolved paths\n  useEffect(() => {\n    return comlink.on('visual-editing/schema-union-types', async (data) => {\n      const documentPathArray = getDocumentPathArray(data.paths)\n      const unionTypes = await Promise.all(\n        documentPathArray.map(async ([id, paths]) => {\n          const arr = Array.from(paths)\n          const projection = arr.map((path, i) => `\"${i}\": ${path}[0]._type`).join(',')\n          const query = `*[_id == $id][0]{${projection}}`\n          const result = await client.fetch(query, {id}, {perspective, tag: 'presentation-schema'})\n          const mapped = arr.map((path, i) => ({path: path, type: result[i]}))\n          return {id, paths: mapped}\n        }),\n      )\n\n      const newState = new Map()\n      unionTypes.forEach((action) => {\n        newState.set(action.id, new Map(action.paths.map(({path, type}) => [path, type])))\n      })\n      return {types: newState}\n    })\n  }, [comlink, client, perspective])\n\n  return null\n}\n\nexport default memo(PostMessageSchema)\n"],"names":["isFieldRequired","field","validation","type","rules","Array","isArray","rule","required","proxy","Proxy","get","target","methodName","_required","isType","typeDef","typeName","name","isObjectType","jsonType","isArrayType","isReferenceType","isCrossDatasetReferenceType","isStringType","isNumberType","lastType","gatherFields","concat","fields","sortByDependencies","compiledSchema","seen","Set","walkDependencies","schemaType","dependencies","has","add","last","schemaTypeName","to","forEach","ref","item","of","dependencyMap","Map","getTypeNames","undefined","set","clear","typeNames","currentlyVisiting","visited","visit","deps","dep","delete","includes","unshift","SchemaIcon","t0","$","_c","theme","themeContext","scheme","tone","t1","Symbol","for","ServerStyleSheet","sheet","t2","icon","jsx","StyleSheetManager","instance","ThemeProvider","createElement","documentDefaultFields","_id","value","_type","_createdAt","_updatedAt","_rev","createStringNodeDefintion","stringSchemaType","listOptions","options","list","map","v","createNumberNodeDefintion","numberSchemaType","createReferenceNode","inArray","_ref","_weak","optional","dereferencesTo","createReferenceNodeDefintion","reference","references","gatherReferenceNames","length","allReferences","gatherReferenceTypes","refTo","typesMap","extractSchema","workspace","inlineFields","schema","schemaDef","basePath","base","convertBaseType","filter","extractIcon","renderToString","object","createObject","title","convertSchemaType","mapped","createArray","Error","createUnionNodeOptions","opts","insertMenu","views","view","previewImageUrls","previewImageUrl","reduce","acc","_a","url","URL","window","location","origin","toString","arraySchemaType","option","_key","createKeyField","rest","push","getDocumentPathArray","paths","documentPathMap","id","path","Object","entries","PostMessageSchema","props","comlink","perspective","useWorkspace","useRootTheme","post","on","useEffect","apiVersion","API_VERSION","client","useClient","t3","t4","data","documentPathArray","unionTypes","Promise","all","t5","arr","from","query","_temp","join","result","fetch","tag","path_0","i_0","i","newState","action","_temp2","types","path_1","memo"],"mappings":"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"}