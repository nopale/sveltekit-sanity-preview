"use strict";
var jsxRuntime = require("react/jsx-runtime"), reactCompilerRuntime = require("react-compiler-runtime"), constants = require("@sanity/preview-url-secret/constants"), ui = require("@sanity/ui"), uuid = require("@sanity/uuid"), react = require("react"), sanity = require("sanity"), index = require("./index.cjs"), comlink = require("@sanity/comlink"), csm = require("@sanity/client/csm"), router = require("sanity/router"), styledComponents = require("styled-components"), useEffectEvent = require("use-effect-event"), icons = require("@sanity/icons"), structure = require("sanity/structure"), DisplayedDocumentBroadcaster = require("./DisplayedDocumentBroadcaster.cjs"), framerMotion = require("framer-motion"), reactDom = require("react-dom"), withoutSecretSearchParams = require("@sanity/preview-url-secret/without-secret-search-params"), logos = require("@sanity/logos"), togglePreviewAccessSharing = require("@sanity/preview-url-secret/toggle-preview-access-sharing"), isEqual = require("fast-deep-equal"), pathToRegexp = require("path-to-regexp"), createSecret = require("@sanity/preview-url-secret/create-secret"), definePreviewUrl = require("@sanity/preview-url-secret/define-preview-url"), suspendReact = require("suspend-react");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual);
const RE_SEGMENT_WITH_INDEX = /^([\w-]+):(0|[1-9][0-9]*)$/, RE_SEGMENT_WITH_TUPLE = /^([\w-]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([\w-]+):([\w-]+)$/;
function urlStringToPath(str) {
  const path = [];
  for (const segment of str.split(".")) {
    const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);
    if (withIndex) {
      path.push(withIndex[1], Number(withIndex[2]));
      continue;
    }
    const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);
    if (withTuple) {
      path.push(withTuple[1], [Number(withTuple[2]), Number(withTuple[3])]);
      continue;
    }
    const withKey = RE_SEGMENT_WITH_KEY.exec(segment);
    if (withKey) {
      path.push(withKey[1], {
        _key: withKey[2]
      });
      continue;
    }
    path.push(segment);
  }
  return path;
}
const lengthyStr = index.pipe(index.string(), index.minLength(1)), optionalLengthyStr = index.optional(lengthyStr);
index.object({
  baseUrl: lengthyStr,
  dataset: optionalLengthyStr,
  id: lengthyStr,
  path: lengthyStr,
  projectId: optionalLengthyStr,
  tool: optionalLengthyStr,
  type: optionalLengthyStr,
  workspace: optionalLengthyStr,
  isDraft: index.optional(index.string())
});
index.object({
  origin: lengthyStr,
  href: lengthyStr,
  data: index.optional(index.record(index.string(), index.unknown()))
});
var __defProp$1$1 = Object.defineProperty, __defProps$1$1 = Object.defineProperties, __getOwnPropDescs$1$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1$1 = Object.getOwnPropertySymbols, __hasOwnProp$1$1 = Object.prototype.hasOwnProperty, __propIsEnum$1$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1$1 = (obj, key, value) => key in obj ? __defProp$1$1(obj, key, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value
}) : obj[key] = value, __spreadValues$1$1 = (a, b) => {
  for (var prop in b || (b = {})) __hasOwnProp$1$1.call(b, prop) && __defNormalProp$1$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$1) for (var prop of __getOwnPropSymbols$1$1(b)) __propIsEnum$1$1.call(b, prop) && __defNormalProp$1$1(a, prop, b[prop]);
  return a;
}, __spreadProps$1$1 = (a, b) => __defProps$1$1(a, __getOwnPropDescs$1$1(b)), __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source) __hasOwnProp$1$1.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$1$1) for (var prop of __getOwnPropSymbols$1$1(source)) exclude.indexOf(prop) < 0 && __propIsEnum$1$1.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
const channelsToComlinkMap = {
  "handshake/syn": comlink.MSG_HANDSHAKE_SYN,
  "handshake/syn-ack": comlink.MSG_HANDSHAKE_SYN_ACK,
  "handshake/ack": comlink.MSG_HANDSHAKE_ACK,
  "channel/response": comlink.MSG_RESPONSE,
  "channel/heartbeat": comlink.MSG_HEARTBEAT,
  "channel/disconnect": comlink.MSG_DISCONNECT,
  "overlay/focus": "visual-editing/focus",
  "overlay/navigate": "visual-editing/navigate",
  "overlay/toggle": "visual-editing/toggle",
  "presentation/toggleOverlay": "presentation/toggle-overlay"
}, comlinkToChannelsMap = {
  [comlink.MSG_HANDSHAKE_SYN]: "handshake/syn",
  [comlink.MSG_HANDSHAKE_SYN_ACK]: "handshake/syn-ack",
  [comlink.MSG_HANDSHAKE_ACK]: "handshake/ack",
  [comlink.MSG_RESPONSE]: "channel/response",
  [comlink.MSG_HEARTBEAT]: "channel/heartbeat",
  [comlink.MSG_DISCONNECT]: "channel/disconnect",
  "visual-editing/focus": "overlay/focus",
  "visual-editing/navigate": "overlay/navigate",
  "visual-editing/toggle": "overlay/toggle",
  "presentation/toggle-overlay": "presentation/toggleOverlay"
}, convertToComlinkEvent = (event) => {
  var _a;
  const {
    data
  } = event;
  return data && typeof data == "object" && "domain" in data && "type" in data && "from" in data && "to" in data && (data.domain === "sanity/channels" && (data.domain = comlink.DOMAIN), data.to === "overlays" && (data.to = "visual-editing"), data.from === "overlays" && (data.from = "visual-editing"), data.channelId = data.connectionId, delete data.connectionId, data.type = (_a = channelsToComlinkMap[data.type]) != null ? _a : data.type), event;
}, convertToChannelsMessage = (comlinkMessage) => {
  var _b;
  const _a = comlinkMessage, {
    channelId
  } = _a, rest = __objRest$3(_a, ["channelId"]), message = __spreadProps$1$1(__spreadValues$1$1({}, rest), {
    connectionId: channelId
  });
  return message.domain === comlink.DOMAIN && (message.domain = "sanity/channels"), message.to === "visual-editing" && (message.to = "overlays"), message.from === "visual-editing" && (message.from = "overlays"), message.type = (_b = comlinkToChannelsMap[message.type]) != null ? _b : message.type, message.type === "channel/response" && message.responseTo && !message.data && (message.data = {
    responseTo: message.responseTo
  }), (message.type === "handshake/syn" || message.type === "handshake/syn-ack" || message.type === "handshake/ack") && (message.data = {
    id: message.connectionId
  }), message;
}, sendAsChannelsMessage = ({
  context
}, params) => {
  const {
    sources,
    targetOrigin
  } = context, message = convertToChannelsMessage(params.message);
  sources.forEach((source) => {
    source.postMessage(message, {
      targetOrigin
    });
  });
}, createCompatibilityActors = () => ({
  listen: comlink.createListenLogic(convertToComlinkEvent),
  requestMachine: comlink.createRequestMachine().provide({
    actions: {
      "send message": sendAsChannelsMessage
    }
  })
});
function getQueryCacheKey(query, params) {
  return `${query}-${typeof params == "string" ? params : JSON.stringify(params)}`;
}
const IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), MODIFIERS = {
  alt: "altKey",
  ctrl: "ctrlKey",
  mod: IS_MAC ? "metaKey" : "ctrlKey",
  shift: "shiftKey"
};
function isHotkey(keys, event) {
  return keys.every((key) => MODIFIERS[key] ? event[MODIFIERS[key]] : event.key === key.toUpperCase());
}
function isAltKey(event) {
  return event.key === "Alt";
}
function debounce(fn, timeout) {
  let timer;
  return (...args) => {
    clearTimeout(timer), timer = setTimeout(() => {
      fn.apply(fn, args);
    }, timeout);
  };
}
const SharedStateProvider = function(props) {
  const $ = reactCompilerRuntime.c(14), {
    comlink: comlink2,
    children
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {}, $[0] = t0) : t0 = $[0];
  const sharedState = react.useRef(t0);
  let t1, t2;
  $[1] !== comlink2 ? (t1 = () => comlink2 == null ? void 0 : comlink2.on("visual-editing/shared-state", () => ({
    state: sharedState.current
  })), t2 = [comlink2], $[1] = comlink2, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), react.useEffect(t1, t2);
  let t3;
  $[4] !== comlink2 ? (t3 = (key, value) => {
    sharedState.current[key] = value, comlink2 == null || comlink2.post("presentation/shared-state", {
      key,
      value
    });
  }, $[4] = comlink2, $[5] = t3) : t3 = $[5];
  const setValue = t3;
  let t4;
  $[6] !== comlink2 ? (t4 = (key_0) => {
    comlink2 == null || comlink2.post("presentation/shared-state", {
      key: key_0
    }), delete sharedState.current[key_0];
  }, $[6] = comlink2, $[7] = t4) : t4 = $[7];
  const removeValue = t4;
  let t5, t6;
  $[8] !== removeValue || $[9] !== setValue ? (t6 = {
    removeValue,
    setValue
  }, $[8] = removeValue, $[9] = setValue, $[10] = t6) : t6 = $[10], t5 = t6;
  const context = t5;
  let t7;
  return $[11] !== children || $[12] !== context ? (t7 = /* @__PURE__ */ jsxRuntime.jsx(index.SharedStateContext.Provider, { value: context, children }), $[11] = children, $[12] = context, $[13] = t7) : t7 = $[13], t7;
}, PanelsContext = react.createContext(null);
PanelsContext.displayName = "PanelsContext";
const Root$1 = styledComponents.styled.div`
  overflow: hidden;
  flex-basis: 0;
  flex-shrink: 1;
`, Panel = function(t0) {
  const $ = reactCompilerRuntime.c(15), {
    children,
    defaultSize: t1,
    id,
    minWidth,
    maxWidth,
    order: t2
  } = t0, defaultSize = t1 === void 0 ? null : t1, order = t2 === void 0 ? 0 : t2, context = react.useContext(PanelsContext);
  if (context === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    getPanelStyle,
    registerElement,
    unregisterElement
  } = context;
  let t3;
  $[0] !== getPanelStyle || $[1] !== id ? (t3 = getPanelStyle(id), $[0] = getPanelStyle, $[1] = id, $[2] = t3) : t3 = $[2];
  const style = t3;
  let t4, t5;
  $[3] !== defaultSize || $[4] !== id || $[5] !== maxWidth || $[6] !== minWidth || $[7] !== order || $[8] !== registerElement || $[9] !== unregisterElement ? (t4 = () => (registerElement(id, {
    id,
    type: "panel",
    defaultSize,
    maxWidth: maxWidth != null ? maxWidth : null,
    minWidth: minWidth != null ? minWidth : 0,
    order
  }), () => {
    unregisterElement(id);
  }), t5 = [id, defaultSize, order, maxWidth, minWidth, registerElement, unregisterElement], $[3] = defaultSize, $[4] = id, $[5] = maxWidth, $[6] = minWidth, $[7] = order, $[8] = registerElement, $[9] = unregisterElement, $[10] = t4, $[11] = t5) : (t4 = $[10], t5 = $[11]), react.useLayoutEffect(t4, t5);
  let t6;
  return $[12] !== children || $[13] !== style ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(Root$1, { style, children }), $[12] = children, $[13] = style, $[14] = t6) : t6 = $[14], t6;
};
var __defProp$a = Object.defineProperty, __defProps$8 = Object.defineProperties, __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$a = Object.getOwnPropertySymbols, __hasOwnProp$a = Object.prototype.hasOwnProperty, __propIsEnum$a = Object.prototype.propertyIsEnumerable, __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$a.call(b, prop) && __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b))
      __propIsEnum$a.call(b, prop) && __defNormalProp$a(a, prop, b[prop]);
  return a;
}, __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
const itemKey = "presentation/panels", getStoredItem = () => JSON.parse(localStorage.getItem(itemKey) || "{}"), setStoredItem = (data) => {
  localStorage.setItem(itemKey, JSON.stringify(data));
}, getKeyForPanels = (panels) => panels.map((panel) => [panel.id, panel.order].join(":")).join(",");
function usePanelsStorage() {
  const $ = reactCompilerRuntime.c(1);
  let t0;
  const get = _temp2$4, set = _temp3$2;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const setDebounced = debounce(set, 100);
    t1 = {
      get,
      set,
      setDebounced
    }, $[0] = t1;
  } else
    t1 = $[0];
  return t0 = t1, t0;
}
function _temp3$2(panels_0, widths) {
  const stored_0 = getStoredItem(), key_0 = getKeyForPanels(panels_0), data = __spreadProps$8(__spreadValues$a({}, stored_0), {
    [key_0]: widths
  });
  setStoredItem(data);
}
function _temp2$4(panels) {
  const stored = getStoredItem(), key = getKeyForPanels(panels);
  return Array.isArray(stored[key]) && stored[key].some(_temp$7) ? void 0 : stored[key];
}
function _temp$7(val) {
  return val === null;
}
function getNextWidth(panel, nextWidth, containerWidth) {
  const {
    maxWidth: maxWidthPx,
    minWidth: minWidthPx
  } = panel, maxWidth = maxWidthPx == null ? 100 : maxWidthPx / containerWidth * 100, minWidth = minWidthPx / containerWidth * 100;
  return Math.min(maxWidth, Math.max(minWidth, nextWidth));
}
function getNextWidths(delta, containerWidth, panelBefore, panelAfter, panelsState, initialDragState) {
  const {
    panels,
    widths: prevWidths
  } = panelsState, {
    widths: initialWidths
  } = initialDragState, widths = initialWidths || prevWidths, nextWidths = [...widths];
  {
    const pivotPanel2 = delta < 0 ? panelAfter : panelBefore, index22 = panels.findIndex((panel) => panel.id === pivotPanel2.id), width = widths[index22], nextWidth = getNextWidth(pivotPanel2, width + Math.abs(delta), containerWidth);
    if (width === nextWidth)
      return widths;
    delta = delta < 0 ? width - nextWidth : nextWidth - width;
  }
  let deltaApplied = 0, pivotPanel = delta < 0 ? panelBefore : panelAfter, index2 = panels.findIndex((panel) => panel.id === pivotPanel.id);
  for (; ; ) {
    const panel = panels[index2], width = widths[index2], deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied), nextWidth = getNextWidth(panel, width - deltaRemaining, containerWidth);
    if (width !== nextWidth && (deltaApplied += width - nextWidth, nextWidths[index2] = nextWidth, deltaApplied.toPrecision(10).localeCompare(Math.abs(delta).toPrecision(10), void 0, {
      numeric: !0
    }) >= 0))
      break;
    if (delta < 0) {
      if (--index2 < 0)
        break;
    } else if (++index2 >= panels.length)
      break;
  }
  return deltaApplied === 0 ? widths : (pivotPanel = delta < 0 ? panelAfter : panelBefore, index2 = panels.findIndex((panel) => panel.id === pivotPanel.id), nextWidths[index2] = widths[index2] + deltaApplied, nextWidths);
}
function getPanelWidth(panels, id, widths) {
  if (panels.length === 1) return "100";
  const index2 = panels.findIndex((panel) => panel.id === id), width = widths[index2];
  return width == null ? "0" : width.toPrecision(10);
}
function getOffset(event, handleElement, initialOffset = 0, initialHandleElementRect = null) {
  const pointerOffset = event.clientX, elementOffset = (initialHandleElementRect || handleElement.getBoundingClientRect()).left;
  return pointerOffset - elementOffset - initialOffset;
}
function isPanel(element) {
  return element.type === "panel";
}
function isResizer(element) {
  return element.type === "resizer";
}
function getSortedElements(elements) {
  return Array.from(elements.values()).sort(({
    order: a
  }, {
    order: b
  }) => a == null && b == null ? 0 : a == null ? -1 : b == null ? 1 : a - b);
}
function validateWidths(panels, widthsToValidate, containerWidth) {
  const total = widthsToValidate.reduce((total2, width) => total2 + width, 0), widths = [...widthsToValidate].map((width) => width / total * 100);
  let remainingWidth = 0;
  for (let index2 = 0; index2 < panels.length; index2++) {
    const panel = panels[index2], width = widths[index2], nextWidth = getNextWidth(panel, width, containerWidth);
    width != nextWidth && (remainingWidth += width - nextWidth, widths[index2] = nextWidth);
  }
  if (remainingWidth.toFixed(3) !== "0.000")
    for (let index2 = 0; index2 < panels.length; index2++) {
      const panel = panels[index2];
      let {
        maxWidth,
        minWidth
      } = panel;
      minWidth = minWidth / containerWidth * 100, maxWidth != null && (maxWidth = maxWidth / containerWidth * 100);
      const width = Math.min(maxWidth != null ? maxWidth : 100, Math.max(minWidth, widths[index2] + remainingWidth));
      if (width !== widths[index2] && (remainingWidth -= width - widths[index2], widths[index2] = width, Math.abs(remainingWidth).toFixed(3) === "0.000"))
        break;
    }
  return widths;
}
function getDefaultWidths(panels) {
  let panelsWithoutWidth = panels.length, remainingWidthTotal = 100;
  const widthsWithNulls = panels.map((panel) => panel.defaultSize ? (remainingWidthTotal = remainingWidthTotal - panel.defaultSize, panelsWithoutWidth = panelsWithoutWidth - 1, panel.defaultSize) : null), defaultWidth = remainingWidthTotal / panelsWithoutWidth;
  return widthsWithNulls.map((width) => width === null ? defaultWidth : width);
}
const PanelsWrapper = styledComponents.styled.div`
  display: flex;
  flex-direction: row;
  height: 100%;
  overflow: hidden;
  width: 100%;
`, Panels = function(t0) {
  const $ = reactCompilerRuntime.c(46), {
    children
  } = t0, panelsEl = react.useRef(null);
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ new Map(), $[0] = t1) : t1 = $[0];
  const [elements, setElements] = react.useState(t1);
  let t2, t3;
  $[1] !== elements ? (t3 = getSortedElements(elements).filter(isPanel), $[1] = elements, $[2] = t3) : t3 = $[2], t2 = t3;
  const panels = t2;
  let t4;
  $[3] === Symbol.for("react.memo_cache_sentinel") ? (t4 = [], $[3] = t4) : t4 = $[3];
  const [widths, setWidths] = react.useState(t4), [activeResizer, setActiveResizer] = react.useState(null);
  let t5;
  $[4] !== elements || $[5] !== panels || $[6] !== widths ? (t5 = {
    elements,
    panels,
    widths
  }, $[4] = elements, $[5] = panels, $[6] = widths, $[7] = t5) : t5 = $[7];
  const panelsRef = react.useRef(t5);
  let t6;
  $[8] !== activeResizer || $[9] !== panels || $[10] !== widths ? (t6 = (id) => ({
    flexGrow: getPanelWidth(panels, id, widths),
    pointerEvents: activeResizer === null ? void 0 : "none"
  }), $[8] = activeResizer, $[9] = panels, $[10] = widths, $[11] = t6) : t6 = $[11];
  const getPanelStyle = t6;
  let t7;
  $[12] === Symbol.for("react.memo_cache_sentinel") ? (t7 = (id_0, data) => {
    setElements((prev) => {
      if (prev.has(id_0))
        return prev;
      const next = new Map(prev);
      return next.set(id_0, data), next;
    });
  }, $[12] = t7) : t7 = $[12];
  const registerElement = t7;
  let t8;
  $[13] === Symbol.for("react.memo_cache_sentinel") ? (t8 = (id_1) => {
    setElements((prev_0) => {
      if (!prev_0.has(id_1))
        return prev_0;
      const next_0 = new Map(prev_0);
      return next_0.delete(id_1), next_0;
    });
  }, $[13] = t8) : t8 = $[13];
  const unregisterElement = t8;
  let t9;
  $[14] === Symbol.for("react.memo_cache_sentinel") ? (t9 = {
    containerWidth: window.innerWidth,
    dragOffset: 0,
    panelAfter: null,
    panelBefore: null,
    resizerIndex: -1,
    resizerRect: null,
    startX: 0,
    widths: []
  }, $[14] = t9) : t9 = $[14];
  const dragRef = react.useRef(t9);
  let t10;
  $[15] !== elements ? (t10 = (id_2, event) => {
    const elementsArr = getSortedElements(elements), index2 = elementsArr.findIndex((el) => el.id === id_2), resizer = elements.get(id_2);
    if (!resizer || !isResizer(resizer))
      return;
    const resizeElement = resizer.el.current;
    resizeElement && (dragRef.current = {
      resizerIndex: index2,
      panelBefore: elementsArr.reduce((acc, el_0, i) => isPanel(el_0) && i < index2 ? el_0 : acc, null),
      panelAfter: elementsArr.reduce((acc_0, el_1, i_0) => acc_0 === null && isPanel(el_1) && i_0 > index2 ? el_1 : acc_0, null),
      containerWidth: window.innerWidth,
      startX: event.pageX,
      dragOffset: getOffset(event, resizeElement),
      resizerRect: resizeElement.getBoundingClientRect(),
      widths: panelsRef.current.widths
    }, setActiveResizer(id_2));
  }, $[15] = elements, $[16] = t10) : t10 = $[16];
  const startDragging = t10;
  let t11;
  $[17] === Symbol.for("react.memo_cache_sentinel") ? (t11 = () => {
    setActiveResizer(null);
  }, $[17] = t11) : t11 = $[17];
  const stopDragging = t11;
  let t12;
  $[18] !== elements ? (t12 = (id_3, event_0) => {
    event_0.preventDefault(), event_0.stopPropagation();
    const {
      containerWidth,
      dragOffset,
      panelBefore,
      panelAfter,
      resizerRect
    } = dragRef.current;
    if (panelBefore == null || panelAfter == null)
      return;
    const resizer_0 = elements.get(id_3);
    if (!resizer_0 || !isResizer(resizer_0))
      return;
    const resizeElement_0 = resizer_0.el.current;
    if (!resizeElement_0)
      return;
    const offset = getOffset(event_0, resizeElement_0, dragOffset, resizerRect);
    if (offset === 0)
      return;
    const {
      widths: prevWidths
    } = panelsRef.current, rect = panelsEl.current.getBoundingClientRect(), delta = offset / rect.width * 100, nextWidths = getNextWidths(delta, containerWidth, panelBefore, panelAfter, panelsRef.current, dragRef.current);
    prevWidths.some((prevWidth, i_1) => prevWidth !== nextWidths[i_1]) && setWidths(nextWidths);
  }, $[18] = elements, $[19] = t12) : t12 = $[19];
  const drag = t12;
  let t13, t14;
  $[20] !== elements || $[21] !== panels || $[22] !== widths ? (t13 = () => {
    panelsRef.current.elements = elements, panelsRef.current.panels = panels, panelsRef.current.widths = widths;
  }, t14 = [elements, panels, widths], $[20] = elements, $[21] = panels, $[22] = widths, $[23] = t13, $[24] = t14) : (t13 = $[23], t14 = $[24]), react.useLayoutEffect(t13, t14);
  const storage = usePanelsStorage();
  let t15, t16;
  $[25] !== panels || $[26] !== storage ? (t15 = () => {
    const {
      widths: widths_0
    } = panelsRef.current;
    if (widths_0.length === panels.length)
      return;
    const storedWidths = storage.get(panels);
    if (storedWidths) {
      const validatedStoredWidths = validateWidths(panels, storedWidths, window.innerWidth);
      setWidths(validatedStoredWidths);
      return;
    }
    const defaultWidths = getDefaultWidths(panels);
    setWidths(defaultWidths);
  }, t16 = [storage, panels], $[25] = panels, $[26] = storage, $[27] = t15, $[28] = t16) : (t15 = $[27], t16 = $[28]), react.useLayoutEffect(t15, t16);
  let t17, t18;
  $[29] !== panels || $[30] !== storage || $[31] !== widths ? (t17 = () => {
    widths.length && storage.setDebounced(panels, widths);
  }, t18 = [storage, panels, widths], $[29] = panels, $[30] = storage, $[31] = widths, $[32] = t17, $[33] = t18) : (t17 = $[32], t18 = $[33]), react.useEffect(t17, t18);
  let t19, t20;
  $[34] === Symbol.for("react.memo_cache_sentinel") ? (t19 = () => {
    const resizeObserver = new ResizeObserver(() => {
      const {
        panels: panels_0,
        widths: prevWidths_0
      } = panelsRef.current, nextWidths_0 = validateWidths(panels_0, prevWidths_0, window.innerWidth);
      prevWidths_0.some((prevWidth_0, i_2) => prevWidth_0 !== nextWidths_0[i_2]) && setWidths(nextWidths_0);
    });
    return resizeObserver.observe(panelsEl.current), () => {
      resizeObserver.disconnect();
    };
  }, t20 = [], $[34] = t19, $[35] = t20) : (t19 = $[34], t20 = $[35]), react.useLayoutEffect(t19, t20);
  let t21, t22;
  $[36] !== activeResizer || $[37] !== drag || $[38] !== getPanelStyle || $[39] !== startDragging ? (t22 = {
    activeResizer,
    drag,
    getPanelStyle,
    registerElement,
    startDragging,
    stopDragging,
    unregisterElement
  }, $[36] = activeResizer, $[37] = drag, $[38] = getPanelStyle, $[39] = startDragging, $[40] = t22) : t22 = $[40], t21 = t22;
  const context = t21;
  let t23;
  $[41] !== children ? (t23 = /* @__PURE__ */ jsxRuntime.jsx(PanelsWrapper, { ref: panelsEl, children }), $[41] = children, $[42] = t23) : t23 = $[42];
  let t24;
  return $[43] !== context || $[44] !== t23 ? (t24 = /* @__PURE__ */ jsxRuntime.jsx(PanelsContext.Provider, { value: context, children: t23 }), $[43] = context, $[44] = t23, $[45] = t24) : t24 = $[45], t24;
};
var __defProp$9 = Object.defineProperty, __defProps$7 = Object.defineProperties, __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$9 = Object.getOwnPropertySymbols, __hasOwnProp$9 = Object.prototype.hasOwnProperty, __propIsEnum$9 = Object.prototype.propertyIsEnumerable, __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$9.call(b, prop) && __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b))
      __propIsEnum$9.call(b, prop) && __defNormalProp$9(a, prop, b[prop]);
  return a;
}, __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b)), __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
function ErrorCard(props) {
  var _a;
  const $ = reactCompilerRuntime.c(37);
  let children, message, onContinueAnyway, onRetry, restProps;
  $[0] !== props ? (_a = props, {
    children,
    message,
    onRetry,
    onContinueAnyway
  } = _a, restProps = __objRest$2(_a, [
    "children",
    "message",
    "onRetry",
    "onContinueAnyway"
  ]), $[0] = props, $[1] = children, $[2] = message, $[3] = onContinueAnyway, $[4] = onRetry, $[5] = restProps) : (children = $[1], message = $[2], onContinueAnyway = $[3], onRetry = $[4], restProps = $[5]);
  const {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace);
  let t0;
  $[6] !== t ? (t0 = t("error-card.retry-button.text"), $[6] = t, $[7] = t0) : t0 = $[7];
  let t1;
  $[8] !== onRetry || $[9] !== t0 ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, mode: "ghost", onClick: onRetry, text: t0 }), $[8] = onRetry, $[9] = t0, $[10] = t1) : t1 = $[10];
  const retryButton = t1;
  let t2;
  $[11] !== t ? (t2 = t("error-card.continue-button.text"), $[11] = t, $[12] = t2) : t2 = $[12];
  let t3;
  $[13] !== onContinueAnyway || $[14] !== t2 ? (t3 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, mode: "ghost", tone: "critical", onClick: onContinueAnyway, text: t2 }), $[13] = onContinueAnyway, $[14] = t2, $[15] = t3) : t3 = $[15];
  const continueAnywayButton = t3;
  let t4;
  $[16] !== t ? (t4 = t("error-card.title"), $[16] = t, $[17] = t4) : t4 = $[17];
  let t5;
  $[18] !== t4 ? (t5 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: t4 }), $[18] = t4, $[19] = t5) : t5 = $[19];
  let t6;
  $[20] !== message ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: message }), $[20] = message, $[21] = t6) : t6 = $[21];
  let t7;
  $[22] !== t5 || $[23] !== t6 ? (t7 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    t5,
    t6
  ] }), $[22] = t5, $[23] = t6, $[24] = t7) : t7 = $[24];
  let t8;
  $[25] !== continueAnywayButton || $[26] !== onContinueAnyway || $[27] !== onRetry || $[28] !== retryButton ? (t8 = onRetry && onContinueAnyway ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
    retryButton,
    continueAnywayButton
  ] }) : onRetry ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: retryButton }) : onContinueAnyway ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: continueAnywayButton }) : null, $[25] = continueAnywayButton, $[26] = onContinueAnyway, $[27] = onRetry, $[28] = retryButton, $[29] = t8) : t8 = $[29];
  let t9;
  $[30] !== children || $[31] !== t7 || $[32] !== t8 ? (t9 = /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { padding: 4, sizing: "border", width: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    t7,
    children,
    t8
  ] }) }) }), $[30] = children, $[31] = t7, $[32] = t8, $[33] = t9) : t9 = $[33];
  let t10;
  return $[34] !== restProps || $[35] !== t9 ? (t10 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, __spreadProps$7(__spreadValues$9({ height: "fill" }, restProps), { children: t9 })), $[34] = restProps, $[35] = t9, $[36] = t10) : t10 = $[36], t10;
}
var __defProp$8 = Object.defineProperty, __defProps$6 = Object.defineProperties, __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$8 = Object.getOwnPropertySymbols, __hasOwnProp$8 = Object.prototype.hasOwnProperty, __propIsEnum$8 = Object.prototype.propertyIsEnumerable, __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$8.call(b, prop) && __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b))
      __propIsEnum$8.call(b, prop) && __defNormalProp$8(a, prop, b[prop]);
  return a;
}, __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b)), __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
function encodeQueryString(params = {}) {
  const parts = Object.entries(params).map(([key, value]) => `${key}=${value}`).join("&");
  return parts.length ? `?${parts}` : "";
}
function resolveQueryStringFromParams(nextParams) {
  const allowed = ["comment", "inspect", "instruction", "pathKey", "rev", "since", "template", "view"], safeNextParams = Object.entries(nextParams).filter(([key]) => allowed.includes(key)).reduce((obj, [key, value]) => value == null ? obj : __spreadProps$6(__spreadValues$8({}, obj), {
    [key]: value
  }), {});
  return encodeQueryString(safeNextParams);
}
const BackLink = react.forwardRef(function(props, ref) {
  var _a;
  const $ = reactCompilerRuntime.c(11);
  let restProps, searchParams;
  $[0] !== props ? (_a = props, {
    searchParams
  } = _a, restProps = __objRest$1(_a, [
    "searchParams"
  ]), $[0] = props, $[1] = restProps, $[2] = searchParams) : (restProps = $[1], searchParams = $[2]);
  let t0;
  $[3] !== searchParams ? (t0 = Object.entries(searchParams), $[3] = searchParams, $[4] = t0) : t0 = $[4];
  let t1;
  $[5] !== t0 ? (t1 = {
    type: void 0,
    _searchParams: t0
  }, $[5] = t0, $[6] = t1) : t1 = $[6];
  let t2;
  return $[7] !== ref || $[8] !== restProps || $[9] !== t1 ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(router.StateLink, __spreadProps$6(__spreadValues$8({}, restProps), { ref, state: t1, title: void 0 })), $[7] = ref, $[8] = restProps, $[9] = t1, $[10] = t2) : t2 = $[10], t2;
}), ReferenceChildLink = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(15);
  let documentId, documentType, restProps, searchParams;
  if ($[0] !== props) {
    const _a = props, {
      documentId: t02,
      documentType: t12,
      parentRefPath,
      template,
      searchParams: t22
    } = _a, t3 = __objRest$1(_a, [
      "documentId",
      "documentType",
      "parentRefPath",
      "template",
      "searchParams"
    ]);
    documentId = t02, documentType = t12, searchParams = t22, restProps = t3, $[0] = props, $[1] = documentId, $[2] = documentType, $[3] = restProps, $[4] = searchParams;
  } else
    documentId = $[1], documentType = $[2], restProps = $[3], searchParams = $[4];
  let t0;
  $[5] !== searchParams ? (t0 = Object.entries(searchParams), $[5] = searchParams, $[6] = t0) : t0 = $[6];
  let t1;
  $[7] !== documentId || $[8] !== documentType || $[9] !== t0 ? (t1 = {
    id: documentId,
    type: documentType,
    _searchParams: t0
  }, $[7] = documentId, $[8] = documentType, $[9] = t0, $[10] = t1) : t1 = $[10];
  let t2;
  return $[11] !== ref || $[12] !== restProps || $[13] !== t1 ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(router.StateLink, __spreadProps$6(__spreadValues$8({}, restProps), { ref, state: t1, title: void 0 })), $[11] = ref, $[12] = restProps, $[13] = t1, $[14] = t2) : t2 = $[14], t2;
});
function PresentationPaneRouterProvider(props) {
  const $ = reactCompilerRuntime.c(26), {
    children,
    onStructureParams,
    structureParams,
    searchParams,
    refs
  } = props, {
    state: routerState,
    resolvePathFromState
  } = router.useRouter();
  let t0;
  $[0] !== routerState._searchParams ? (t0 = Object.fromEntries(routerState._searchParams || []), $[0] = routerState._searchParams, $[1] = t0) : t0 = $[1];
  const routerSearchParams = sanity.useUnique(t0);
  let t1;
  $[2] !== resolvePathFromState || $[3] !== routerSearchParams || $[4] !== routerState ? (t1 = (nextParams) => {
    const path = resolvePathFromState(routerState), qs = resolveQueryStringFromParams(__spreadValues$8(__spreadValues$8({}, routerSearchParams), nextParams));
    return `${path}${qs}`;
  }, $[2] = resolvePathFromState, $[3] = routerSearchParams, $[4] = routerState, $[5] = t1) : t1 = $[5];
  const createPathWithParams = t1;
  let t2, t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {}, $[6] = t3) : t3 = $[6];
  const t4 = structureParams;
  let t5;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t5 = [], $[7] = t5) : t5 = $[7];
  let t6;
  $[8] !== refs || $[9] !== searchParams ? (t6 = (childLinkProps) => {
    const _a = childLinkProps, {
      childId
    } = _a, restProps = __objRest$1(_a, [
      "childId"
    ]), ref = refs == null ? void 0 : refs.find((r) => r._id === childId || sanity.getPublishedId(r._id) === childId);
    return ref ? /* @__PURE__ */ jsxRuntime.jsx(router.StateLink, __spreadProps$6(__spreadValues$8({}, restProps), { state: {
      id: childId,
      type: ref._type,
      _searchParams: Object.entries(searchParams)
    } })) : /* @__PURE__ */ jsxRuntime.jsx("div", __spreadValues$8({}, restProps));
  }, $[8] = refs, $[9] = searchParams, $[10] = t6) : t6 = $[10];
  let t7, t8;
  $[11] !== searchParams ? (t7 = (backLinkProps) => /* @__PURE__ */ jsxRuntime.jsx(BackLink, __spreadProps$6(__spreadValues$8({}, backLinkProps), { searchParams })), t8 = (childLinkProps_0) => /* @__PURE__ */ jsxRuntime.jsx(ReferenceChildLink, __spreadProps$6(__spreadValues$8({}, childLinkProps_0), { searchParams })), $[11] = searchParams, $[12] = t7, $[13] = t8) : (t7 = $[12], t8 = $[13]);
  let t9;
  $[14] !== onStructureParams ? (t9 = (nextParams_0) => {
    var _a;
    onStructureParams(__spreadProps$6(__spreadValues$8({}, nextParams_0), {
      inspect: (_a = nextParams_0.inspect) != null ? _a : void 0
    }));
  }, $[14] = onStructureParams, $[15] = t9) : t9 = $[15];
  let t10;
  $[16] !== createPathWithParams || $[17] !== t4 || $[18] !== t6 || $[19] !== t7 || $[20] !== t8 || $[21] !== t9 ? (t10 = {
    index: 0,
    groupIndex: 0,
    siblingIndex: 0,
    payload: t3,
    params: t4,
    hasGroupSiblings: !1,
    groupLength: 1,
    routerPanesState: t5,
    ChildLink: t6,
    BackLink: t7,
    ReferenceChildLink: t8,
    ParameterizedLink: _temp$6,
    closeCurrentAndAfter: _temp2$3,
    handleEditReference: _temp3$1,
    replaceCurrent: _temp4,
    closeCurrent: _temp5,
    duplicateCurrent: _temp6,
    setView: _temp7,
    setParams: t9,
    setPayload: _temp8,
    navigateIntent: _temp9,
    createPathWithParams
  }, $[16] = createPathWithParams, $[17] = t4, $[18] = t6, $[19] = t7, $[20] = t8, $[21] = t9, $[22] = t10) : t10 = $[22], t2 = t10;
  const context = t2;
  let t11;
  return $[23] !== children || $[24] !== context ? (t11 = /* @__PURE__ */ jsxRuntime.jsx(structure.PaneRouterContext.Provider, { value: context, children }), $[23] = children, $[24] = context, $[25] = t11) : t11 = $[25], t11;
}
function _temp9(intentName, intentParams, options_0) {
  console.warn("navigateIntent", intentName, intentParams, options_0);
}
function _temp8(payload) {
  console.warn("setPayload", payload);
}
function _temp7(viewId) {
  console.warn("setView", viewId);
}
function _temp6(pane_0) {
  console.warn("duplicateCurrent", pane_0);
}
function _temp5() {
  console.warn("closeCurrent");
}
function _temp4(pane) {
  console.warn("replaceCurrent", pane);
}
function _temp3$1(options) {
  console.warn("handleEditReference", options);
}
function _temp2$3() {
  console.warn("closeCurrentAndAfter");
}
function _temp$6() {
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: "ParameterizedLink" });
}
const RootLayout = styledComponents.styled(structure.PaneLayout)`
  height: 100%;
`, Root = styledComponents.styled(ui.Flex)`
  & > div {
    min-width: none !important;
    max-width: none !important;
  }
`, WrappedCode$1 = styledComponents.styled(ui.Code)`
  white-space: pre-wrap;
`;
function DocumentListPane(props) {
  var _a, _b, _c2, _d;
  const $ = reactCompilerRuntime.c(33), {
    mainDocumentState,
    onStructureParams,
    searchParams,
    refs
  } = props, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace), {
    devMode
  } = index.usePresentationTool();
  let t0, t1;
  if ($[0] !== ((_a = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _a._id) || $[1] !== refs) {
    let t22;
    $[3] !== ((_b = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _b._id) ? (t22 = (r) => {
      var _a2;
      return sanity.getPublishedId(r._id) !== ((_a2 = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _a2._id);
    }, $[3] = (_c2 = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _c2._id, $[4] = t22) : t22 = $[4], t1 = refs.filter(t22).map(_temp$5), $[0] = (_d = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _d._id, $[1] = refs, $[2] = t1;
  } else
    t1 = $[2];
  t0 = t1;
  const ids = t0;
  let t2, t3;
  $[5] !== ids ? (t3 = {
    filter: "_id in $ids",
    params: {
      ids
    }
  }, $[5] = ids, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== t ? (t4 = t("document-list-pane.document-list.title"), $[7] = t, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== t3 || $[10] !== t4 ? (t5 = {
    id: "$root",
    options: t3,
    schemaTypeName: "",
    title: t4,
    type: "documentList"
  }, $[9] = t3, $[10] = t4, $[11] = t5) : t5 = $[11], t2 = t5;
  const pane = t2, [errorParams, setErrorParams] = react.useState(null);
  let t6;
  $[12] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => setErrorParams(null), $[12] = t6) : t6 = $[12];
  const handleRetry = t6, [structureParams] = react.useState(_temp2$2);
  let t7;
  $[13] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => setErrorParams(null), $[13] = t7) : t7 = $[13];
  let t8;
  if ($[14] !== refs ? (t8 = [refs], $[14] = refs, $[15] = t8) : t8 = $[15], react.useEffect(t7, t8), errorParams) {
    let t92;
    $[16] !== t ? (t92 = t("document-list-pane.error.text"), $[16] = t, $[17] = t92) : t92 = $[17];
    let t102;
    $[18] !== devMode || $[19] !== errorParams || $[20] !== t ? (t102 = devMode && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { overflow: "auto", padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { muted: !0, size: 0, children: t("presentation-error.label") }),
      /* @__PURE__ */ jsxRuntime.jsx(WrappedCode$1, { size: 1, children: errorParams.error.message })
    ] }) }), $[18] = devMode, $[19] = errorParams, $[20] = t, $[21] = t102) : t102 = $[21];
    let t11;
    return $[22] !== t102 || $[23] !== t92 ? (t11 = /* @__PURE__ */ jsxRuntime.jsx(ErrorCard, { flex: 1, message: t92, onRetry: handleRetry, children: t102 }), $[22] = t102, $[23] = t92, $[24] = t11) : t11 = $[24], t11;
  }
  let t9;
  $[25] !== pane ? (t9 = /* @__PURE__ */ jsxRuntime.jsx(Root, { direction: "column", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(structure.DocumentListPane, { index: 0, itemId: "$root", pane, paneKey: "$root" }) }), $[25] = pane, $[26] = t9) : t9 = $[26];
  let t10;
  return $[27] !== onStructureParams || $[28] !== refs || $[29] !== searchParams || $[30] !== structureParams || $[31] !== t9 ? (t10 = /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: setErrorParams, children: /* @__PURE__ */ jsxRuntime.jsx(RootLayout, { children: /* @__PURE__ */ jsxRuntime.jsx(structure.StructureToolProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(PresentationPaneRouterProvider, { onStructureParams, structureParams, searchParams, refs, children: t9 }) }) }) }), $[27] = onStructureParams, $[28] = refs, $[29] = searchParams, $[30] = structureParams, $[31] = t9, $[32] = t10) : t10 = $[32], t10;
}
function _temp2$2() {
  return {};
}
function _temp$5(r_0) {
  return r_0._id;
}
const WrappedCode = styledComponents.styled(ui.Code)`
  white-space: pre-wrap;
`;
function DocumentPane(props) {
  const $ = reactCompilerRuntime.c(35), {
    documentId,
    documentType,
    onFocusPath,
    onStructureParams,
    searchParams,
    structureParams
  } = props, {
    template,
    templateParams
  } = structureParams, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace), {
    devMode
  } = index.usePresentationTool();
  let t0, t1;
  $[0] !== templateParams ? (t1 = router.decodeJsonParams(templateParams), $[0] = templateParams, $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== documentId || $[3] !== documentType || $[4] !== t1 || $[5] !== template ? (t2 = {
    id: documentId,
    type: documentType,
    template,
    templateParameters: t1
  }, $[2] = documentId, $[3] = documentType, $[4] = t1, $[5] = template, $[6] = t2) : t2 = $[6];
  let t3;
  $[7] !== documentId || $[8] !== t2 ? (t3 = {
    id: documentId,
    options: t2,
    title: "",
    type: "document"
  }, $[7] = documentId, $[8] = t2, $[9] = t3) : t3 = $[9], t0 = t3;
  const paneDocumentNode = t0, [errorParams, setErrorParams] = react.useState(null);
  let t4;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => setErrorParams(null), $[10] = t4) : t4 = $[10];
  const handleRetry = t4;
  let t5;
  $[11] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    setErrorParams(null);
  }, $[11] = t5) : t5 = $[11];
  let t6;
  if ($[12] !== documentId || $[13] !== documentType || $[14] !== structureParams ? (t6 = [documentId, documentType, structureParams], $[12] = documentId, $[13] = documentType, $[14] = structureParams, $[15] = t6) : t6 = $[15], react.useEffect(t5, t6), errorParams) {
    let t72;
    $[16] !== t ? (t72 = t("document-pane.error.text"), $[16] = t, $[17] = t72) : t72 = $[17];
    let t82;
    $[18] !== devMode || $[19] !== errorParams || $[20] !== t ? (t82 = devMode && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { overflow: "auto", padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { muted: !0, size: 0, children: t("presentation-error.label") }),
      /* @__PURE__ */ jsxRuntime.jsx(WrappedCode, { size: 1, children: errorParams.error.message })
    ] }) }), $[18] = devMode, $[19] = errorParams, $[20] = t, $[21] = t82) : t82 = $[21];
    let t92;
    return $[22] !== t72 || $[23] !== t82 ? (t92 = /* @__PURE__ */ jsxRuntime.jsx(ErrorCard, { flex: 1, message: t72, onRetry: handleRetry, children: t82 }), $[22] = t72, $[23] = t82, $[24] = t92) : t92 = $[24], t92;
  }
  let t7;
  $[25] === Symbol.for("react.memo_cache_sentinel") ? (t7 = {
    height: "100%"
  }, $[25] = t7) : t7 = $[25];
  let t8;
  $[26] === Symbol.for("react.memo_cache_sentinel") ? (t8 = /* @__PURE__ */ jsxRuntime.jsx(index.PresentationSpinner, {}), $[26] = t8) : t8 = $[26];
  let t9;
  $[27] !== onFocusPath || $[28] !== paneDocumentNode ? (t9 = /* @__PURE__ */ jsxRuntime.jsx(react.Suspense, { fallback: t8, children: /* @__PURE__ */ jsxRuntime.jsx(structure.DocumentPane, { paneKey: "document", index: 1, itemId: "document", pane: paneDocumentNode, onFocusPath }) }), $[27] = onFocusPath, $[28] = paneDocumentNode, $[29] = t9) : t9 = $[29];
  let t10;
  return $[30] !== onStructureParams || $[31] !== searchParams || $[32] !== structureParams || $[33] !== t9 ? (t10 = /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: setErrorParams, children: /* @__PURE__ */ jsxRuntime.jsx(structure.PaneLayout, { style: t7, children: /* @__PURE__ */ jsxRuntime.jsx(PresentationPaneRouterProvider, { searchParams, onStructureParams, structureParams, children: t9 }) }) }), $[30] = onStructureParams, $[31] = searchParams, $[32] = structureParams, $[33] = t9, $[34] = t10) : t10 = $[34], t10;
}
function DocumentPanel(props) {
  const $ = reactCompilerRuntime.c(7), {
    documentId,
    documentType,
    onFocusPath,
    onStructureParams,
    searchParams,
    structureParams
  } = props;
  let t0;
  return $[0] !== documentId || $[1] !== documentType || $[2] !== onFocusPath || $[3] !== onStructureParams || $[4] !== searchParams || $[5] !== structureParams ? (t0 = /* @__PURE__ */ jsxRuntime.jsx(structure.StructureToolProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(DocumentPane, { documentId, documentType, onFocusPath, onStructureParams, searchParams, structureParams }) }), $[0] = documentId, $[1] = documentType, $[2] = onFocusPath, $[3] = onStructureParams, $[4] = searchParams, $[5] = structureParams, $[6] = t0) : t0 = $[6], t0;
}
function usePreviewState(documentId, schemaType) {
  const $ = reactCompilerRuntime.c(6), documentPreviewStore = sanity.useDocumentPreviewStore();
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {}, $[0] = t0) : t0 = $[0];
  const [preview, setPreview] = react.useState(t0);
  let t1, t2;
  return $[1] !== documentId || $[2] !== documentPreviewStore || $[3] !== schemaType ? (t1 = () => {
    if (!schemaType)
      return;
    const subscription = sanity.getPreviewStateObservable(documentPreviewStore, schemaType, documentId, "").subscribe((state) => {
      setPreview(state);
    });
    return () => {
      subscription == null || subscription.unsubscribe();
    };
  }, t2 = [documentPreviewStore, schemaType, documentId], $[1] = documentId, $[2] = documentPreviewStore, $[3] = schemaType, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), react.useEffect(t1, t2), preview;
}
var __defProp$7 = Object.defineProperty, __defProps$5 = Object.defineProperties, __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$7 = Object.getOwnPropertySymbols, __hasOwnProp$7 = Object.prototype.hasOwnProperty, __propIsEnum$7 = Object.prototype.propertyIsEnumerable, __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$7.call(b, prop) && __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b))
      __propIsEnum$7.call(b, prop) && __defNormalProp$7(a, prop, b[prop]);
  return a;
}, __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
function ContentEditor(props) {
  var _a, _b, _c2, _d, _e, _f, _g, _h;
  const $ = reactCompilerRuntime.c(39), {
    documentId,
    documentType,
    mainDocumentState,
    onFocusPath,
    onStructureParams,
    refs,
    searchParams,
    structureParams
  } = props, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace), schema = sanity.useSchema();
  let t0;
  $[0] !== ((_a = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _a._id) || $[1] !== ((_b = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _b._type) || $[2] !== searchParams ? (t0 = (props_0) => {
    var _a2, _b2;
    return /* @__PURE__ */ jsxRuntime.jsx(router.StateLink, __spreadProps$5(__spreadValues$7({}, props_0), { state: {
      id: (_a2 = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _a2._id,
      type: (_b2 = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _b2._type,
      _searchParams: Object.entries(searchParams)
    } }));
  }, $[0] = (_c2 = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _c2._id, $[1] = (_d = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _d._type, $[2] = searchParams, $[3] = t0) : t0 = $[3];
  const MainDocumentLink = t0;
  let t1, t2;
  $[4] !== ((_e = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _e._type) || $[5] !== schema ? (t2 = schema.get(((_f = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _f._type) || "shoe"), $[4] = (_g = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _g._type, $[5] = schema, $[6] = t2) : t2 = $[6], t1 = t2;
  const schemaType = t1, previewState = usePreviewState(((_h = mainDocumentState == null ? void 0 : mainDocumentState.document) == null ? void 0 : _h._id) || "", schemaType);
  let t3;
  bb0: {
    if (!(mainDocumentState != null && mainDocumentState.document)) {
      t3 = null;
      break bb0;
    }
    const t42 = mainDocumentState.document;
    let t52;
    $[7] !== previewState.draft || $[8] !== previewState.published || $[9] !== t42 ? (t52 = sanity.getPreviewValueWithFallback({
      value: t42,
      published: previewState.published,
      draft: previewState.draft
    }), $[7] = previewState.draft, $[8] = previewState.published, $[9] = t42, $[10] = t52) : t52 = $[10];
    let t62;
    $[11] !== t ? (t62 = t("main-document.label"), $[11] = t, $[12] = t62) : t62 = $[12];
    let t7;
    $[13] !== t62 ? (t7 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, radius: 2, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 0, weight: "medium", children: t62 }) }), $[13] = t62, $[14] = t7) : t7 = $[14];
    let t8;
    $[15] !== schemaType || $[16] !== t52 || $[17] !== t7 ? (t8 = /* @__PURE__ */ jsxRuntime.jsx(sanity.SanityDefaultPreview, __spreadProps$5(__spreadValues$7({}, t52), { schemaType, status: t7 })), $[15] = schemaType, $[16] = t52, $[17] = t7, $[18] = t8) : t8 = $[18], t3 = t8;
  }
  const preview = t3;
  if (documentId && documentType) {
    let t42;
    return $[19] !== documentId || $[20] !== documentType || $[21] !== onFocusPath || $[22] !== onStructureParams || $[23] !== searchParams || $[24] !== structureParams ? (t42 = /* @__PURE__ */ jsxRuntime.jsx(DocumentPanel, { documentId, documentType, onFocusPath, onStructureParams, searchParams, structureParams }), $[19] = documentId, $[20] = documentType, $[21] = onFocusPath, $[22] = onStructureParams, $[23] = searchParams, $[24] = structureParams, $[25] = t42) : t42 = $[25], t42;
  }
  let t4;
  $[26] !== MainDocumentLink || $[27] !== mainDocumentState || $[28] !== preview || $[29] !== t ? (t4 = mainDocumentState && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, tone: mainDocumentState.document ? "inherit" : "caution", children: mainDocumentState.document ? /* @__PURE__ */ jsxRuntime.jsx(sanity.PreviewCard, { __unstable_focusRing: !0, as: MainDocumentLink, "data-as": "a", radius: 2, sizing: "border", tone: "inherit", children: preview }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.Translate, { t, i18nKey: "main-document.missing.text", components: {
      Code: "code"
    }, values: {
      path: mainDocumentState.path
    } }) }) })
  ] }) }) }), $[26] = MainDocumentLink, $[27] = mainDocumentState, $[28] = preview, $[29] = t, $[30] = t4) : t4 = $[30];
  let t5;
  $[31] !== mainDocumentState || $[32] !== onStructureParams || $[33] !== refs || $[34] !== searchParams ? (t5 = /* @__PURE__ */ jsxRuntime.jsx(DocumentListPane, { mainDocumentState, onStructureParams, searchParams, refs }), $[31] = mainDocumentState, $[32] = onStructureParams, $[33] = refs, $[34] = searchParams, $[35] = t5) : t5 = $[35];
  let t6;
  return $[36] !== t4 || $[37] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", flex: 1, height: "fill", children: [
    t4,
    t5
  ] }), $[36] = t4, $[37] = t5, $[38] = t6) : t6 = $[38], t6;
}
var byteToHex = [];
for (var i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options)
    return native.randomUUID();
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  return rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, unsafeStringify(rnds);
}
function usePanelId(id) {
  const $ = reactCompilerRuntime.c(2);
  let t0;
  $[0] !== id ? (t0 = () => id || v4(), $[0] = id, $[1] = t0) : t0 = $[1];
  const [panelId] = react.useState(t0);
  return panelId;
}
const Resizer = styledComponents.styled.div`
  position: relative;
`, ResizerInner = styledComponents.styled.div`
  position: absolute;
  top: 0;
  bottom: 0;
  left: -5px;
  width: 9px;
  z-index: 10;
  cursor: ${({
  $disabled
}) => $disabled ? "auto" : "ew-resize"};

  /* Border */
  & > span:nth-child(1) {
    display: block;
    border-left: 1px solid var(--card-border-color);
    position: absolute;
    top: 0;
    left: 4px;
    bottom: 0;
    transition: opacity 200ms;
  }

  ${({
  $disabled
}) => !$disabled && `
    /* Hover effect */
    & > span:nth-child(2) {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 9px;
      bottom: 0;
      background-color: var(--card-border-color);
      opacity: 0;
      transition: opacity 150ms;
    }

    @media (hover: hover) {
      &:hover > span:nth-child(2) {
        opacity: 0.2;
      }
    }
  `}
`, PanelResizer = function(t0) {
  const $ = reactCompilerRuntime.c(27), {
    id: propId,
    order,
    disabled: t1
  } = t0, disabled = t1 === void 0 ? !1 : t1, el = react.useRef(null), context = react.useContext(PanelsContext);
  if (context === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const id = usePanelId(propId), {
    activeResizer,
    drag,
    startDragging,
    stopDragging,
    registerElement,
    unregisterElement
  } = context, isDragging = activeResizer === id;
  if (context === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  let t2;
  $[0] !== id || $[1] !== startDragging ? (t2 = (event) => {
    startDragging(id, event.nativeEvent);
  }, $[0] = id, $[1] = startDragging, $[2] = t2) : t2 = $[2];
  const onMouseDown = t2;
  let t3;
  $[3] !== drag || $[4] !== id ? (t3 = (e) => {
    drag(id, e);
  }, $[3] = drag, $[4] = id, $[5] = t3) : t3 = $[5];
  const onDrag = t3;
  let t4;
  $[6] !== stopDragging ? (t4 = () => {
    el.current.blur(), stopDragging();
  }, $[6] = stopDragging, $[7] = t4) : t4 = $[7];
  const onDragStop = t4;
  let t5, t6;
  $[8] !== disabled || $[9] !== isDragging || $[10] !== onDrag || $[11] !== onDragStop ? (t5 = () => {
    if (!isDragging || disabled)
      return;
    const resetDocumentStyles = function() {
      const bodyStyle = document.body.style, documentStyle = document.documentElement.style, {
        cursor
      } = documentStyle, {
        userSelect
      } = bodyStyle;
      return documentStyle.cursor = "ew-resize", bodyStyle.userSelect = "none", () => {
        cursor ? documentStyle.cursor = cursor : documentStyle.removeProperty("cursor"), userSelect ? bodyStyle.userSelect = userSelect : bodyStyle.removeProperty("user-select");
      };
    }();
    return window.addEventListener("mousemove", onDrag), window.addEventListener("mouseup", onDragStop), window.addEventListener("contextmenu", onDragStop), () => {
      resetDocumentStyles(), window.removeEventListener("mousemove", onDrag), window.removeEventListener("mouseup", onDragStop), window.removeEventListener("contextmenu", onDragStop);
    };
  }, t6 = [disabled, isDragging, onDrag, onDragStop], $[8] = disabled, $[9] = isDragging, $[10] = onDrag, $[11] = onDragStop, $[12] = t5, $[13] = t6) : (t5 = $[12], t6 = $[13]), react.useEffect(t5, t6);
  let t7, t8;
  $[14] !== id || $[15] !== order || $[16] !== registerElement || $[17] !== unregisterElement ? (t7 = () => (registerElement(id, {
    id,
    order,
    type: "resizer",
    el
  }), () => {
    unregisterElement(id);
  }), t8 = [id, order, registerElement, unregisterElement], $[14] = id, $[15] = order, $[16] = registerElement, $[17] = unregisterElement, $[18] = t7, $[19] = t8) : (t7 = $[18], t8 = $[19]), react.useLayoutEffect(t7, t8);
  let t10, t9;
  $[20] === Symbol.for("react.memo_cache_sentinel") ? (t9 = /* @__PURE__ */ jsxRuntime.jsx("span", {}), t10 = /* @__PURE__ */ jsxRuntime.jsx("span", {}), $[20] = t10, $[21] = t9) : (t10 = $[20], t9 = $[21]);
  let t11;
  $[22] !== disabled ? (t11 = /* @__PURE__ */ jsxRuntime.jsxs(ResizerInner, { $disabled: disabled, children: [
    t9,
    t10
  ] }), $[22] = disabled, $[23] = t11) : t11 = $[23];
  let t12;
  return $[24] !== onMouseDown || $[25] !== t11 ? (t12 = /* @__PURE__ */ jsxRuntime.jsx(Resizer, { onMouseDown, ref: el, children: t11 }), $[24] = onMouseDown, $[25] = t11, $[26] = t12) : t12 = $[26], t12;
}, PresentationContentWrapper = (props) => {
  const $ = reactCompilerRuntime.c(8), {
    documentId,
    setDisplayedDocument,
    getCommentIntent
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsxRuntime.jsx(PanelResizer, { order: 4 }), $[0] = t0) : t0 = $[0];
  let t1;
  $[1] !== getCommentIntent || $[2] !== props.children ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(sanity.CommentsIntentProvider, { getIntent: getCommentIntent, children: props.children }), $[1] = getCommentIntent, $[2] = props.children, $[3] = t1) : t1 = $[3];
  let t2;
  return $[4] !== documentId || $[5] !== setDisplayedDocument || $[6] !== t1 ? (t2 = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    t0,
    /* @__PURE__ */ jsxRuntime.jsx(Panel, { id: "content", minWidth: 325, order: 5, children: /* @__PURE__ */ jsxRuntime.jsx(DisplayedDocumentBroadcaster.DisplayedDocumentBroadcasterProvider, { documentId, setDisplayedDocument, children: t1 }) })
  ] }), $[4] = documentId, $[5] = setDisplayedDocument, $[6] = t1, $[7] = t2) : t2 = $[7], t2;
}, PresentationContent = (props) => {
  const $ = reactCompilerRuntime.c(14), {
    documentId,
    documentsOnPage,
    documentType,
    getCommentIntent,
    mainDocumentState,
    onFocusPath,
    onStructureParams,
    searchParams,
    setDisplayedDocument,
    structureParams
  } = props;
  let t0;
  $[0] !== documentId || $[1] !== documentType || $[2] !== documentsOnPage || $[3] !== mainDocumentState || $[4] !== onFocusPath || $[5] !== onStructureParams || $[6] !== searchParams || $[7] !== structureParams ? (t0 = /* @__PURE__ */ jsxRuntime.jsx(ContentEditor, { documentId, documentType, mainDocumentState, onFocusPath, onStructureParams, refs: documentsOnPage, searchParams, structureParams }), $[0] = documentId, $[1] = documentType, $[2] = documentsOnPage, $[3] = mainDocumentState, $[4] = onFocusPath, $[5] = onStructureParams, $[6] = searchParams, $[7] = structureParams, $[8] = t0) : t0 = $[8];
  let t1;
  return $[9] !== documentId || $[10] !== getCommentIntent || $[11] !== setDisplayedDocument || $[12] !== t0 ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(PresentationContentWrapper, { documentId, getCommentIntent, setDisplayedDocument, children: t0 }), $[9] = documentId, $[10] = getCommentIntent, $[11] = setDisplayedDocument, $[12] = t0, $[13] = t1) : t1 = $[13], t1;
}, PresentationNavigateProvider = function(props) {
  const $ = reactCompilerRuntime.c(5), {
    children,
    navigate: _navigate
  } = props;
  let t0;
  $[0] !== _navigate ? (t0 = (preview, t12) => {
    _navigate((t12 === void 0 ? void 0 : t12) || {}, preview ? {
      preview
    } : {});
  }, $[0] = _navigate, $[1] = t0) : t0 = $[1];
  const navigate = t0;
  let t1;
  return $[2] !== children || $[3] !== navigate ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(index.PresentationNavigateContext.Provider, { value: navigate, children }), $[2] = children, $[3] = navigate, $[4] = t1) : t1 = $[4], t1;
};
function useLocalState(key, defaultValue) {
  const $ = reactCompilerRuntime.c(9);
  let t0;
  $[0] !== defaultValue || $[1] !== key ? (t0 = () => {
    var _a;
    return JSON.parse((_a = localStorage.getItem(key)) != null ? _a : JSON.stringify(defaultValue));
  }, $[0] = defaultValue, $[1] = key, $[2] = t0) : t0 = $[2];
  const [value, setValue] = react.useState(t0);
  let t1, t2;
  $[3] !== key || $[4] !== value ? (t1 = () => {
    localStorage.setItem(key, JSON.stringify(value));
  }, t2 = [key, value], $[3] = key, $[4] = value, $[5] = t1, $[6] = t2) : (t1 = $[5], t2 = $[6]), react.useEffect(t1, t2);
  let t3;
  return $[7] !== value ? (t3 = [value, setValue], $[7] = value, $[8] = t3) : t3 = $[8], t3;
}
var __defProp$6 = Object.defineProperty, __getOwnPropSymbols$6 = Object.getOwnPropertySymbols, __hasOwnProp$6 = Object.prototype.hasOwnProperty, __propIsEnum$6 = Object.prototype.propertyIsEnumerable, __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$6.call(b, prop) && __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b))
      __propIsEnum$6.call(b, prop) && __defNormalProp$6(a, prop, b[prop]);
  return a;
};
function usePresentationNavigator(props) {
  const $ = reactCompilerRuntime.c(11), {
    unstable_navigator
  } = props, navigatorProvided = !!(unstable_navigator != null && unstable_navigator.component), [_navigatorEnabled, setNavigatorEnabled] = useLocalState("presentation/navigator", navigatorProvided), navigatorEnabled = navigatorProvided ? _navigatorEnabled : !1;
  let t0;
  bb0: {
    if (!navigatorProvided) {
      t0 = void 0;
      break bb0;
    }
    let t12;
    $[0] !== setNavigatorEnabled ? (t12 = () => setNavigatorEnabled(_temp$4), $[0] = setNavigatorEnabled, $[1] = t12) : t12 = $[1], t0 = t12;
  }
  const toggleNavigator = t0;
  let t1;
  $[2] !== navigatorEnabled || $[3] !== unstable_navigator ? (t1 = function() {
    return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: navigatorEnabled && /* @__PURE__ */ jsxRuntime.jsx(Navigator, __spreadValues$6({}, unstable_navigator)) });
  }, $[2] = navigatorEnabled, $[3] = unstable_navigator, $[4] = t1) : t1 = $[4];
  const Component = t1;
  let t2;
  $[5] !== navigatorEnabled || $[6] !== toggleNavigator ? (t2 = {
    navigatorEnabled,
    toggleNavigator
  }, $[5] = navigatorEnabled, $[6] = toggleNavigator, $[7] = t2) : t2 = $[7];
  let t3;
  return $[8] !== Component || $[9] !== t2 ? (t3 = [t2, Component], $[8] = Component, $[9] = t2, $[10] = t3) : t3 = $[10], t3;
}
function _temp$4(enabled) {
  return !enabled;
}
function NavigatorComponent(props) {
  const $ = reactCompilerRuntime.c(11), {
    minWidth,
    maxWidth,
    component: NavigatorComponent2
  } = props, navigatorDisabled = minWidth != null && maxWidth != null && minWidth === maxWidth;
  let t0;
  $[0] !== NavigatorComponent2 ? (t0 = /* @__PURE__ */ jsxRuntime.jsx(NavigatorComponent2, {}), $[0] = NavigatorComponent2, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== maxWidth || $[3] !== minWidth || $[4] !== t0 ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(Panel, { id: "navigator", minWidth, maxWidth, order: 1, children: t0 }), $[2] = maxWidth, $[3] = minWidth, $[4] = t0, $[5] = t1) : t1 = $[5];
  let t2;
  $[6] !== navigatorDisabled ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(PanelResizer, { order: 2, disabled: navigatorDisabled }), $[6] = navigatorDisabled, $[7] = t2) : t2 = $[7];
  let t3;
  return $[8] !== t1 || $[9] !== t2 ? (t3 = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    t1,
    t2
  ] }), $[8] = t1, $[9] = t2, $[10] = t3) : t3 = $[10], t3;
}
const Navigator = react.memo(NavigatorComponent), PresentationParamsProvider = function(props) {
  const $ = reactCompilerRuntime.c(3), {
    children,
    params
  } = props;
  let t0;
  t0 = params;
  const context = t0;
  let t1;
  return $[0] !== children || $[1] !== context ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(index.PresentationParamsContext.Provider, { value: context, children }), $[0] = children, $[1] = context, $[2] = t1) : t1 = $[2], t1;
}, PresentationProvider = function(props) {
  const $ = reactCompilerRuntime.c(10), {
    children,
    devMode,
    name,
    navigate,
    params,
    searchParams,
    structureParams
  } = props;
  let t0, t1;
  $[0] !== devMode || $[1] !== name || $[2] !== navigate || $[3] !== params || $[4] !== searchParams || $[5] !== structureParams ? (t1 = {
    devMode,
    name,
    navigate,
    params,
    searchParams,
    structureParams
  }, $[0] = devMode, $[1] = name, $[2] = navigate, $[3] = params, $[4] = searchParams, $[5] = structureParams, $[6] = t1) : t1 = $[6], t0 = t1;
  const context = t0;
  let t2;
  return $[7] !== children || $[8] !== context ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(index.PresentationContext.Provider, { value: context, children }), $[7] = children, $[8] = context, $[9] = t2) : t2 = $[9], t2;
};
var __defProp$5 = Object.defineProperty, __defProps$4 = Object.defineProperties, __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$5 = Object.getOwnPropertySymbols, __hasOwnProp$5 = Object.prototype.hasOwnProperty, __propIsEnum$5 = Object.prototype.propertyIsEnumerable, __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$5.call(b, prop) && __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b))
      __propIsEnum$5.call(b, prop) && __defNormalProp$5(a, prop, b[prop]);
  return a;
}, __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
const IFrameElement = framerMotion.motion.create(styledComponents.styled.iframe`
  box-shadow: 0 0 0 1px var(--card-border-color);
  border: 0;
  max-height: 100%;
  width: 100%;
  view-transition-class: presentation-tool-iframe;
`), IFrameOverlay = styledComponents.styled(ui.Box)`
  position: absolute;
  inset: 0;
  background: transparent;
`, IFrame = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(16), {
    animate,
    initial,
    onLoad,
    preventClick,
    src,
    variants,
    style
  } = props, t0 = `presentation-tool-iframe-${react.useId().replace(/[^a-zA-Z0-9-_]/g, "_")}`;
  let t1;
  $[0] !== style || $[1] !== t0 ? (t1 = __spreadProps$4(__spreadValues$5({}, style), {
    viewTransitionName: t0
  }), $[0] = style, $[1] = t0, $[2] = t1) : t1 = $[2];
  let t2;
  $[3] !== animate || $[4] !== initial || $[5] !== onLoad || $[6] !== ref || $[7] !== src || $[8] !== t1 || $[9] !== variants ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(IFrameElement, { style: t1, animate, initial, onLoad, ref, src, variants }), $[3] = animate, $[4] = initial, $[5] = onLoad, $[6] = ref, $[7] = src, $[8] = t1, $[9] = variants, $[10] = t2) : t2 = $[10];
  let t3;
  $[11] !== preventClick ? (t3 = preventClick && /* @__PURE__ */ jsxRuntime.jsx(IFrameOverlay, {}), $[11] = preventClick, $[12] = t3) : t3 = $[12];
  let t4;
  return $[13] !== t2 || $[14] !== t3 ? (t4 = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    t2,
    t3
  ] }), $[13] = t2, $[14] = t3, $[15] = t4) : t4 = $[15], t4;
});
function OpenPreviewButton(props) {
  const $ = reactCompilerRuntime.c(16), {
    openPopup,
    previewLocationOrigin,
    previewLocationRoute
  } = props, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace);
  let t0;
  $[0] !== openPopup ? (t0 = (event) => {
    event.preventDefault(), openPopup(event.currentTarget.href);
  }, $[0] = openPopup, $[1] = t0) : t0 = $[1];
  const handleOpenPopup = t0;
  let t1;
  $[2] !== t ? (t1 = t("share-url.menu-item.open.text"), $[2] = t, $[3] = t1) : t1 = $[3];
  let t2;
  $[4] !== t1 ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t1 }), $[4] = t1, $[5] = t2) : t2 = $[5];
  let t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = ["bottom-start"], $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== t ? (t4 = t("share-url.menu-item.open.text"), $[7] = t, $[8] = t4) : t4 = $[8];
  const t5 = `${previewLocationOrigin}${previewLocationRoute}`;
  let t6;
  $[9] !== handleOpenPopup || $[10] !== t4 || $[11] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { as: "a", "aria-label": t4, fontSize: 1, icon: icons.LaunchIcon, mode: "bleed", padding: 2, href: t5, onClick: handleOpenPopup, rel: "opener", target: "_blank" }), $[9] = handleOpenPopup, $[10] = t4, $[11] = t5, $[12] = t6) : t6 = $[12];
  let t7;
  return $[13] !== t2 || $[14] !== t6 ? (t7 = /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { animate: !0, content: t2, fallbackPlacements: t3, padding: 2, placement: "bottom", portal: !0, children: t6 }), $[13] = t2, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}
const PreviewLocationInput = function(props) {
  var _a;
  const $ = reactCompilerRuntime.c(27), {
    fontSize: t0,
    onChange,
    origin,
    padding: t1,
    prefix,
    suffix,
    value
  } = props, fontSize = t0 === void 0 ? 1 : t0, padding = t1 === void 0 ? 3 : t1, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace), {
    basePath: t2
  } = ((_a = sanity.useActiveWorkspace()) == null ? void 0 : _a.activeWorkspace) || {}, basePath = t2 === void 0 ? "/" : t2, inputRef = react.useRef(null), [sessionValue, setSessionValue] = react.useState(void 0), [customValidity, setCustomValidity] = react.useState(void 0);
  let t3;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t3 = (event) => {
    setSessionValue(event.currentTarget.value);
  }, $[0] = t3) : t3 = $[0];
  const handleChange = t3;
  let t4;
  $[1] !== basePath || $[2] !== onChange || $[3] !== origin || $[4] !== sessionValue || $[5] !== t ? (t4 = (event_0) => {
    var _a2;
    if (event_0.key === "Enter") {
      if (sessionValue === void 0)
        return;
      const absoluteValue = sessionValue.startsWith("/") || sessionValue === "" ? `${origin}${sessionValue}` : sessionValue;
      if (!absoluteValue.startsWith(origin + "/") && absoluteValue !== origin) {
        setCustomValidity(t("preview-location-input.error", {
          origin,
          context: "missing-origin"
        }));
        return;
      }
      if (!origin && (absoluteValue.startsWith(`${basePath}/`) || absoluteValue === basePath)) {
        setCustomValidity(t("preview-location-input.error", {
          basePath,
          context: "same-base-path"
        }));
        return;
      }
      const nextValue = absoluteValue === origin ? origin + "/" : absoluteValue;
      setCustomValidity(void 0), setSessionValue(void 0), onChange(nextValue.slice(origin.length)), (_a2 = inputRef.current) == null || _a2.blur();
    }
    event_0.key === "Escape" && (setCustomValidity(void 0), setSessionValue(void 0));
  }, $[1] = basePath, $[2] = onChange, $[3] = origin, $[4] = sessionValue, $[5] = t, $[6] = t4) : t4 = $[6];
  const handleKeyDown = t4;
  let t5;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    setCustomValidity(void 0), setSessionValue(void 0);
  }, $[7] = t5) : t5 = $[7];
  const handleBlur = t5;
  let t6;
  $[8] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => {
    setCustomValidity(void 0), setSessionValue(void 0);
  }, $[8] = t6) : t6 = $[8];
  let t7;
  $[9] !== origin || $[10] !== value ? (t7 = [origin, value], $[9] = origin, $[10] = value, $[11] = t7) : t7 = $[11], react.useEffect(t6, t7);
  let t8, t9;
  $[12] === Symbol.for("react.memo_cache_sentinel") ? (t9 = {
    icon: icons.ResetIcon
  }, $[12] = t9) : t9 = $[12], t8 = t9;
  const t10 = customValidity ? t8 : void 0;
  let t11;
  $[13] !== origin || $[14] !== value ? (t11 = () => {
    setCustomValidity(void 0), setSessionValue(origin + value);
  }, $[13] = origin, $[14] = value, $[15] = t11) : t11 = $[15];
  let t12;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t12 = {
    zIndex: 1
  }, $[16] = t12) : t12 = $[16];
  const t13 = sessionValue === void 0 ? `${origin}${value}` : sessionValue;
  let t14;
  return $[17] !== customValidity || $[18] !== fontSize || $[19] !== handleKeyDown || $[20] !== padding || $[21] !== prefix || $[22] !== suffix || $[23] !== t10 || $[24] !== t11 || $[25] !== t13 ? (t14 = /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { clearButton: t10, customValidity, fontSize, onBlur: handleBlur, onClear: t11, onChange: handleChange, onKeyDownCapture: handleKeyDown, padding, prefix, style: t12, radius: 2, ref: inputRef, space: padding, suffix, value: t13 }) }), $[17] = customValidity, $[18] = fontSize, $[19] = handleKeyDown, $[20] = padding, $[21] = prefix, $[22] = suffix, $[23] = t10, $[24] = t11, $[25] = t13, $[26] = t14) : t14 = $[26], t14;
}, QRCodeSVG = react.lazy(() => Promise.resolve().then(function() {
  return require("./QRCodeSVG.cjs");
})), QrCodeLogoSize = 24, QrCodeLogoPadding = 16, QrSize = 224, StyledSanityMonogram = styledComponents.styled(logos.SanityMonogram)`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  height: ${QrCodeLogoSize}px;
  width: ${QrCodeLogoSize}px;
`, MotionSpinner = framerMotion.motion.create(ui.Spinner), MotionText = framerMotion.motion.create(ui.Text), MotionMonogram = framerMotion.motion.create(StyledSanityMonogram), SharePreviewMenu = react.memo(function(props) {
  const {
    canToggleSharePreviewAccess,
    canUseSharedPreviewAccess,
    initialUrl,
    previewLocationRoute,
    perspective
  } = props, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace), {
    push: pushToast
  } = ui.useToast(), client = sanity.useClient({
    apiVersion: index.API_VERSION
  }), currentUser = sanity.useCurrentUser(), [loading, setLoading] = react.useState(!0), [enabling, setEnabling] = react.useState(!1), [disabling, setDisabling] = react.useState(!1), [secret, setSecret] = react.useState(null), busy = enabling || disabling || loading, url = react.useMemo(() => secret ? withoutSecretSearchParams.setSecretSearchParams(initialUrl, secret, previewLocationRoute, perspective) : null, [initialUrl, perspective, previewLocationRoute, secret]), [error, setError] = react.useState(null);
  if (error)
    throw error;
  const handleUnableToToggle = react.useCallback(() => {
    pushToast({
      closable: !0,
      status: "warning",
      title: t("share-preview-menu.error_toggle-sharing", {
        context: "toggle-sharing"
      })
    });
  }, [pushToast, t]), handleDisableSharing = react.useCallback(async () => {
    try {
      setDisabling(!0), await togglePreviewAccessSharing.disablePreviewAccessSharing(client, "@sanity/presentation", typeof window > "u" ? "" : location.href, currentUser == null ? void 0 : currentUser.id), setSecret(null);
    } catch (error_0) {
      setError(error_0);
    } finally {
      setDisabling(!1);
    }
  }, [client, currentUser == null ? void 0 : currentUser.id]), handleEnableSharing = react.useCallback(async () => {
    try {
      setEnabling(!0);
      const previewUrlSecret = await togglePreviewAccessSharing.enablePreviewAccessSharing(client, "@sanity/presentation", typeof window > "u" ? "" : location.href, currentUser == null ? void 0 : currentUser.id);
      setSecret(previewUrlSecret.secret);
    } catch (error_1) {
      setError(error_1);
    } finally {
      setEnabling(!1);
    }
  }, [client, currentUser == null ? void 0 : currentUser.id]), handleCopyUrl = react.useCallback(() => {
    try {
      if (!url)
        throw new Error("No URL to copy");
      navigator.clipboard.writeText(url.toString()), pushToast({
        closable: !0,
        status: "success",
        title: t("share-url.clipboard.status", {
          context: "success"
        })
      });
    } catch (error_2) {
      setError(error_2);
    }
  }, [pushToast, t, url]);
  return react.useEffect(() => {
    let controller = new AbortController(), usedTags = [];
    async function fetchShareSecret(lastLiveEventId, signal) {
      const {
        result,
        syncTags
      } = await client.fetch(constants.fetchSharedAccessQuery, {}, {
        filterResponse: !1,
        lastLiveEventId,
        tag: "presentation.fetch-shared-access-secret"
      });
      Array.isArray(syncTags) && (usedTags = syncTags), signal.aborted || setSecret(result);
    }
    const subscription = client.live.events().subscribe({
      next: (event) => {
        event.type === "message" && (controller.abort(), controller = new AbortController(), event.tags.some((tag) => usedTags.includes(tag)) && fetchShareSecret(event.id, controller.signal));
      },
      error: setError
    });
    return fetchShareSecret(null, controller.signal).finally(() => setLoading(!1)), () => {
      subscription.unsubscribe(), controller.abort();
    };
  }, [client]), /* @__PURE__ */ jsxRuntime.jsx(ui.MenuButton, { button: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { "aria-label": t("preview-frame.share-button.aria-label"), fontSize: 1, icon: icons.ShareIcon, mode: "bleed", padding: 2 }), id: "share-menu", menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { style: {
    maxWidth: 248
  }, padding: canUseSharedPreviewAccess ? void 0 : 0, children: canUseSharedPreviewAccess ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("label", { style: {
      cursor: "pointer"
    }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: 2, rows: 2, gapX: 3, gapY: 1, style: {
      justifyContent: "center",
      alignItems: "center",
      gridTemplateColumns: "min-content 1fr",
      gridTemplateRows: "min-content"
    }, paddingTop: 3, paddingX: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { animate: !0, content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t("share-preview-menu.toggle-button.tooltip", {
        context: url ? "disable" : "enable"
      }) }), fallbackPlacements: ["bottom-start"], padding: 1, placement: "bottom", portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Switch, { checked: enabling || url !== null && !disabling, readOnly: enabling || disabling, indeterminate: loading, onChange: canToggleSharePreviewAccess ? url ? handleDisableSharing : handleEnableSharing : handleUnableToToggle }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t("share-preview-menu.toggle-button.label", {
        context: "first-line"
      }) }),
      /* @__PURE__ */ jsxRuntime.jsx("span", {}),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t("share-preview-menu.toggle-button.label", {
        context: "second-line"
      }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, paddingTop: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: busy || !url ? "transparent" : void 0, style: {
        position: "relative",
        aspectRatio: "1 / 1",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }, children: /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: busy ? /* @__PURE__ */ jsxRuntime.jsx(MotionSpinner, { muted: !0, initial: {
        opacity: 0
      }, animate: {
        opacity: 1
      }, exit: {
        opacity: 0
      } }) : url ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsxs(react.Suspense, { fallback: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, {}), children: [
        /* @__PURE__ */ jsxRuntime.jsx(QRCodeSVG, { title: t("share-preview-menu.qr-code.title", {
          url: url.toString()
        }), value: url.toString(), size: QrSize, color: "var(--card-fg-color)", logoSize: QrCodeLogoSize + QrCodeLogoPadding }),
        /* @__PURE__ */ jsxRuntime.jsx(MotionMonogram, { initial: {
          opacity: -0.5
        }, animate: {
          opacity: 1.5
        }, exit: {
          opacity: 0
        } })
      ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(MotionText, { muted: !0, size: 1, style: {
        maxWidth: "100px",
        textWrap: "pretty",
        textAlign: "center"
      }, initial: {
        opacity: 0
      }, animate: {
        opacity: 1
      }, exit: {
        opacity: 0
      }, children: t("share-preview-menu.qr-code.placeholder") }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t("share-preview-menu.qr-code.instructions") })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { disabled: !url || disabling, icon: icons.CopyIcon, onClick: handleCopyUrl, fontSize: 1, padding: 3, text: t("share-preview-menu.copy-url.text") })
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, tone: "caution", radius: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { style: {
    textWrap: "pretty"
  }, children: t("share-preview-menu.error", {
    context: "missing-grants"
  }) }) }) }), popover: {
    animate: !0,
    constrainSize: !0,
    placement: "bottom",
    portal: !0
  } });
});
SharePreviewMenu.displayName = "Memo(SharePreviewMenu)";
var __defProp$4 = Object.defineProperty, __defProps$3 = Object.defineProperties, __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$4 = Object.getOwnPropertySymbols, __hasOwnProp$4 = Object.prototype.hasOwnProperty, __propIsEnum$4 = Object.prototype.propertyIsEnumerable, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$4.call(b, prop) && __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b))
      __propIsEnum$4.call(b, prop) && __defNormalProp$4(a, prop, b[prop]);
  return a;
}, __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
const PERSPECTIVE_TITLE_KEY = {
  previewDrafts: "preview-frame.perspective.previewDrafts.title",
  published: "preview-frame.perspective.published.title"
}, PERSPECTIVE_TONES = {
  previewDrafts: "caution",
  published: "positive"
}, PERSPECTIVE_ICONS = {
  previewDrafts: icons.EditIcon,
  published: icons.PublishIcon
}, PreviewHeaderDefault = (props) => {
  const $ = reactCompilerRuntime.c(164), {
    canSharePreviewAccess,
    canToggleSharePreviewAccess,
    canUseSharedPreviewAccess,
    dispatch,
    iframe,
    iframeRef,
    initialUrl,
    loadersConnection,
    navigatorEnabled,
    onPathChange,
    onRefresh,
    openPopup,
    overlaysConnection,
    perspective,
    previewUrl,
    setPerspective,
    setViewport,
    targetOrigin,
    toggleNavigator,
    toggleOverlay,
    viewport,
    visualEditing: t0
  } = props, {
    overlaysEnabled
  } = t0, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace);
  let t1;
  $[0] !== setViewport || $[1] !== viewport ? (t1 = () => setViewport(viewport === "desktop" ? "mobile" : "desktop"), $[0] = setViewport, $[1] = viewport, $[2] = t1) : t1 = $[2];
  const toggleViewportSize = t1;
  let t2;
  t2 = targetOrigin === location.origin ? "" : targetOrigin;
  const previewLocationOrigin = t2;
  let t3;
  $[3] !== dispatch || $[4] !== iframeRef.current || $[5] !== onRefresh || $[6] !== previewUrl || $[7] !== targetOrigin ? (t3 = () => {
    onRefresh(() => {
      iframeRef.current && (dispatch({
        type: index.ACTION_IFRAME_RELOAD
      }), Object.assign(iframeRef.current, {
        src: `${targetOrigin}${previewUrl || "/"}`
      }));
    });
  }, $[3] = dispatch, $[4] = iframeRef.current, $[5] = onRefresh, $[6] = previewUrl, $[7] = targetOrigin, $[8] = t3) : t3 = $[8];
  const handleRefresh = t3;
  let t4;
  const previewURL = new URL(previewUrl || "/", targetOrigin), {
    pathname,
    search
  } = withoutSecretSearchParams.withoutSecretSearchParams(previewURL);
  t4 = `${pathname}${search}`;
  const previewLocationRoute = t4;
  let t5;
  $[9] !== navigatorEnabled || $[10] !== t || $[11] !== toggleNavigator ? (t5 = toggleNavigator && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", marginRight: 1, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { animate: !0, content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t("preview-frame.navigator.toggle-button.tooltip") }), fallbackPlacements: ["bottom-start"], padding: 2, placement: "bottom", portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { "aria-label": t("preview-frame.navigator.toggle-button.aria-label"), fontSize: 1, icon: icons.PanelLeftIcon, mode: "bleed", onClick: toggleNavigator, padding: 2, selected: navigatorEnabled }) }) }), $[9] = navigatorEnabled, $[10] = t, $[11] = toggleNavigator, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] === Symbol.for("react.memo_cache_sentinel") ? (t6 = {
    whiteSpace: "nowrap"
  }, $[13] = t6) : t6 = $[13];
  const t7 = overlaysEnabled ? "disable" : "enable";
  let t8;
  $[14] !== t || $[15] !== t7 ? (t8 = t("preview-frame.overlay.toggle-button.tooltip", {
    context: t7
  }), $[14] = t, $[15] = t7, $[16] = t8) : t8 = $[16];
  let t9;
  $[17] !== t8 ? (t9 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t8 }) }), $[17] = t8, $[18] = t9) : t9 = $[18];
  let t10;
  $[19] === Symbol.for("react.memo_cache_sentinel") ? (t10 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Hotkeys, { keys: ["Alt"], style: {
    marginTop: -4,
    marginBottom: -4
  } }) }), $[19] = t10) : t10 = $[19];
  let t11;
  $[20] !== t9 ? (t11 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", style: t6, children: [
    t9,
    t10
  ] }), $[20] = t9, $[21] = t11) : t11 = $[21];
  let t12;
  $[22] === Symbol.for("react.memo_cache_sentinel") ? (t12 = ["bottom-start"], $[22] = t12) : t12 = $[22];
  let t13;
  $[23] === Symbol.for("react.memo_cache_sentinel") ? (t13 = {
    lineHeight: 0,
    borderRadius: 999,
    userSelect: "none"
  }, $[23] = t13) : t13 = $[23];
  const t14 = overlaysEnabled ? "transparent" : void 0;
  let t15;
  $[24] === Symbol.for("react.memo_cache_sentinel") ? (t15 = {
    margin: -4
  }, $[24] = t15) : t15 = $[24];
  const t16 = iframe.status === "loading" || overlaysConnection !== "connected";
  let t17;
  $[25] !== overlaysEnabled || $[26] !== t16 || $[27] !== toggleOverlay ? (t17 = /* @__PURE__ */ jsxRuntime.jsx("div", { style: t15, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Switch, { checked: overlaysEnabled, onChange: toggleOverlay, disabled: t16 }) }), $[25] = overlaysEnabled, $[26] = t16, $[27] = toggleOverlay, $[28] = t17) : t17 = $[28];
  const t18 = !overlaysEnabled;
  let t19;
  $[29] !== t ? (t19 = t("preview-frame.overlay.toggle-button.text"), $[29] = t, $[30] = t19) : t19 = $[30];
  let t20;
  $[31] !== t18 || $[32] !== t19 ? (t20 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: t18, size: 1, weight: "medium", children: t19 }) }), $[31] = t18, $[32] = t19, $[33] = t20) : t20 = $[33];
  let t21;
  $[34] !== t17 || $[35] !== t20 ? (t21 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    t17,
    t20
  ] }), $[34] = t17, $[35] = t20, $[36] = t21) : t21 = $[36];
  let t22;
  $[37] !== t14 || $[38] !== t21 ? (t22 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "label", flex: "none", marginRight: 1, padding: 3, style: t13, tone: t14, children: t21 }), $[37] = t14, $[38] = t21, $[39] = t22) : t22 = $[39];
  let t23;
  $[40] !== t11 || $[41] !== t22 ? (t23 = /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { animate: !0, content: t11, fallbackPlacements: t12, padding: 1, placement: "bottom", portal: !0, children: t22 }), $[40] = t11, $[41] = t22, $[42] = t23) : t23 = $[42];
  let t24;
  $[43] !== iframe.status || $[44] !== t ? (t24 = iframe.status === "loaded" ? t("preview-frame.refresh-button.tooltip") : t("preview-frame.status", {
    context: iframe.status
  }), $[43] = iframe.status, $[44] = t, $[45] = t24) : t24 = $[45];
  let t25;
  $[46] !== t24 ? (t25 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t24 }), $[46] = t24, $[47] = t25) : t25 = $[47];
  let t26;
  $[48] === Symbol.for("react.memo_cache_sentinel") ? (t26 = ["bottom-end"], $[48] = t26) : t26 = $[48];
  let t27;
  $[49] !== t ? (t27 = t("preview-frame.refresh-button.aria-label"), $[49] = t, $[50] = t27) : t27 = $[50];
  const t28 = iframe.status === "reloading" || iframe.status === "refreshing";
  let t29;
  $[51] !== handleRefresh || $[52] !== t27 || $[53] !== t28 ? (t29 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { "aria-label": t27, fontSize: 1, icon: icons.RefreshIcon, mode: "bleed", loading: t28, onClick: handleRefresh, padding: 2 }), $[51] = handleRefresh, $[52] = t27, $[53] = t28, $[54] = t29) : t29 = $[54];
  let t30;
  $[55] !== t25 || $[56] !== t29 ? (t30 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { animate: !0, content: t25, fallbackPlacements: t26, padding: 2, placement: "bottom", portal: !0, children: t29 }) }), $[55] = t25, $[56] = t29, $[57] = t30) : t30 = $[57];
  let t31;
  $[58] !== openPopup || $[59] !== previewLocationOrigin || $[60] !== previewLocationRoute ? (t31 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(OpenPreviewButton, { openPopup, previewLocationOrigin, previewLocationRoute }) }), $[58] = openPopup, $[59] = previewLocationOrigin, $[60] = previewLocationRoute, $[61] = t31) : t31 = $[61];
  let t32;
  $[62] !== onPathChange || $[63] !== previewLocationOrigin || $[64] !== previewLocationRoute || $[65] !== t30 || $[66] !== t31 ? (t32 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(PreviewLocationInput, { prefix: t30, onChange: onPathChange, origin: previewLocationOrigin, suffix: t31, value: previewLocationRoute }) }), $[62] = onPathChange, $[63] = previewLocationOrigin, $[64] = previewLocationRoute, $[65] = t30, $[66] = t31, $[67] = t32) : t32 = $[67];
  const t33 = PERSPECTIVE_TITLE_KEY[loadersConnection === "connected" ? perspective : "previewDrafts"];
  let t34;
  $[68] !== t || $[69] !== t33 ? (t34 = t(t33), $[68] = t, $[69] = t33, $[70] = t34) : t34 = $[70];
  const t35 = loadersConnection === "reconnecting" && iframe.status !== "loaded", t36 = loadersConnection !== "connected";
  let t37;
  $[71] !== t34 || $[72] !== t35 || $[73] !== t36 ? (t37 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, iconRight: icons.ChevronDownIcon, mode: "bleed", padding: 2, space: 2, text: t34, loading: t35, disabled: t36 }), $[71] = t34, $[72] = t35, $[73] = t36, $[74] = t37) : t37 = $[74];
  let t38;
  $[75] === Symbol.for("react.memo_cache_sentinel") ? (t38 = {
    maxWidth: 240
  }, $[75] = t38) : t38 = $[75];
  let t39;
  $[76] !== setPerspective ? (t39 = () => setPerspective("previewDrafts"), $[76] = setPerspective, $[77] = t39) : t39 = $[77];
  const t40 = perspective === "previewDrafts";
  let t41;
  $[78] === Symbol.for("react.memo_cache_sentinel") ? (t41 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: react.createElement(PERSPECTIVE_ICONS.previewDrafts) }) }), $[78] = t41) : t41 = $[78];
  let t42;
  $[79] !== t ? (t42 = t(PERSPECTIVE_TITLE_KEY.previewDrafts), $[79] = t, $[80] = t42) : t42 = $[80];
  let t43;
  $[81] !== t42 ? (t43 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t42 }), $[81] = t42, $[82] = t43) : t43 = $[82];
  let t44;
  $[83] !== t ? (t44 = t("preview-frame.perspective.previewDrafts.text"), $[83] = t, $[84] = t44) : t44 = $[84];
  let t45;
  $[85] !== t44 ? (t45 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t44 }), $[85] = t44, $[86] = t45) : t45 = $[86];
  let t46;
  $[87] !== t43 || $[88] !== t45 ? (t46 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
    t43,
    t45
  ] }), $[87] = t43, $[88] = t45, $[89] = t46) : t46 = $[89];
  const t47 = perspective === "previewDrafts" ? 1 : 0;
  let t48;
  $[90] !== t47 ? (t48 = {
    opacity: t47
  }, $[90] = t47, $[91] = t48) : t48 = $[91];
  let t49;
  $[92] === Symbol.for("react.memo_cache_sentinel") ? (t49 = /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}), $[92] = t49) : t49 = $[92];
  let t50;
  $[93] !== t48 ? (t50 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, style: t48, children: t49 }) }), $[93] = t48, $[94] = t50) : t50 = $[94];
  let t51;
  $[95] !== t46 || $[96] !== t50 ? (t51 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
    t41,
    t46,
    t50
  ] }), $[95] = t46, $[96] = t50, $[97] = t51) : t51 = $[97];
  let t52;
  $[98] !== t39 || $[99] !== t40 || $[100] !== t51 ? (t52 = /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { fontSize: 1, onClick: t39, padding: 3, pressed: t40, tone: PERSPECTIVE_TONES.previewDrafts, children: t51 }), $[98] = t39, $[99] = t40, $[100] = t51, $[101] = t52) : t52 = $[101];
  let t53;
  $[102] !== setPerspective ? (t53 = () => setPerspective("published"), $[102] = setPerspective, $[103] = t53) : t53 = $[103];
  const t54 = perspective === "published";
  let t55;
  $[104] === Symbol.for("react.memo_cache_sentinel") ? (t55 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: react.createElement(PERSPECTIVE_ICONS.published) }) }), $[104] = t55) : t55 = $[104];
  let t56;
  $[105] !== t ? (t56 = t(PERSPECTIVE_TITLE_KEY.published), $[105] = t, $[106] = t56) : t56 = $[106];
  let t57;
  $[107] !== t56 ? (t57 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t56 }), $[107] = t56, $[108] = t57) : t57 = $[108];
  let t58;
  $[109] !== t ? (t58 = t("preview-frame.perspective.published.text"), $[109] = t, $[110] = t58) : t58 = $[110];
  let t59;
  $[111] !== t58 ? (t59 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t58 }), $[111] = t58, $[112] = t59) : t59 = $[112];
  let t60;
  $[113] !== t57 || $[114] !== t59 ? (t60 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
    t57,
    t59
  ] }), $[113] = t57, $[114] = t59, $[115] = t60) : t60 = $[115];
  const t61 = perspective === "published" ? 1 : 0;
  let t62;
  $[116] !== t61 ? (t62 = {
    opacity: t61
  }, $[116] = t61, $[117] = t62) : t62 = $[117];
  let t63;
  $[118] === Symbol.for("react.memo_cache_sentinel") ? (t63 = /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}), $[118] = t63) : t63 = $[118];
  let t64;
  $[119] !== t62 ? (t64 = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, style: t62, children: t63 }) }), $[119] = t62, $[120] = t64) : t64 = $[120];
  let t65;
  $[121] !== t60 || $[122] !== t64 ? (t65 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
    t55,
    t60,
    t64
  ] }), $[121] = t60, $[122] = t64, $[123] = t65) : t65 = $[123];
  let t66;
  $[124] !== t53 || $[125] !== t54 || $[126] !== t65 ? (t66 = /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { fontSize: 1, onClick: t53, padding: 3, pressed: t54, tone: PERSPECTIVE_TONES.published, children: t65 }), $[124] = t53, $[125] = t54, $[126] = t65, $[127] = t66) : t66 = $[127];
  let t67;
  $[128] !== t52 || $[129] !== t66 ? (t67 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { style: t38, children: [
    t52,
    t66
  ] }), $[128] = t52, $[129] = t66, $[130] = t67) : t67 = $[130];
  let t68;
  $[131] === Symbol.for("react.memo_cache_sentinel") ? (t68 = {
    animate: !0,
    constrainSize: !0,
    placement: "bottom",
    portal: !0
  }, $[131] = t68) : t68 = $[131];
  let t69;
  $[132] !== t37 || $[133] !== t67 ? (t69 = /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", flex: "none", gap: 1, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.MenuButton, { button: t37, id: "perspective-menu", menu: t67, popover: t68 }) }), $[132] = t37, $[133] = t67, $[134] = t69) : t69 = $[134];
  const t70 = viewport === "desktop" ? "narrow" : "full";
  let t71;
  $[135] !== t || $[136] !== t70 ? (t71 = t("preview-frame.viewport-button.tooltip", {
    context: t70
  }), $[135] = t, $[136] = t70, $[137] = t71) : t71 = $[137];
  let t72;
  $[138] !== t71 ? (t72 = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t71 }), $[138] = t71, $[139] = t72) : t72 = $[139];
  let t73;
  $[140] === Symbol.for("react.memo_cache_sentinel") ? (t73 = ["bottom-start"], $[140] = t73) : t73 = $[140];
  let t74;
  $[141] !== t ? (t74 = t("preview-frame.viewport-button.aria-label"), $[141] = t, $[142] = t74) : t74 = $[142];
  const t75 = viewport === "desktop" ? icons.MobileDeviceIcon : icons.DesktopIcon;
  let t76;
  $[143] !== t74 || $[144] !== t75 || $[145] !== toggleViewportSize ? (t76 = /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { "aria-label": t74, fontSize: 1, icon: t75, mode: "bleed", onClick: toggleViewportSize, padding: 2 }), $[143] = t74, $[144] = t75, $[145] = toggleViewportSize, $[146] = t76) : t76 = $[146];
  let t77;
  $[147] !== t72 || $[148] !== t76 ? (t77 = /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", flex: "none", gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Tooltip, { animate: !0, content: t72, fallbackPlacements: t73, padding: 2, placement: "bottom", portal: !0, children: t76 }) }), $[147] = t72, $[148] = t76, $[149] = t77) : t77 = $[149];
  let t78;
  $[150] !== canSharePreviewAccess || $[151] !== canToggleSharePreviewAccess || $[152] !== canUseSharedPreviewAccess || $[153] !== initialUrl || $[154] !== perspective || $[155] !== previewLocationRoute ? (t78 = canSharePreviewAccess && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", flex: "none", gap: 1, paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(SharePreviewMenu, { canToggleSharePreviewAccess, canUseSharedPreviewAccess, previewLocationRoute, initialUrl, perspective }) }), $[150] = canSharePreviewAccess, $[151] = canToggleSharePreviewAccess, $[152] = canUseSharedPreviewAccess, $[153] = initialUrl, $[154] = perspective, $[155] = previewLocationRoute, $[156] = t78) : t78 = $[156];
  let t79;
  return $[157] !== t23 || $[158] !== t32 || $[159] !== t5 || $[160] !== t69 || $[161] !== t77 || $[162] !== t78 ? (t79 = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    t5,
    t23,
    t32,
    t69,
    t77,
    t78
  ] }), $[157] = t23, $[158] = t32, $[159] = t5, $[160] = t69, $[161] = t77, $[162] = t78, $[163] = t79) : t79 = $[163], t79;
}, PreviewHeader = (props) => {
  var _a;
  const $ = reactCompilerRuntime.c(6), renderDefault = _temp$3;
  let t0;
  $[0] !== props ? (t0 = (_a = props.options) != null && _a.component ? react.createElement(props.options.component, __spreadProps$3(__spreadValues$4({}, props), {
    renderDefault
  })) : renderDefault(props), $[0] = props, $[1] = t0) : t0 = $[1];
  const header = t0;
  let t1;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    position: "relative"
  }, $[2] = t1) : t1 = $[2];
  let t2;
  $[3] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    minHeight: 0
  }, $[3] = t2) : t2 = $[3];
  let t3;
  return $[4] !== header ? (t3 = /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", padding: 2, borderBottom: !0, style: t1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", style: t2, children: header }) }), $[4] = header, $[5] = t3) : t3 = $[5], t3;
};
function usePresentationPreviewHeader(props) {
  const $ = reactCompilerRuntime.c(2);
  let t0;
  return $[0] !== props ? (t0 = () => /* @__PURE__ */ jsxRuntime.jsx(PreviewHeader, __spreadValues$4({}, props)), $[0] = props, $[1] = t0) : t0 = $[1], t0;
}
function _temp$3(props_0) {
  return react.createElement(PreviewHeaderDefault, props_0);
}
var __defProp$3 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$3 = Object.getOwnPropertySymbols, __hasOwnProp$3 = Object.prototype.hasOwnProperty, __propIsEnum$3 = Object.prototype.propertyIsEnumerable, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b))
      __propIsEnum$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  return a;
}, __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const MotionFlex = framerMotion.motion.create(ui.Flex), Preview = react.memo(react.forwardRef(function(props, forwardedRef) {
  const {
    dispatch,
    iframe,
    header,
    initialUrl,
    loadersConnection,
    overlaysConnection,
    viewport
  } = props, {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace), {
    devMode
  } = index.usePresentationTool(), prefersReducedMotion = ui.usePrefersReducedMotion(), ref = react.useRef(null), PreviewHeader2 = usePresentationPreviewHeader(__spreadProps$2(__spreadValues$3({}, props), {
    iframeRef: ref,
    options: header
  }));
  react.useImperativeHandle(forwardedRef, () => ref.current);
  const loading = iframe.status === "loading" || iframe.status === "reloading", [timedOut, setTimedOut] = react.useState(!1), refreshing = iframe.status === "refreshing", [somethingIsWrong, setSomethingIsWrong] = react.useState(!1), iframeIsBusy = loading || refreshing || overlaysConnection === "connecting", handleRetry = react.useCallback(() => {
    ref.current && (ref.current.src = initialUrl.toString(), dispatch({
      type: index.ACTION_IFRAME_RELOAD
    }));
  }, [dispatch, initialUrl]), handleContinueAnyway = react.useCallback(() => {
    setContinueAnyway(!0);
  }, []), [continueAnyway, setContinueAnyway] = react.useState(!1), [showOverlaysConnectionStatus, setShowOverlaysConnectionState] = react.useState(!1);
  react.useEffect(() => {
    if (!(loading || refreshing) && (overlaysConnection === "connecting" || overlaysConnection === "reconnecting")) {
      const timeout = setTimeout(() => {
        setShowOverlaysConnectionState(!0);
      }, 5e3);
      return () => clearTimeout(timeout);
    }
  }, [overlaysConnection, loading, refreshing]), react.useEffect(() => {
    if (!(loading || refreshing || !showOverlaysConnectionStatus)) {
      if (overlaysConnection === "connected" && (setSomethingIsWrong(!1), setShowOverlaysConnectionState(!1), setTimedOut(!1), setContinueAnyway(!1)), overlaysConnection === "connecting") {
        const timeout_0 = setTimeout(() => {
          setTimedOut(!0), console.error("Unable to connect to visual editing. Make sure you've setup '@sanity/visual-editing' correctly");
        }, index.MAX_TIME_TO_OVERLAYS_CONNECTION);
        return () => clearTimeout(timeout_0);
      }
      if (overlaysConnection === "reconnecting") {
        const timeout_1 = setTimeout(() => {
          setTimedOut(!0), setSomethingIsWrong(!0);
        }, index.MAX_TIME_TO_OVERLAYS_CONNECTION);
        return () => clearTimeout(timeout_1);
      }
    }
  }, [loading, overlaysConnection, refreshing, showOverlaysConnectionStatus]);
  const onIFrameLoad = react.useCallback(() => {
    dispatch({
      type: index.ACTION_IFRAME_LOADED
    });
  }, [dispatch]);
  react.useEffect(() => {
    if (!ref.current)
      return;
    const instance = ref.current;
    function handleBlur() {
      instance === document.activeElement && instance.dispatchEvent(new MouseEvent("mousedown", {
        bubbles: !0,
        cancelable: !0
      }));
    }
    return window.addEventListener("blur", handleBlur), () => {
      window.removeEventListener("blur", handleBlur);
    };
  }, []);
  const preventIframeInteraction = react.useMemo(() => (loading || overlaysConnection === "connecting" && iframe.status !== "refreshing") && !continueAnyway, [continueAnyway, iframe.status, loading, overlaysConnection]), canUseViewTransition = react.useSyncExternalStore(react.useCallback(() => () => {
  }, []), () => CSS.supports("(view-transition-name: test)")), iframeAnimations = react.useMemo(() => [
    preventIframeInteraction ? "background" : "active",
    loading ? "reloading" : "idle",
    // If CSS View Transitions are supported, then transition iframe viewport dimensions with that instead of Motion
    canUseViewTransition ? "" : viewport,
    showOverlaysConnectionStatus && !continueAnyway ? "timedOut" : ""
  ], [canUseViewTransition, continueAnyway, loading, preventIframeInteraction, showOverlaysConnectionStatus, viewport]), [currentViewport, setCurrentViewport] = react.useState(viewport), [iframeStyle, setIframeStyle] = react.useState(iframeVariants[viewport]);
  return react.useEffect(() => {
    if (canUseViewTransition && viewport !== currentViewport) {
      const update = () => {
        setCurrentViewport(viewport), setIframeStyle(iframeVariants[viewport]);
      };
      !prefersReducedMotion && "startViewTransition" in document && typeof document.startViewTransition == "function" ? document.startViewTransition(() => reactDom.flushSync(() => update())) : update();
    }
  }, [canUseViewTransition, prefersReducedMotion, currentViewport, viewport]), /* @__PURE__ */ jsxRuntime.jsx(framerMotion.MotionConfig, { transition: prefersReducedMotion ? {
    duration: 0
  } : void 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.TooltipDelayGroupProvider, { delay: 1e3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(PreviewHeader2, {}),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: 1, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", height: "fill", justify: "center", padding: (canUseViewTransition ? currentViewport : viewport) === "desktop" ? 0 : 2, sizing: "border", style: {
      position: "relative",
      cursor: iframeIsBusy ? "wait" : void 0
    }, children: [
      /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: !somethingIsWrong && !loading && !refreshing && // viewport, // using CSS View Transitions instead of framer motion to drive this
      showOverlaysConnectionStatus && !continueAnyway ? /* @__PURE__ */ jsxRuntime.jsx(MotionFlex, { initial: "initial", animate: "animate", exit: "exit", variants: spinnerVariants, justify: "center", align: "center", style: {
        inset: "0",
        position: "absolute",
        backdropFilter: timedOut ? "blur(16px) saturate(0.5) grayscale(0.5)" : "blur(2px)",
        transition: "backdrop-filter 0.2s ease-in-out",
        // @TODO Because of Safari we have to do this
        WebkitBackdropFilter: timedOut ? "blur(16px) saturate(0.5) grayscale(0.5)" : "blur(2px)",
        WebkitTransition: "-webkit-backdrop-filter 0.2s ease-in-out",
        zIndex: 1
      }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { style: __spreadValues$3({}, sizes[viewport]), justify: "center", align: "center", direction: "column", gap: 4, children: [
        timedOut && /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { disabled: !0, fontSize: 1, mode: "ghost", text: t("preview-frame.continue-button.text"), style: {
          opacity: 0
        } }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, tone: timedOut ? "caution" : "inherit", padding: 4, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "center", align: "center", direction: "column", gap: 4, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: timedOut ? t("preview-frame.status", {
            context: "timeout"
          }) : t("preview-frame.status", {
            context: "connecting"
          }) })
        ] }) }),
        timedOut && /* @__PURE__ */ jsxRuntime.jsx(
          ui.Button,
          {
            fontSize: 1,
            tone: "critical",
            onClick: handleContinueAnyway,
            text: t("preview-frame.continue-button.text")
          }
        )
      ] }) }) : (loading || overlaysConnection === "connecting" && iframe.status !== "refreshing") && !continueAnyway ? /* @__PURE__ */ jsxRuntime.jsx(MotionFlex, { initial: "initial", animate: "animate", exit: "exit", variants: spinnerVariants, justify: "center", align: "center", style: {
        inset: "0",
        position: "absolute"
        // boxShadow: '0 0 0 1px var(--card-shadow-outline-color)',
      }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { style: __spreadValues$3({}, sizes[viewport]), justify: "center", align: "center", direction: "column", gap: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t("preview-frame.status", {
          context: "loading"
        }) })
      ] }) }) : somethingIsWrong && !continueAnyway ? /* @__PURE__ */ jsxRuntime.jsx(MotionFlex, { initial: "initial", animate: "animate", exit: "exit", variants: errorVariants, justify: "center", align: "center", style: {
        background: "var(--card-bg-color)",
        inset: "0",
        position: "absolute"
      }, children: /* @__PURE__ */ jsxRuntime.jsx(ErrorCard, { flex: 1, message: t("preview-frame.connection.error.text"), onRetry: handleRetry, onContinueAnyway: handleContinueAnyway, children: devMode && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        overlaysConnection !== "connected" && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { muted: !0, size: 0, children: t("preview-frame.overlay.connection-status.label") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: t("channel.status", {
            context: overlaysConnection
          }) })
        ] }) }),
        loadersConnection !== "connected" && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { muted: !0, size: 0, children: t("preview-frame.loader.connection-status.label") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: t("channel.status", {
            context: loadersConnection
          }) })
        ] }) })
      ] }) }) }) : null }),
      /* @__PURE__ */ jsxRuntime.jsx(IFrame, { animate: iframeAnimations, initial: ["background"], onLoad: onIFrameLoad, preventClick: preventIframeInteraction, ref, src: initialUrl.toString(), style: iframeStyle, variants: iframeVariants })
    ] }) })
  ] }) });
}));
Preview.displayName = "Memo(ForwardRef(Preview))";
const sizes = {
  desktop: {
    width: "100%",
    height: "100%"
  },
  mobile: {
    width: 375,
    height: 650
  }
}, spinnerVariants = {
  initial: {
    opacity: 1
  },
  animate: {
    opacity: [0, 0, 1]
  },
  exit: {
    opacity: [1, 0, 0]
  }
}, errorVariants = {
  initial: {
    opacity: 1
  },
  animate: {
    opacity: [0, 0, 1]
  },
  exit: {
    opacity: [1, 0, 0]
  }
}, iframeVariants = {
  desktop: __spreadProps$2(__spreadValues$3({}, sizes.desktop), {
    boxShadow: "0 0 0 0px var(--card-border-color)"
  }),
  mobile: __spreadProps$2(__spreadValues$3({}, sizes.mobile), {
    boxShadow: "0 0 0 1px var(--card-border-color)"
  }),
  background: {
    opacity: 0,
    scale: 1
  },
  idle: {
    scale: 1
  },
  reloading: {
    scale: [1, 1, 1, 0.98]
  },
  active: {
    opacity: [0, 0, 1],
    scale: 1
  },
  timedOut: {
    opacity: [0, 0, 1]
  }
};
function useEffectOnChange(value, _callback, initialValue, comparator) {
  const $ = reactCompilerRuntime.c(5), previousValueRef = react.useRef(initialValue), callback = useEffectEvent.useEffectEvent(_callback);
  let t0, t1;
  $[0] !== callback || $[1] !== comparator || $[2] !== value ? (t0 = () => {
    const prev = previousValueRef.current;
    if (previousValueRef.current = value, value !== prev)
      return callback(value, prev);
  }, t1 = [callback, comparator, value], $[0] = callback, $[1] = comparator, $[2] = value, $[3] = t0, $[4] = t1) : (t0 = $[3], t1 = $[4]), react.useEffect(t0, t1);
}
const RevisionSwitcher = function(props) {
  const $ = reactCompilerRuntime.c(4), {
    documentId,
    documentType,
    navigate,
    perspective,
    documentRevision
  } = props, editState = sanity.useEditState(documentId, documentType);
  let t0;
  return $[0] !== documentRevision || $[1] !== editState || $[2] !== navigate ? (t0 = (value) => {
    let rev;
    if (value === "published" && editState.published) {
      const {
        _updatedAt,
        _rev
      } = editState.published;
      rev = `${_updatedAt}/${_rev}`;
    }
    documentRevision !== rev && navigate({}, {
      rev
    }, !0);
  }, $[0] = documentRevision, $[1] = editState, $[2] = navigate, $[3] = t0) : t0 = $[3], useEffectOnChange(perspective, t0), null;
};
function defineWarnOnce() {
  let warned = !1;
  return (...args) => {
    warned || (console.warn(...args), warned = !0);
  };
}
var __defProp$2 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b))
      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  return a;
}, __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const warnOnceAboutCrossDatasetReference = defineWarnOnce();
function useDocumentsOnPage(perspective, frameStateRef) {
  if (perspective !== "published" && perspective !== "previewDrafts")
    throw new Error(`Invalid perspective: ${perspective}`);
  const [published, setPublished] = react.useState({}), [previewDrafts, setPreviewDrafts] = react.useState({}), urlRef = react.useRef(""), setDocumentsOnPage = react.useCallback((key, perspective_0, sourceDocuments = []) => {
    const documents = sourceDocuments.filter((sourceDocument) => "_projectId" in sourceDocument && sourceDocument._projectId ? (warnOnceAboutCrossDatasetReference("Cross dataset references are not supported yet, ignoring source document", sourceDocument), !1) : sourceDocument);
    (perspective_0 === "published" ? setPublished : setPreviewDrafts)((cache) => {
      const next = {};
      for (const document2 of documents)
        next[document2._id] = document2;
      if (urlRef.current !== frameStateRef.current.url)
        return urlRef.current = frameStateRef.current.url, {
          [key]: next
        };
      const prev = cache[key];
      return isEqual__default.default(prev, next) ? cache : __spreadProps$1(__spreadValues$2({}, cache), {
        [key]: next
      });
    });
  }, [frameStateRef]);
  return [react.useMemo(() => {
    const uniqueDocuments = Object.values(perspective === "published" ? published : previewDrafts).reduce((acc, cache_0) => (Object.values(cache_0).forEach((doc) => {
      acc[doc._id] = doc;
    }), acc), {});
    return Object.values(uniqueDocuments);
  }, [perspective, previewDrafts, published]), setDocumentsOnPage];
}
function fnOrObj(arg, context) {
  return arg instanceof Function ? arg(context) : arg;
}
function getQueryFromResult(resolver, context) {
  var _a;
  if (resolver.resolve) {
    const filter = (_a = resolver.resolve(context)) == null ? void 0 : _a.filter;
    return filter ? `// groq
*[${filter}][0]{_id, _type}` : void 0;
  }
  return "type" in resolver ? `// groq
*[_type == "${resolver.type}"][0]{_id, _type}` : `// groq
*[${fnOrObj(resolver.filter, context)}][0]{_id, _type}`;
}
function getParamsFromResult(resolver, context) {
  var _a, _b, _c2;
  return resolver.resolve ? (_b = (_a = resolver.resolve(context)) == null ? void 0 : _a.params) != null ? _b : context.params : "type" in resolver ? {} : (_c2 = fnOrObj(resolver.params, context)) != null ? _c2 : context.params;
}
function getRouteContext(route, url) {
  const routes = Array.isArray(route) ? route : [route];
  for (route of routes) {
    let origin, path = route;
    if (typeof route == "string")
      try {
        const absolute = new URL(route);
        origin = absolute.origin, path = absolute.pathname;
      } catch (e) {
      }
    if (!(origin && url.origin !== origin))
      try {
        const result = pathToRegexp.match(path, {
          decode: decodeURIComponent
        })(url.pathname);
        if (result) {
          const {
            params,
            path: path2
          } = result;
          return {
            origin,
            params,
            path: path2
          };
        }
      } catch (e) {
        throw new Error(`"${route}" is not a valid route pattern`);
      }
  }
}
function useMainDocument(props) {
  var _a, _b;
  const $ = reactCompilerRuntime.c(16), {
    navigate,
    navigationHistory,
    path,
    previewUrl,
    resolvers: t0
  } = props;
  let t1;
  $[0] !== t0 ? (t1 = t0 === void 0 ? [] : t0, $[0] = t0, $[1] = t1) : t1 = $[1];
  const resolvers = t1, {
    state: routerState
  } = router.useRouter();
  let t2;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    apiVersion: index.API_VERSION
  }, $[2] = t2) : t2 = $[2];
  const client = sanity.useClient(t2);
  let t3;
  $[3] !== path || $[4] !== routerState ? (t3 = path || ((_b = (_a = routerState._searchParams) == null ? void 0 : _a.find(_temp$2)) == null ? void 0 : _b[1]) || "", $[3] = path, $[4] = routerState, $[5] = t3) : t3 = $[5];
  const relativeUrl = t3, [mainDocumentState, setMainDocumentState] = react.useState(void 0), mainDocumentIdRef = react.useRef(void 0);
  let t4;
  $[6] !== navigate || $[7] !== navigationHistory ? (t4 = (doc, url) => {
    var _a2, _b2;
    (!doc || mainDocumentIdRef.current !== doc._id) && (setMainDocumentState({
      document: doc,
      path: url.pathname
    }), mainDocumentIdRef.current = doc == null ? void 0 : doc._id, ((_a2 = navigationHistory.at(-1)) == null ? void 0 : _a2.id) === ((_b2 = navigationHistory.at(-2)) == null ? void 0 : _b2.id) && (navigate == null || navigate({
      id: doc == null ? void 0 : doc._id,
      type: doc == null ? void 0 : doc._type
    })));
  }, $[6] = navigate, $[7] = navigationHistory, $[8] = t4) : t4 = $[8];
  const handleResponse = useEffectEvent.useEffectEvent(t4);
  let t5, t6;
  return $[9] !== client || $[10] !== handleResponse || $[11] !== previewUrl || $[12] !== relativeUrl || $[13] !== resolvers ? (t5 = () => {
    const base = typeof previewUrl == "string" ? previewUrl : typeof previewUrl == "object" && (previewUrl == null ? void 0 : previewUrl.origin) || location.origin, url_0 = new URL(relativeUrl, base);
    if (resolvers.length) {
      let result;
      for (const resolver of resolvers) {
        const context = getRouteContext(resolver.route, url_0);
        if (context) {
          result = {
            context,
            resolver
          };
          break;
        }
      }
      if (result) {
        const query = getQueryFromResult(result.resolver, result.context), params = getParamsFromResult(result.resolver, result.context);
        if (query) {
          const controller = new AbortController(), options = {
            perspective: "previewDrafts",
            signal: controller.signal
          };
          return client.fetch(query, params, options).then((doc_0) => handleResponse(doc_0, url_0)).catch((e) => {
            e instanceof Error && e.name === "AbortError" || (setMainDocumentState({
              document: void 0,
              path: url_0.pathname
            }), mainDocumentIdRef.current = void 0);
          }), () => {
            controller.abort();
          };
        }
      }
    }
    setMainDocumentState(void 0), mainDocumentIdRef.current = void 0;
  }, t6 = [client, handleResponse, previewUrl, relativeUrl, resolvers], $[9] = client, $[10] = handleResponse, $[11] = previewUrl, $[12] = relativeUrl, $[13] = resolvers, $[14] = t5, $[15] = t6) : (t5 = $[14], t6 = $[15]), react.useEffect(t5, t6), mainDocumentState;
}
function _temp$2(t0) {
  const [key] = t0;
  return key === "preview";
}
function parseId(rawId) {
  var _a;
  if (rawId === void 0)
    return;
  const segments = (_a = decodeURIComponent(rawId)) == null ? void 0 : _a.split(".");
  return segments[0] === "drafts" && segments.shift(), segments.join(".");
}
function parsePath(rawPath) {
  if (rawPath !== void 0)
    return csm.studioPath.toString(urlStringToPath(decodeURIComponent(rawPath)));
}
function parseRouterState(state) {
  return {
    id: parseId(state.id),
    path: parsePath(state.path),
    type: state.type
  };
}
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b))
      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  return a;
}, __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
function pruneObject(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([, value]) => value !== void 0 && value !== "" && value !== null));
}
function useParams({
  initialPreviewUrl,
  routerNavigate,
  routerState,
  routerSearchParams,
  frameStateRef
}) {
  const params = react.useMemo(() => {
    const {
      id,
      path,
      type
    } = parseRouterState(routerState);
    return {
      id,
      type,
      path,
      preview: routerSearchParams.preview || `${initialPreviewUrl.pathname}${initialPreviewUrl.search}`,
      perspective: routerSearchParams.perspective,
      viewport: routerSearchParams.viewport,
      inspect: routerSearchParams.inspect,
      rev: routerSearchParams.rev,
      since: routerSearchParams.since,
      template: routerSearchParams.template,
      templateParams: routerSearchParams.templateParams,
      view: routerSearchParams.view,
      // assist
      pathKey: routerSearchParams.pathKey,
      instruction: routerSearchParams.instruction,
      // comments
      comment: routerSearchParams.comment,
      changesInspectorTab: routerSearchParams.changesInspectorTab
    };
  }, [routerState, routerSearchParams, initialPreviewUrl]), structureParams = react.useMemo(() => pruneObject({
    inspect: params.inspect,
    path: params.path,
    rev: params.rev,
    since: params.since,
    template: params.template,
    templateParams: params.templateParams,
    view: params.view,
    // assist
    pathKey: params.pathKey,
    instruction: params.instruction,
    // comments
    comment: params.comment,
    changesInspectorTab: params.changesInspectorTab
  }), [params.changesInspectorTab, params.comment, params.inspect, params.instruction, params.path, params.pathKey, params.rev, params.since, params.template, params.templateParams, params.view]), searchParams = react.useMemo(() => pruneObject({
    perspective: params.perspective,
    preview: params.preview,
    viewport: params.viewport
  }), [params.perspective, params.preview, params.viewport]), routerStateRef = react.useRef(routerState);
  react.useEffect(() => {
    routerStateRef.current = routerState;
  }, [routerState]);
  const [navigationHistory, setNavigationHistory] = react.useState([routerState]);
  return {
    navigate: react.useCallback((nextState, nextSearchState = {}, forceReplace) => {
      nextState.id && (nextState.id = sanity.getPublishedId(nextState.id));
      const _a = routerStateRef.current, {
        _searchParams: routerSearchParams_0
      } = _a, routerState_0 = __objRest(_a, [
        "_searchParams"
      ]), routerSearchState = (routerSearchParams_0 || []).reduce((acc, [key, value]) => (acc[key] = value, acc), {}), state = pruneObject(__spreadValues$1(__spreadValues$1({}, routerState_0), nextState)), searchState = pruneObject(__spreadValues$1(__spreadValues$1({}, routerSearchState), nextSearchState));
      routerState_0.id !== state.id && (delete searchState.template, delete searchState.templateParams), state._searchParams = Object.entries(searchState).reduce((acc_0, [key_0, value_0]) => [...acc_0, [key_0, value_0]], []);
      const replace = forceReplace != null ? forceReplace : searchState.preview === frameStateRef.current.url;
      setNavigationHistory((prev) => [...prev, state]), routerNavigate(state, {
        replace
      });
    }, [routerNavigate, frameStateRef]),
    navigationHistory,
    params,
    searchParams,
    structureParams
  };
}
const usePopups = (controller) => {
  const $ = reactCompilerRuntime.c(10), [popups, setPopups] = react.useState(_temp$1);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = (url) => {
    const source = window.open(url, "_blank");
    source && setPopups((prev) => new Set(prev).add(source));
  }, $[0] = t0) : t0 = $[0];
  const open = t0;
  let t1, t2;
  $[1] !== controller || $[2] !== popups ? (t1 = () => {
    const unsubs = [];
    if (popups.size && controller)
      for (const source_0 of popups)
        source_0 && "closed" in source_0 && !source_0.closed && unsubs.push(controller.addTarget(source_0));
    return () => {
      unsubs.forEach(_temp2$1);
    };
  }, t2 = [controller, popups], $[1] = controller, $[2] = popups, $[3] = t1, $[4] = t2) : (t1 = $[3], t2 = $[4]), react.useEffect(t1, t2);
  let t3, t4;
  $[5] !== popups ? (t3 = () => {
    if (popups.size) {
      const interval = setInterval(() => {
        const closed = /* @__PURE__ */ new Set();
        for (const source_1 of popups)
          source_1 && "closed" in source_1 && source_1.closed && closed.add(source_1);
        closed.size && setPopups((prev_0) => {
          const next = new Set(prev_0);
          for (const source_2 of closed)
            next.delete(source_2);
          return next;
        });
      }, index.POPUP_CHECK_INTERVAL);
      return () => {
        clearInterval(interval);
      };
    }
  }, t4 = [popups], $[5] = popups, $[6] = t3, $[7] = t4) : (t3 = $[6], t4 = $[7]), react.useEffect(t3, t4);
  let t5;
  return $[8] !== popups ? (t5 = {
    popups,
    open
  }, $[8] = popups, $[9] = t5) : t5 = $[9], t5;
};
function _temp$1() {
  return /* @__PURE__ */ new Set();
}
function _temp2$1(unsub) {
  return unsub();
}
function usePreviewUrl(previewUrl, toolName, studioPreviewPerspective, previewSearchParam, canCreateUrlPreviewSecrets) {
  var _a, _b;
  const client = sanity.useClient({
    apiVersion: index.API_VERSION
  }), workspace = sanity.useActiveWorkspace(), basePath = ((_a = workspace == null ? void 0 : workspace.activeWorkspace) == null ? void 0 : _a.basePath) || "/", workspaceName = ((_b = workspace == null ? void 0 : workspace.activeWorkspace) == null ? void 0 : _b.name) || "default", deps = useSuspendCacheKeys(toolName, basePath, workspaceName, previewSearchParam), previewUrlSecret = usePreviewUrlSecret(canCreateUrlPreviewSecrets && typeof previewUrl == "object" || typeof previewUrl == "function", deps);
  return suspendReact.suspend(async () => {
    if (typeof previewUrl == "string") {
      const resolvedUrl2 = new URL(previewUrl, location.origin);
      let resultUrl = resolvedUrl2;
      try {
        if (previewSearchParam) {
          const restoredUrl = new URL(previewSearchParam, resolvedUrl2);
          restoredUrl.origin === resolvedUrl2.origin && (resultUrl = restoredUrl);
        }
      } catch (e) {
      }
      return location.origin === resultUrl.origin && (resultUrl.pathname.startsWith(`${basePath}/`) || resultUrl.pathname === basePath) ? resolvedUrl2 : resultUrl;
    }
    const resolvedUrl = await (typeof previewUrl == "object" ? definePreviewUrl.definePreviewUrl(previewUrl) : previewUrl)({
      client,
      previewUrlSecret,
      studioPreviewPerspective,
      previewSearchParam,
      studioBasePath: basePath
    });
    return new URL(resolvedUrl, location.origin);
  }, [...deps, previewUrlSecret]);
}
const resolveUUID = Symbol();
function useSuspendCacheKeys(toolName, basePath, workspaceName, previewSearchParam) {
  const $ = reactCompilerRuntime.c(12);
  let t0;
  $[0] !== previewSearchParam ? (t0 = () => previewSearchParam || "", $[0] = previewSearchParam, $[1] = t0) : t0 = $[1];
  const [cachedPreviewSearchParam, setCachedPreviewSearchParam] = react.useState(t0), timeoutRef = react.useRef(0);
  let t1, t2;
  $[2] !== cachedPreviewSearchParam || $[3] !== previewSearchParam ? (t1 = () => {
    if (cachedPreviewSearchParam && previewSearchParam)
      return window.clearTimeout(timeoutRef.current), () => {
        timeoutRef.current = window.setTimeout(() => {
          setCachedPreviewSearchParam("");
        }, 100);
      };
  }, t2 = [cachedPreviewSearchParam, previewSearchParam], $[2] = cachedPreviewSearchParam, $[3] = previewSearchParam, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), react.useEffect(t1, t2);
  const currentUser = sanity.useCurrentUser();
  let t3;
  const t4 = currentUser == null ? void 0 : currentUser.id;
  let t5;
  return $[6] !== basePath || $[7] !== cachedPreviewSearchParam || $[8] !== t4 || $[9] !== toolName || $[10] !== workspaceName ? (t5 = ["@sanity/presentation", basePath, workspaceName, toolName, t4, resolveUUID, cachedPreviewSearchParam], $[6] = basePath, $[7] = cachedPreviewSearchParam, $[8] = t4, $[9] = toolName, $[10] = workspaceName, $[11] = t5) : t5 = $[11], t3 = t5, t3;
}
function usePreviewUrlSecret(enabled, deps) {
  const $ = reactCompilerRuntime.c(10);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    apiVersion: index.API_VERSION
  }, $[0] = t0) : t0 = $[0];
  const client = sanity.useClient(t0), currentUser = sanity.useCurrentUser(), [secretLastExpiredAt, setSecretLastExpiredAt] = react.useState("");
  let t1;
  $[1] !== client || $[2] !== (currentUser == null ? void 0 : currentUser.id) || $[3] !== deps || $[4] !== enabled || $[5] !== secretLastExpiredAt ? (t1 = enabled ? suspendReact.suspend(async () => await createSecret.createPreviewSecret(client, "@sanity/presentation", typeof window > "u" ? "" : location.href, currentUser == null ? void 0 : currentUser.id), [...deps, secretLastExpiredAt]) : null, $[1] = client, $[2] = currentUser == null ? void 0 : currentUser.id, $[3] = deps, $[4] = enabled, $[5] = secretLastExpiredAt, $[6] = t1) : t1 = $[6];
  const previewUrlSecret = t1;
  let t2, t3;
  return $[7] !== previewUrlSecret ? (t2 = () => {
    if (!previewUrlSecret)
      return;
    const timeout = setTimeout(() => {
      react.startTransition(() => setSecretLastExpiredAt(previewUrlSecret.expiresAt.toString()));
    }, previewUrlSecret.expiresAt.getTime() - Date.now());
    return () => clearTimeout(timeout);
  }, t3 = [previewUrlSecret], $[7] = previewUrlSecret, $[8] = t2, $[9] = t3) : (t2 = $[8], t3 = $[9]), react.useEffect(t2, t3), (previewUrlSecret == null ? void 0 : previewUrlSecret.secret) || null;
}
function useStatus() {
  const $ = reactCompilerRuntime.c(4);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ new Map(), $[0] = t0) : t0 = $[0];
  const [statusMap, setStatusMap] = react.useState(t0);
  let t1;
  bb0: {
    const values = Array.from(statusMap.values());
    if (values.find(_temp)) {
      t1 = "connected";
      break bb0;
    }
    const handshaking = values.filter(_temp2);
    if (handshaking.length) {
      t1 = handshaking.some(_temp3) ? "connecting" : "reconnecting";
      break bb0;
    }
    t1 = "idle";
  }
  const status_1 = t1;
  let t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t2 = (event) => {
    setStatusMap((prev) => {
      var _a;
      const next = new Map(prev);
      if (event.status === "disconnected")
        next.delete(event.connection);
      else {
        const hasConnected_0 = ((_a = next.get(event.connection)) == null ? void 0 : _a.hasConnected) || event.status === "connected", status_2 = event.status === "handshaking" ? "connecting" : event.status;
        next.set(event.connection, {
          status: status_2,
          hasConnected: hasConnected_0
        });
      }
      return next;
    });
  }, $[1] = t2) : t2 = $[1];
  const setStatusFromEvent = t2;
  let t3;
  return $[2] !== status_1 ? (t3 = [status_1, setStatusFromEvent], $[2] = status_1, $[3] = t3) : t3 = $[3], t3;
}
function _temp3(t0) {
  const {
    hasConnected
  } = t0;
  return !hasConnected;
}
function _temp2(t0) {
  const {
    status: status_0
  } = t0;
  return status_0 === "connecting";
}
function _temp(t0) {
  const {
    status
  } = t0;
  return status === "connected";
}
const LoaderQueries = react.lazy(() => Promise.resolve().then(function() {
  return require("./LoaderQueries.cjs");
}));
react.lazy(() => Promise.resolve().then(function() {
  return require("./LiveQueries.cjs");
}));
const PostMessageDocuments = react.lazy(() => Promise.resolve().then(function() {
  return require("./PostMessageDocuments.cjs");
})), PostMessageFeatures = react.lazy(() => Promise.resolve().then(function() {
  return require("./PostMessageFeatures.cjs");
})), PostMessageRefreshMutations = react.lazy(() => Promise.resolve().then(function() {
  return require("./PostMessageRefreshMutations.cjs");
})), PostMessagePerspective = react.lazy(() => Promise.resolve().then(function() {
  return require("./PostMessagePerspective.cjs");
})), PostMessagePreviewSnapshots = react.lazy(() => Promise.resolve().then(function() {
  return require("./PostMessagePreviewSnapshots.cjs");
})), PostMessageSchema = react.lazy(() => Promise.resolve().then(function() {
  return require("./PostMessageSchema.cjs");
})), PostMessageTelemetry = react.lazy(() => Promise.resolve().then(function() {
  return require("./PostMessageTelemetry.cjs");
})), Container = styledComponents.styled(ui.Flex)`
  overflow-x: auto;
`;
function PresentationTool(props) {
  var _a, _b, _c, _d, _e;
  const {
    canCreateUrlPreviewSecrets,
    canToggleSharePreviewAccess,
    canUseSharedPreviewAccess,
    tool
  } = props, components = (_a = tool.options) == null ? void 0 : _a.components, _previewUrl = (_b = tool.options) == null ? void 0 : _b.previewUrl, name = tool.name || index.DEFAULT_TOOL_NAME, {
    unstable_navigator,
    unstable_header
  } = components || {}, {
    navigate: routerNavigate,
    state: routerState
  } = router.useRouter(), routerSearchParams = sanity.useUnique(Object.fromEntries(routerState._searchParams || [])), initialPreviewUrl = usePreviewUrl(_previewUrl || "/", name, routerSearchParams.perspective === "published" ? "published" : "previewDrafts", routerSearchParams.preview || null, canCreateUrlPreviewSecrets), canSharePreviewAccess = react.useMemo(() => _previewUrl && typeof _previewUrl == "object" && "draftMode" in _previewUrl && _previewUrl.draftMode ? (console.warn("previewUrl.draftMode is deprecated, use previewUrl.previewMode instead"), _previewUrl.draftMode.shareAccess !== !1) : _previewUrl && typeof _previewUrl == "object" && "previewMode" in _previewUrl && _previewUrl.previewMode ? _previewUrl.previewMode.shareAccess !== !1 : !1, [_previewUrl]), [devMode] = react.useState(() => {
    var _a2;
    const option = (_a2 = tool.options) == null ? void 0 : _a2.devMode;
    return typeof option == "function" ? option() : typeof option == "boolean" ? option : typeof window < "u" && window.location.hostname === "localhost";
  }), targetOrigin = react.useMemo(() => initialPreviewUrl.origin, [initialPreviewUrl.origin]), iframeRef = react.useRef(null), [controller, setController] = react.useState(), [visualEditingComlink, setVisualEditingComlink] = react.useState(null), frameStateRef = react.useRef({
    title: void 0,
    url: void 0
  }), {
    navigate: _navigate,
    navigationHistory,
    params,
    searchParams,
    structureParams
  } = useParams({
    initialPreviewUrl,
    routerNavigate,
    routerState,
    routerSearchParams,
    frameStateRef
  }), navigate = react.useMemo(() => debounce(_navigate, 50), [_navigate]), [state, dispatch] = react.useReducer(index.presentationReducer, {}, index.presentationReducerInit), perspective = react.useMemo(() => params.perspective ? "published" : "previewDrafts", [params.perspective]), viewport = react.useMemo(() => params.viewport ? "mobile" : "desktop", [params.viewport]), [documentsOnPage, setDocumentsOnPage] = useDocumentsOnPage(perspective, frameStateRef), projectId = sanity.useProjectId(), dataset = sanity.useDataset(), mainDocumentState = useMainDocument({
    // Prevent flash of content by using immediate navigation
    navigate: _navigate,
    navigationHistory,
    path: params.preview,
    previewUrl: (_c = tool.options) == null ? void 0 : _c.previewUrl,
    resolvers: (_e = (_d = tool.options) == null ? void 0 : _d.resolve) == null ? void 0 : _e.mainDocuments
  }), [overlaysConnection, setOverlaysConnection] = useStatus(), [loadersConnection, setLoadersConnection] = useStatus(), [previewKitConnection, setPreviewKitConnection] = useStatus(), {
    open: handleOpenPopup
  } = usePopups(controller), isLoading = state.iframe.status === "loading";
  react.useEffect(() => {
    var _a2;
    const target = (_a2 = iframeRef.current) == null ? void 0 : _a2.contentWindow;
    if (!target || isLoading) return;
    const controller_0 = comlink.createController({
      targetOrigin
    });
    return controller_0.addTarget(target), setController(controller_0), () => {
      controller_0.destroy(), setController(void 0);
    };
  }, [targetOrigin, isLoading]);
  const handleNavigate = useEffectEvent.useEffectEvent((nextState, nextSearchState, forceReplace) => navigate(nextState, nextSearchState, forceReplace));
  react.useEffect(() => {
    if (!controller) return;
    const comlink$1 = controller.createChannel({
      name: "presentation",
      heartbeat: !0,
      connectTo: "visual-editing"
    }, comlink.createConnectionMachine().provide({
      actors: createCompatibilityActors()
    }));
    comlink$1.on("visual-editing/focus", (data) => {
      "id" in data && handleNavigate({
        type: data.type,
        id: data.id,
        path: data.path
      });
    }), comlink$1.on("visual-editing/navigate", (data_0) => {
      const {
        title,
        url
      } = data_0;
      frameStateRef.current.url !== url && handleNavigate({}, {
        preview: url
      }), frameStateRef.current = {
        title,
        url
      };
    }), comlink$1.on("visual-editing/meta", (data_1) => {
      frameStateRef.current.title = data_1.title;
    }), comlink$1.on("visual-editing/toggle", (data_2) => {
      dispatch({
        type: index.ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE,
        enabled: data_2.enabled
      });
    }), comlink$1.on("visual-editing/documents", (data_3) => {
      setDocumentsOnPage(
        "visual-editing",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data_3.perspective,
        data_3.documents
      );
    }), comlink$1.on("visual-editing/refreshing", (data_4) => {
      data_4.source === "manual" ? clearTimeout(refreshRef.current) : data_4.source === "mutation" && dispatch({
        type: index.ACTION_IFRAME_REFRESH
      });
    }), comlink$1.on("visual-editing/refreshed", () => {
      dispatch({
        type: index.ACTION_IFRAME_LOADED
      });
    }), comlink$1.onStatus(setOverlaysConnection);
    const stop = comlink$1.start();
    return setVisualEditingComlink(comlink$1), () => {
      stop(), setVisualEditingComlink(null);
    };
  }, [controller, handleNavigate, setDocumentsOnPage, setOverlaysConnection, targetOrigin]), react.useEffect(() => {
    if (!controller) return;
    const comlink_0 = controller.createChannel({
      name: "presentation",
      connectTo: "preview-kit",
      heartbeat: !0
    }, comlink.createConnectionMachine().provide({
      actors: createCompatibilityActors()
    }));
    return comlink_0.onStatus(setPreviewKitConnection), comlink_0.on("preview-kit/documents", (data_5) => {
      data_5.projectId === projectId && data_5.dataset === dataset && setDocumentsOnPage(
        "preview-kit",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data_5.perspective,
        data_5.documents
      );
    }), comlink_0.start();
  }, [controller, dataset, projectId, setDocumentsOnPage, setPreviewKitConnection, targetOrigin]);
  const handleFocusPath = react.useCallback((nextPath) => {
    navigate({
      path: csm.studioPath.toString(nextPath)
    }, {}, !0);
  }, [navigate]), handlePreviewPath = react.useCallback((nextPath_0) => {
    const url_0 = new URL(nextPath_0, initialPreviewUrl.origin), preview = url_0.pathname + url_0.search;
    url_0.origin === initialPreviewUrl.origin && preview !== params.preview && navigate({}, {
      preview
    });
  }, [initialPreviewUrl, params, navigate]), handleStructureParams = react.useCallback((structureParams_0) => {
    navigate({}, structureParams_0);
  }, [navigate]);
  react.useEffect(() => {
    params.id && params.path ? visualEditingComlink == null || visualEditingComlink.post("presentation/focus", {
      id: params.id,
      path: params.path
    }) : visualEditingComlink == null || visualEditingComlink.post("presentation/blur");
  }, [params.id, params.path, visualEditingComlink]), react.useEffect(() => {
    frameStateRef.current.url && params.preview && frameStateRef.current.url !== params.preview && (frameStateRef.current.url = params.preview, overlaysConnection !== "connected" && iframeRef.current ? iframeRef.current.src = `${targetOrigin}${params.preview}` : visualEditingComlink == null || visualEditingComlink.post("presentation/navigate", {
      url: params.preview,
      type: "replace"
    }));
  }, [overlaysConnection, targetOrigin, params.preview, visualEditingComlink]);
  const toggleOverlay = react.useCallback(() => visualEditingComlink == null ? void 0 : visualEditingComlink.post("presentation/toggle-overlay"), [visualEditingComlink]), [displayedDocument, setDisplayedDocument] = react.useState(null);
  react.useEffect(() => {
    const handleKeyUp = (e) => {
      isAltKey(e) && toggleOverlay();
    }, handleKeydown = (e_0) => {
      isAltKey(e_0) && toggleOverlay(), isHotkey(["mod", "\\"], e_0) && toggleOverlay();
    };
    return window.addEventListener("keydown", handleKeydown), window.addEventListener("keyup", handleKeyUp), () => {
      window.removeEventListener("keydown", handleKeydown), window.removeEventListener("keyup", handleKeyUp);
    };
  }, [toggleOverlay]);
  const [boundaryElement, setBoundaryElement] = react.useState(null), [{
    navigatorEnabled,
    toggleNavigator
  }, PresentationNavigator] = usePresentationNavigator({
    unstable_navigator
  }), idRef = react.useRef(params.id);
  react.useEffect(() => {
    params.rev && idRef.current && params.id !== idRef.current && navigate({}, {
      rev: void 0
    }), idRef.current = params.id;
  });
  const refreshRef = react.useRef(), handleRefresh = react.useCallback((fallback) => {
    if (dispatch({
      type: index.ACTION_IFRAME_REFRESH
    }), visualEditingComlink) {
      refreshRef.current = window.setTimeout(fallback, 300), visualEditingComlink.post("presentation/refresh", {
        source: "manual",
        livePreviewEnabled: previewKitConnection === "connected" || loadersConnection === "connected"
      });
      return;
    }
    fallback();
  }, [loadersConnection, previewKitConnection, visualEditingComlink]), workspace = sanity.useWorkspace(), getCommentIntent = react.useCallback(({
    id,
    type,
    path
  }) => {
    if (frameStateRef.current.url)
      return {
        title: frameStateRef.current.title || frameStateRef.current.url,
        name: "edit",
        params: {
          id,
          path,
          type,
          inspect: index.COMMENTS_INSPECTOR_NAME,
          workspace: workspace.name,
          mode: index.EDIT_INTENT_MODE,
          preview: params.preview
        }
      };
  }, [params.preview, workspace.name]), setViewport = react.useCallback((next) => {
    navigate({}, {
      viewport: next === "desktop" ? void 0 : "mobile"
    }, !0);
  }, [navigate]), setPerspective = react.useCallback((next_0) => {
    navigate({}, {
      perspective: next_0 === "previewDrafts" ? void 0 : next_0
    });
  }, [navigate]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(PresentationProvider, { devMode, name, navigate, params, searchParams, structureParams, children: /* @__PURE__ */ jsxRuntime.jsx(PresentationNavigateProvider, { navigate, children: /* @__PURE__ */ jsxRuntime.jsx(PresentationParamsProvider, { params, children: /* @__PURE__ */ jsxRuntime.jsx(SharedStateProvider, { comlink: visualEditingComlink, children: /* @__PURE__ */ jsxRuntime.jsx(Container, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsxs(Panels, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(PresentationNavigator, {}),
      /* @__PURE__ */ jsxRuntime.jsx(Panel, { id: "preview", minWidth: 325, defaultSize: navigatorEnabled ? 50 : 75, order: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", flex: 1, height: "fill", ref: setBoundaryElement, children: /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: boundaryElement, children: /* @__PURE__ */ jsxRuntime.jsx(Preview, { canSharePreviewAccess, canToggleSharePreviewAccess, canUseSharedPreviewAccess, dispatch, header: unstable_header, iframe: state.iframe, initialUrl: initialPreviewUrl, loadersConnection, navigatorEnabled, onPathChange: handlePreviewPath, onRefresh: handleRefresh, openPopup: handleOpenPopup, overlaysConnection, previewUrl: params.preview, perspective, ref: iframeRef, setPerspective, setViewport, targetOrigin, toggleNavigator, toggleOverlay, viewport, visualEditing: state.visualEditing }) }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(PresentationContent, { documentId: params.id, documentsOnPage, documentType: params.type, getCommentIntent, mainDocumentState, onFocusPath: handleFocusPath, onStructureParams: handleStructureParams, searchParams, setDisplayedDocument, structureParams })
    ] }) }) }) }) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(react.Suspense, { children: [
      controller && /* @__PURE__ */ jsxRuntime.jsx(LoaderQueries, { controller, perspective, liveDocument: displayedDocument, onDocumentsOnPage: setDocumentsOnPage, onLoadersConnection: setLoadersConnection, documentsOnPage }),
      visualEditingComlink && params.id && params.type && /* @__PURE__ */ jsxRuntime.jsx(PostMessageRefreshMutations, { comlink: visualEditingComlink, id: params.id, type: params.type, loadersConnection, previewKitConnection }),
      visualEditingComlink && /* @__PURE__ */ jsxRuntime.jsx(PostMessageSchema, { comlink: visualEditingComlink, perspective }),
      visualEditingComlink && documentsOnPage.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(PostMessagePreviewSnapshots, { comlink: visualEditingComlink, perspective, refs: documentsOnPage }),
      visualEditingComlink && /* @__PURE__ */ jsxRuntime.jsx(PostMessageDocuments, { comlink: visualEditingComlink }),
      visualEditingComlink && /* @__PURE__ */ jsxRuntime.jsx(PostMessageFeatures, { comlink: visualEditingComlink }),
      visualEditingComlink && /* @__PURE__ */ jsxRuntime.jsx(PostMessagePerspective, { comlink: visualEditingComlink, perspective }),
      visualEditingComlink && /* @__PURE__ */ jsxRuntime.jsx(PostMessageTelemetry, { comlink: visualEditingComlink }),
      params.id && params.type && /* @__PURE__ */ jsxRuntime.jsx(RevisionSwitcher, { documentId: params.id, documentRevision: params.rev, documentType: params.type, navigate, perspective })
    ] })
  ] });
}
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function PresentationToolGrantsCheck(props) {
  var _a;
  const $ = reactCompilerRuntime.c(16), {
    t
  } = sanity.useTranslation(index.presentationLocaleNamespace), {
    previewUrl
  } = (_a = props.tool.options) != null ? _a : {}, {
    push: pushToast
  } = ui.useToast(), willGeneratePreviewUrlSecret = typeof previewUrl == "object" || typeof previewUrl == "function", grantsStore = sanity.useGrantsStore(), [previewAccessSharingCreatePermission, setCreateAccessSharingPermission] = react.useState(null), [previewAccessSharingUpdatePermission, setUpdateAccessSharingPermission] = react.useState(null), [previewAccessSharingReadPermission, setReadAccessSharingPermission] = react.useState(null), [previewUrlSecretPermission, setPreviewUrlSecretPermission] = react.useState(null);
  let t0, t1;
  $[0] !== grantsStore || $[1] !== willGeneratePreviewUrlSecret ? (t0 = () => {
    if (!willGeneratePreviewUrlSecret)
      return;
    const previewCreateAccessSharingPermissionSubscription = grantsStore.checkDocumentPermission("create", {
      _id: constants.schemaIdSingleton,
      _type: constants.schemaTypeSingleton
    }).subscribe(setCreateAccessSharingPermission), previewUpdateAccessSharingPermissionSubscription = grantsStore.checkDocumentPermission("update", {
      _id: constants.schemaIdSingleton,
      _type: constants.schemaTypeSingleton
    }).subscribe(setUpdateAccessSharingPermission), previewReadAccessSharingPermissionSubscription = grantsStore.checkDocumentPermission("read", {
      _id: constants.schemaIdSingleton,
      _type: constants.schemaTypeSingleton
    }).subscribe(setReadAccessSharingPermission), previewUrlSecretPermissionSubscription = grantsStore.checkDocumentPermission("create", {
      _id: `drafts.${uuid.uuid()}`,
      _type: constants.schemaType
    }).subscribe(setPreviewUrlSecretPermission);
    return () => {
      previewCreateAccessSharingPermissionSubscription.unsubscribe(), previewUpdateAccessSharingPermissionSubscription.unsubscribe(), previewReadAccessSharingPermissionSubscription.unsubscribe(), previewUrlSecretPermissionSubscription.unsubscribe();
    };
  }, t1 = [grantsStore, willGeneratePreviewUrlSecret], $[0] = grantsStore, $[1] = willGeneratePreviewUrlSecret, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), react.useEffect(t0, t1);
  const canCreateUrlPreviewSecrets = previewUrlSecretPermission == null ? void 0 : previewUrlSecretPermission.granted;
  let t2, t3;
  if ($[4] !== canCreateUrlPreviewSecrets || $[5] !== pushToast || $[6] !== t || $[7] !== willGeneratePreviewUrlSecret ? (t2 = () => {
    if (!willGeneratePreviewUrlSecret || canCreateUrlPreviewSecrets !== !1)
      return;
    const raf = requestAnimationFrame(() => pushToast({
      closable: !0,
      status: "error",
      duration: 3e4,
      title: t("preview-url-secret.missing-grants")
    }));
    return () => cancelAnimationFrame(raf);
  }, t3 = [canCreateUrlPreviewSecrets, pushToast, t, willGeneratePreviewUrlSecret], $[4] = canCreateUrlPreviewSecrets, $[5] = pushToast, $[6] = t, $[7] = willGeneratePreviewUrlSecret, $[8] = t2, $[9] = t3) : (t2 = $[8], t3 = $[9]), react.useEffect(t2, t3), willGeneratePreviewUrlSecret && (!previewAccessSharingCreatePermission || typeof previewAccessSharingCreatePermission.granted > "u" || !previewAccessSharingUpdatePermission || typeof previewAccessSharingUpdatePermission.granted > "u" || !previewUrlSecretPermission || !previewAccessSharingReadPermission || typeof previewAccessSharingReadPermission.granted > "u" || typeof previewUrlSecretPermission.granted > "u")) {
    let t42;
    return $[10] === Symbol.for("react.memo_cache_sentinel") ? (t42 = /* @__PURE__ */ jsxRuntime.jsx(index.PresentationSpinner, {}), $[10] = t42) : t42 = $[10], t42;
  }
  const t4 = canCreateUrlPreviewSecrets === !0, t5 = (previewAccessSharingCreatePermission == null ? void 0 : previewAccessSharingCreatePermission.granted) === !0 && (previewAccessSharingUpdatePermission == null ? void 0 : previewAccessSharingUpdatePermission.granted) === !0, t6 = (previewAccessSharingReadPermission == null ? void 0 : previewAccessSharingReadPermission.granted) === !0;
  let t7;
  return $[11] !== props || $[12] !== t4 || $[13] !== t5 || $[14] !== t6 ? (t7 = /* @__PURE__ */ jsxRuntime.jsx(PresentationTool, __spreadProps(__spreadValues({}, props), { canCreateUrlPreviewSecrets: t4, canToggleSharePreviewAccess: t5, canUseSharedPreviewAccess: t6 })), $[11] = props, $[12] = t4, $[13] = t5, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}
var PresentationToolGrantsCheck$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: PresentationToolGrantsCheck
});
exports.PresentationToolGrantsCheck = PresentationToolGrantsCheck$1;
exports.createCompatibilityActors = createCompatibilityActors;
exports.getQueryCacheKey = getQueryCacheKey;
//# sourceMappingURL=PresentationToolGrantsCheck.cjs.map
