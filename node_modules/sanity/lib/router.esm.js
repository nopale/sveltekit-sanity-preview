import { jsx } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { useContext, forwardRef, useRef, useEffect } from "react";
import { RouterContext } from "sanity/_singletons";
import { RouterContext as RouterContext2 } from "sanity/_singletons";
import difference from "lodash/difference.js";
import intersection from "lodash/intersection.js";
import isPlainObject from "lodash/isPlainObject.js";
import pick from "lodash/pick.js";
import debug$1 from "debug";
import identity from "lodash/identity.js";
function useRouter() {
  const router = useContext(RouterContext);
  if (!router)
    throw new Error("Router: missing context value");
  return router;
}
function isLeftClickEvent(event) {
  return event.button === 0;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function useLink(options) {
  const $ = c(8), {
    onClick: onClickProp,
    href,
    target,
    replace: t0
  } = options, replace = t0 === void 0 ? !1 : t0, {
    navigateUrl
  } = useRouter();
  let t1;
  $[0] !== href || $[1] !== navigateUrl || $[2] !== onClickProp || $[3] !== replace || $[4] !== target ? (t1 = (event) => {
    event.isDefaultPrevented() || href && (onClickProp && onClickProp(event), !(isModifiedEvent(event) || !isLeftClickEvent(event)) && (target || (event.preventDefault(), navigateUrl({
      path: href,
      replace
    }))));
  }, $[0] = href, $[1] = navigateUrl, $[2] = onClickProp, $[3] = replace, $[4] = target, $[5] = t1) : t1 = $[5];
  const onClick = t1;
  let t2;
  return $[6] !== onClick ? (t2 = {
    onClick
  }, $[6] = onClick, $[7] = t2) : t2 = $[7], t2;
}
function useIntentLink(options) {
  const $ = c(13), {
    intent,
    onClick: onClickProp,
    params,
    replace,
    target,
    searchParams
  } = options, {
    resolveIntentLink
  } = useRouter();
  let t0, t1;
  $[0] !== intent || $[1] !== params || $[2] !== resolveIntentLink || $[3] !== searchParams ? (t1 = resolveIntentLink(intent, params, searchParams), $[0] = intent, $[1] = params, $[2] = resolveIntentLink, $[3] = searchParams, $[4] = t1) : t1 = $[4], t0 = t1;
  const href = t0;
  let t2;
  $[5] !== href || $[6] !== onClickProp || $[7] !== replace || $[8] !== target ? (t2 = {
    href,
    onClick: onClickProp,
    replace,
    target
  }, $[5] = href, $[6] = onClickProp, $[7] = replace, $[8] = target, $[9] = t2) : t2 = $[9];
  const {
    onClick
  } = useLink(t2);
  let t3;
  return $[10] !== href || $[11] !== onClick ? (t3 = {
    onClick,
    href
  }, $[10] = href, $[11] = onClick, $[12] = t3) : t3 = $[12], t3;
}
var __defProp$6 = Object.defineProperty, __defProps$5 = Object.defineProperties, __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$7 = Object.getOwnPropertySymbols, __hasOwnProp$7 = Object.prototype.hasOwnProperty, __propIsEnum$7 = Object.prototype.propertyIsEnumerable, __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$7.call(b, prop) && __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b))
      __propIsEnum$7.call(b, prop) && __defNormalProp$6(a, prop, b[prop]);
  return a;
}, __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b)), __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
const IntentLink = forwardRef(function(props, ref) {
  var _a;
  const $ = c(18);
  let intent, params, restProps, searchParams, target;
  $[0] !== props ? (_a = props, {
    intent,
    params,
    target,
    searchParams
  } = _a, restProps = __objRest$4(_a, [
    "intent",
    "params",
    "target",
    "searchParams"
  ]), $[0] = props, $[1] = intent, $[2] = params, $[3] = restProps, $[4] = searchParams, $[5] = target) : (intent = $[1], params = $[2], restProps = $[3], searchParams = $[4], target = $[5]);
  let t0;
  $[6] !== intent || $[7] !== params || $[8] !== props.onClick || $[9] !== searchParams || $[10] !== target ? (t0 = {
    intent,
    params,
    target,
    onClick: props.onClick,
    searchParams
  }, $[6] = intent, $[7] = params, $[8] = props.onClick, $[9] = searchParams, $[10] = target, $[11] = t0) : t0 = $[11];
  const {
    onClick,
    href
  } = useIntentLink(t0);
  let t1;
  return $[12] !== href || $[13] !== onClick || $[14] !== ref || $[15] !== restProps || $[16] !== target ? (t1 = /* @__PURE__ */ jsx("a", __spreadProps$5(__spreadValues$6({}, restProps), { href, onClick, ref, target })), $[12] = href, $[13] = onClick, $[14] = ref, $[15] = restProps, $[16] = target, $[17] = t1) : t1 = $[17], t1;
});
var __defProp$5 = Object.defineProperty, __defProps$4 = Object.defineProperties, __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$6 = Object.getOwnPropertySymbols, __hasOwnProp$6 = Object.prototype.hasOwnProperty, __propIsEnum$6 = Object.prototype.propertyIsEnumerable, __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$6.call(b, prop) && __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b))
      __propIsEnum$6.call(b, prop) && __defNormalProp$5(a, prop, b[prop]);
  return a;
}, __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b)), __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
const Link = forwardRef(function(props, ref) {
  var _a;
  const $ = c(17);
  let href, onClickProp, replace, restProps, target;
  $[0] !== props ? (_a = props, {
    onClick: onClickProp,
    href,
    target,
    replace
  } = _a, restProps = __objRest$3(_a, [
    "onClick",
    "href",
    "target",
    "replace"
  ]), $[0] = props, $[1] = href, $[2] = onClickProp, $[3] = replace, $[4] = restProps, $[5] = target) : (href = $[1], onClickProp = $[2], replace = $[3], restProps = $[4], target = $[5]);
  let t0;
  $[6] !== href || $[7] !== onClickProp || $[8] !== replace || $[9] !== target ? (t0 = {
    onClick: onClickProp,
    href,
    target,
    replace
  }, $[6] = href, $[7] = onClickProp, $[8] = replace, $[9] = target, $[10] = t0) : t0 = $[10];
  const {
    onClick
  } = useLink(t0);
  let t1;
  return $[11] !== href || $[12] !== onClick || $[13] !== ref || $[14] !== restProps || $[15] !== target ? (t1 = /* @__PURE__ */ jsx("a", __spreadProps$4(__spreadValues$5({}, restProps), { onClick, href, target, ref })), $[11] = href, $[12] = onClick, $[13] = ref, $[14] = restProps, $[15] = target, $[16] = t1) : t1 = $[16], t1;
}), VALID_PARAM_SEGMENT = /^[a-zA-Z0-9_-]+$/;
function createSegment(segment) {
  if (!segment)
    return null;
  if (segment.startsWith(":")) {
    const paramName = segment.slice(1);
    if (!VALID_PARAM_SEGMENT.test(paramName)) {
      const addendum = segment.includes("*") ? " Splats are not supported. Consider using child routes instead" : "";
      console.error(new Error(`Warning: Param segments "${segment}" includes invalid characters.${addendum}`));
    }
    return {
      type: "param",
      name: paramName
    };
  }
  return {
    type: "dir",
    name: segment
  };
}
function _parseRoute(route2) {
  const [pathname] = route2.split("?"), segments = pathname.split("/").map(createSegment).filter(Boolean);
  return {
    raw: route2,
    segments
  };
}
function arrayify(val) {
  return Array.isArray(val) ? val : val ? [val] : [];
}
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols, __hasOwnProp$5 = Object.prototype.hasOwnProperty, __propIsEnum$5 = Object.prototype.propertyIsEnumerable, __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
function isRecord(value) {
  return isPlainObject(value);
}
function createMatchError(node, missingKeys, unmappableStateKeys) {
  return {
    type: "error",
    node,
    missingKeys,
    unmappableStateKeys
  };
}
function createMatchOk(node, matchedState, searchParams, child) {
  return {
    type: "ok",
    node,
    matchedState,
    searchParams,
    child
  };
}
function _findMatchingRoutes(node, _state) {
  if (!_state)
    return createMatchOk(node, {}, []);
  const _a = (node.scope ? _state[node.scope] : _state) || {}, {
    _searchParams: searchParams = []
  } = _a, state = __objRest$2(_a, [
    "_searchParams"
  ]), requiredParams = node.route.segments.filter((seg) => seg.type === "param").map((seg) => seg.name), stateKeys = isRecord(state) ? Object.keys(state) : [], consumedParams = intersection(stateKeys, requiredParams), missingParams = difference(requiredParams, consumedParams), remainingParams = difference(stateKeys, consumedParams);
  if (missingParams.length > 0)
    return createMatchError(node, missingParams, []);
  const scopedParams = searchParams.map(([key, value]) => [[key], value]), consumedState = pick(state, consumedParams);
  if (remainingParams.length === 0)
    return createMatchOk(node, consumedState, scopedParams);
  const children = arrayify((typeof node.children == "function" ? node.children(isRecord(state) ? state : {}) : node.children) || []);
  if (remainingParams.length > 0 && children.length === 0)
    return createMatchError(node, [], remainingParams);
  const remainingState = pick(state, remainingParams), found = children.map((childNode) => _findMatchingRoutes(childNode, remainingState)).find((res) => res.type === "ok");
  return found ? createMatchOk(node, consumedState, scopedParams, found) : createMatchError(node, [], remainingParams);
}
function encodeURIComponentExcept(uriComponent, unescaped) {
  const chars = [...String(uriComponent)];
  let res = "";
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    unescaped.includes(char) ? res += char : res += encodeURIComponent(char);
  }
  return res;
}
const debug = debug$1("state-router");
function _resolvePathFromState(node, _state) {
  debug("Resolving path from state %o", _state);
  const match = _findMatchingRoutes(node, _state);
  if (match.type === "error") {
    const unmappable = match.unmappableStateKeys;
    if (unmappable.length > 0)
      throw new Error(`Unable to find matching route for state. Could not map the following state key${unmappable.length == 1 ? "" : "s"} to a valid url: ${unmappable.map(quote).join(", ")}`);
    const missingKeys = match.missingKeys;
    throw new Error(`Unable to find matching route for state. State object is missing the following key${missingKeys.length == 1 ? "" : "s"} defined in route: ${missingKeys.map(quote).join(", ")}`);
  }
  const {
    path,
    searchParams
  } = pathFromMatchResult(match), search = searchParams.length > 0 ? encodeParams$1(searchParams) : "";
  return `/${path.join("/")}${search ? `?${search}` : ""}`;
}
function bracketify(value) {
  return `[${value}]`;
}
function encodeParams$1(params) {
  return params.flatMap(([key, value]) => value === void 0 ? [] : [encodeSearchParamKey(serializeScopedPath(key)), encodeSearchParamValue(value)].join("=")).join("&");
}
function serializeScopedPath(scopedPath) {
  const [head, ...tail] = scopedPath;
  return tail.length > 0 ? [head, ...tail.map(bracketify)].join("") : head;
}
function encodeSearchParamValue(value) {
  return encodeURIComponentExcept(value, "/");
}
function encodeSearchParamKey(value) {
  return encodeURIComponentExcept(value, "[]");
}
function pathFromMatchResult(match) {
  const matchedState = match.matchedState, base = match.node.route.segments.map((segment) => {
    if (segment.type === "dir")
      return segment.name;
    const transform = match.node.transform && match.node.transform[segment.name];
    return transform ? transform.toPath(matchedState[segment.name]) : matchedState[segment.name];
  }), childMatch = match.child ? pathFromMatchResult(match.child) : void 0, searchParams = childMatch != null && childMatch.searchParams ? [...match.searchParams, ...childMatch.searchParams] : match.searchParams;
  return {
    searchParams: addNodeScope(match.node, searchParams),
    path: [...base || [], ...(childMatch == null ? void 0 : childMatch.path) || []]
  };
}
function addNodeScope(node, searchParams) {
  const scope = node.scope;
  return scope && !node.__unsafe_disableScopedSearchParams ? searchParams.map(([namespaces, value]) => [[scope, ...namespaces], value]) : searchParams;
}
function quote(value) {
  return `"${value}"`;
}
function parseScopedParams(params) {
  return params.map(([key, value]) => [parse(key), value]);
}
const OPEN = 1, CLOSED = 0;
function parse(str) {
  const result = [];
  let i = 0, state = CLOSED;
  for (; i < str.length; ) {
    const nextBracketIdx = str.indexOf("[", i);
    if (nextBracketIdx === -1) {
      result.push(str.slice(i, str.length));
      break;
    }
    if (state === OPEN)
      throw new Error("Nested brackets not supported");
    state = OPEN, nextBracketIdx > i && (result.push(str.slice(i, nextBracketIdx)), i = nextBracketIdx);
    const nextClosing = str.indexOf("]", nextBracketIdx);
    if (nextClosing === -1) {
      if (state === OPEN)
        throw new Error("Unclosed bracket");
      break;
    }
    state = CLOSED, result.push(str.slice(i + 1, nextClosing)), i = nextClosing + 1;
  }
  return result;
}
var __defProp$4 = Object.defineProperty, __getOwnPropSymbols$4 = Object.getOwnPropertySymbols, __hasOwnProp$4 = Object.prototype.hasOwnProperty, __propIsEnum$4 = Object.prototype.propertyIsEnumerable, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$4.call(b, prop) && __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b))
      __propIsEnum$4.call(b, prop) && __defNormalProp$4(a, prop, b[prop]);
  return a;
};
function matchPath(node, path, searchParams) {
  const parts = path.split("/").filter(Boolean), segmentsLength = node.route.segments.length;
  if (parts.length < segmentsLength)
    return null;
  const state = {};
  if (!node.route.segments.every((segment, i) => {
    if (segment.type === "dir")
      return segment.name === parts[i];
    const transform = node.transform && node.transform[segment.name];
    return state[segment.name] = transform ? transform.toState(parts[i]) : parts[i], !0;
  }))
    return null;
  const rest = parts.slice(segmentsLength);
  let childState = null;
  const children = typeof node.children == "function" ? arrayify(node.children(state)) : node.children, unscopedParams = removeScope(node.scope, searchParams);
  if (children.some((childNode) => {
    if (childNode) {
      const childParams = childNode.scope ? unscopedParams.filter(([namespaces]) => childNode.scope === namespaces[0]) : unscopedParams;
      return childState = matchPath(childNode, rest.join("/"), childParams), childState;
    }
  }), rest.length > 0 && !childState)
    return null;
  const selfParams = unscopedParams.flatMap(([namespace, value]) => namespace.length === 1 ? [[namespace[0], value]] : []), mergedState = __spreadValues$4(__spreadValues$4(__spreadValues$4({}, state), childState || {}), selfParams.length > 0 ? {
    _searchParams: selfParams
  } : {});
  return node.scope ? {
    [node.scope]: mergedState
  } : mergedState;
}
function _resolveStateFromPath(node, path) {
  debug("resolving state from path %s", path);
  const [pathname, search] = path.split("?"), urlSearchParams = Array.from(new URLSearchParams(search).entries()), pathMatch = matchPath(node, pathname, parseScopedParams(urlSearchParams));
  return debug("resolved: %o", pathMatch || null), pathMatch || null;
}
function removeScope(scope, searchParams) {
  return scope ? searchParams.map(([namespaces, value]) => [namespaces[0] === scope ? namespaces.slice(1) : namespaces, value]) : searchParams;
}
function encodeBase64Url(str) {
  return encodeBase64(str).replace(/\//g, "_").replace(/\+/g, "-").replace(/[=]+$/, "");
}
function decodeBase64Url(str) {
  return decodeBase64(str.replace(/-/g, "+").replace(/_/g, "/"));
}
function percentToByte(p) {
  return String.fromCharCode(parseInt(p.slice(1), 16));
}
function encodeBase64(str) {
  return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));
}
function byteToPercent(b) {
  return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`;
}
function decodeBase64(str) {
  return decodeURIComponent(Array.from(atob(str), byteToPercent).join(""));
}
function decodeJsonParams(pathSegment = "") {
  const segment = decodeURIComponent(pathSegment);
  if (!segment)
    return {};
  try {
    return JSON.parse(decodeBase64Url(segment));
  } catch (err) {
  }
  try {
    return JSON.parse(atob(segment));
  } catch (err) {
  }
  try {
    return JSON.parse(segment);
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
  }
  return {};
}
function encodeJsonParams(params) {
  return params ? encodeBase64Url(JSON.stringify(params)) : "";
}
function decodeParams(pathSegment) {
  return pathSegment.split(";").reduce((params, pair) => {
    const [key, value] = pair.split("=");
    return params[decodeURIComponent(key)] = decodeURIComponent(value), params;
  }, {});
}
function encodeParams(params) {
  return Object.entries(params).filter(([, value]) => value != null).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join(";");
}
var __defProp$3 = Object.defineProperty, __defProps$3 = Object.defineProperties, __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$3 = Object.getOwnPropertySymbols, __hasOwnProp$3 = Object.prototype.hasOwnProperty, __propIsEnum$3 = Object.prototype.propertyIsEnumerable, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b))
      __propIsEnum$3.call(b, prop) && __defNormalProp$3(a, prop, b[prop]);
  return a;
}, __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
const route = {
  create: (routeOrOpts, childrenOrOpts, children) => _createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children)),
  intents: (base) => {
    const basePath = normalize(base).join("/");
    return route.create(`${basePath}/:intent`, [route.create(":params", {
      transform: {
        params: {
          toState: decodeParams,
          toPath: encodeParams
        }
      }
    }, [route.create(":payload", {
      transform: {
        payload: {
          toState: decodeJsonParams,
          toPath: encodeJsonParams
        }
      }
    })])]);
  },
  scope(scopeName, routeOrOpts, childrenOrOpts, children) {
    const options = normalizeArgs(routeOrOpts, childrenOrOpts, children);
    return _createNode(__spreadProps$3(__spreadValues$3({}, options), {
      scope: scopeName
    }));
  }
};
function normalizeChildren(children) {
  return Array.isArray(children) || typeof children == "function" ? children : children ? [children] : [];
}
function isRoute(val) {
  return val && "_isRoute" in val;
}
function normalizeArgs(path, childrenOrOpts, children) {
  return typeof path == "object" ? path : Array.isArray(childrenOrOpts) || typeof childrenOrOpts == "function" || isRoute(childrenOrOpts) ? {
    path,
    children: normalizeChildren(childrenOrOpts)
  } : children ? __spreadProps$3(__spreadValues$3({
    path
  }, childrenOrOpts), {
    children: normalizeChildren(children)
  }) : __spreadValues$3({
    path
  }, childrenOrOpts);
}
function normalize(...paths) {
  return paths.reduce((acc, path) => acc.concat(path.split("/")), []).filter(Boolean);
}
const EMPTY_STATE$1 = {};
function isRoot(pathname) {
  return pathname.split("/").every((segment) => !segment);
}
function _createNode(options) {
  const {
    path,
    scope,
    transform,
    children,
    __unsafe_disableScopedSearchParams
  } = options;
  if (!path)
    throw new TypeError("Missing path");
  const parsedRoute = _parseRoute(path);
  return {
    _isRoute: !0,
    // todo: make a Router class instead
    scope,
    // eslint-disable-next-line camelcase
    __unsafe_disableScopedSearchParams,
    route: parsedRoute,
    children: children || [],
    transform,
    encode(state) {
      return _resolvePathFromState(this, state);
    },
    decode(_path) {
      return _resolveStateFromPath(this, _path);
    },
    isRoot,
    isNotFound(pathname) {
      return this.decode(pathname) === null;
    },
    getBasePath() {
      return this.encode(EMPTY_STATE$1);
    },
    getRedirectBase(pathname) {
      if (isRoot(pathname)) {
        const basePath = this.getBasePath();
        if (pathname !== basePath)
          return basePath;
      }
      return null;
    }
  };
}
function RouterProvider(props) {
  const $ = c(20), {
    onNavigate,
    router: routerProp,
    state
  } = props;
  let t0;
  $[0] !== routerProp ? (t0 = (intentName, parameters, _searchParams) => {
    const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
    return routerProp.encode({
      intent: intentName,
      params,
      payload,
      _searchParams
    });
  }, $[0] = routerProp, $[1] = t0) : t0 = $[1];
  const resolveIntentLink = t0;
  let t1;
  $[2] !== routerProp ? (t1 = (nextState) => routerProp.encode(nextState), $[2] = routerProp, $[3] = t1) : t1 = $[3];
  const resolvePathFromState = t1;
  let t2;
  $[4] !== onNavigate || $[5] !== resolvePathFromState ? (t2 = (nextState_0, t32) => {
    const options = t32 === void 0 ? {} : t32;
    onNavigate({
      path: resolvePathFromState(nextState_0),
      replace: options.replace
    });
  }, $[4] = onNavigate, $[5] = resolvePathFromState, $[6] = t2) : t2 = $[6];
  const navigate = t2;
  let t3;
  $[7] !== onNavigate || $[8] !== resolveIntentLink ? (t3 = (intentName_0, params_0, t42) => {
    const options_0 = t42 === void 0 ? {} : t42;
    onNavigate({
      path: resolveIntentLink(intentName_0, params_0),
      replace: options_0.replace
    });
  }, $[7] = onNavigate, $[8] = resolveIntentLink, $[9] = t3) : t3 = $[9];
  const navigateIntent = t3;
  let t4, t5;
  $[10] !== navigate || $[11] !== navigateIntent || $[12] !== onNavigate || $[13] !== resolveIntentLink || $[14] !== resolvePathFromState || $[15] !== state ? (t5 = {
    navigate,
    navigateIntent,
    navigateUrl: onNavigate,
    resolveIntentLink,
    resolvePathFromState,
    state
  }, $[10] = navigate, $[11] = navigateIntent, $[12] = onNavigate, $[13] = resolveIntentLink, $[14] = resolvePathFromState, $[15] = state, $[16] = t5) : t5 = $[16], t4 = t5;
  const router = t4;
  let t6;
  return $[17] !== props.children || $[18] !== router ? (t6 = /* @__PURE__ */ jsx(RouterContext.Provider, { value: router, children: props.children }), $[17] = props.children, $[18] = router, $[19] = t6) : t6 = $[19], t6;
}
var __defProp$2 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b))
      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  return a;
}, __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b)), __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
function addScope(routerState, scope, scopedState) {
  return scopedState && __spreadProps$2(__spreadValues$2({}, routerState), {
    [scope]: scopedState
  });
}
const RouteScope = function(props) {
  const $ = c(27), {
    children,
    scope,
    __unsafe_disableScopedSearchParams
  } = props, parentRouter = useRouter(), {
    resolvePathFromState: parent_resolvePathFromState,
    navigate: parent_navigate
  } = parentRouter, parentStateRef = useRef(parentRouter.state);
  let t0, t1;
  $[0] !== parentRouter.state ? (t0 = () => {
    parentStateRef.current = parentRouter.state;
  }, t1 = [parentRouter.state], $[0] = parentRouter.state, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1);
  let t2;
  $[3] !== __unsafe_disableScopedSearchParams || $[4] !== scope ? (t2 = (_nextState) => {
    const _a = _nextState, {
      _searchParams
    } = _a, nextState = __objRest$1(_a, [
      "_searchParams"
    ]), nextParentState = addScope(parentStateRef.current, scope, nextState);
    return __unsafe_disableScopedSearchParams ? nextParentState._searchParams = _searchParams : nextParentState[scope]._searchParams = _searchParams, nextParentState;
  }, $[3] = __unsafe_disableScopedSearchParams, $[4] = scope, $[5] = t2) : t2 = $[5];
  const resolveNextParentState = t2;
  let t3;
  $[6] !== parent_resolvePathFromState || $[7] !== resolveNextParentState ? (t3 = (nextState_0) => parent_resolvePathFromState(resolveNextParentState(nextState_0)), $[6] = parent_resolvePathFromState, $[7] = resolveNextParentState, $[8] = t3) : t3 = $[8];
  const resolvePathFromState = t3;
  let t4;
  $[9] !== parent_navigate || $[10] !== resolveNextParentState ? (t4 = (nextState_1, options) => parent_navigate(resolveNextParentState(nextState_1), options), $[9] = parent_navigate, $[10] = resolveNextParentState, $[11] = t4) : t4 = $[11];
  const navigate = t4;
  let t5;
  const parentState = parentRouter.state;
  let t6;
  $[12] !== parentState || $[13] !== scope ? (t6 = parentState[scope] || {}, $[12] = parentState, $[13] = scope, $[14] = t6) : t6 = $[14];
  let childState;
  $[15] !== __unsafe_disableScopedSearchParams || $[16] !== parentState._searchParams || $[17] !== t6 ? (childState = __spreadValues$2({}, t6), __unsafe_disableScopedSearchParams && (childState._searchParams = parentState._searchParams), $[15] = __unsafe_disableScopedSearchParams, $[16] = parentState._searchParams, $[17] = t6, $[18] = childState) : childState = $[18];
  let t7;
  $[19] !== childState || $[20] !== navigate || $[21] !== parentRouter || $[22] !== resolvePathFromState ? (t7 = __spreadProps$2(__spreadValues$2({}, parentRouter), {
    navigate,
    resolvePathFromState,
    state: childState
  }), $[19] = childState, $[20] = navigate, $[21] = parentRouter, $[22] = resolvePathFromState, $[23] = t7) : t7 = $[23], t5 = t7;
  const childRouter = t5;
  let t8;
  return $[24] !== childRouter || $[25] !== children ? (t8 = /* @__PURE__ */ jsx(RouterContext.Provider, { value: childRouter, children }), $[24] = childRouter, $[25] = children, $[26] = t8) : t8 = $[26], t8;
};
RouteScope.displayName = "RouteScope";
const EMPTY_STATE = {};
function useStateLink(options) {
  const $ = c(11), {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex: t0
  } = options, toIndex = t0 === void 0 ? !1 : t0;
  if (state && toIndex)
    throw new Error("Passing both `state` and `toIndex={true}` as props to StateLink is invalid");
  !state && !toIndex && console.error(new Error("No state passed to StateLink. If you want to link to an empty state, its better to use the the `toIndex` property"));
  const {
    resolvePathFromState
  } = useRouter();
  let t1;
  const t2 = toIndex ? EMPTY_STATE : state || EMPTY_STATE;
  let t3;
  $[0] !== resolvePathFromState || $[1] !== t2 ? (t3 = resolvePathFromState(t2), $[0] = resolvePathFromState, $[1] = t2, $[2] = t3) : t3 = $[2], t1 = t3;
  const href = t1;
  let t4;
  $[3] !== href || $[4] !== onClickProp || $[5] !== replace || $[6] !== target ? (t4 = {
    href,
    onClick: onClickProp,
    replace,
    target
  }, $[3] = href, $[4] = onClickProp, $[5] = replace, $[6] = target, $[7] = t4) : t4 = $[7];
  const {
    onClick
  } = useLink(t4);
  let t5;
  return $[8] !== href || $[9] !== onClick ? (t5 = {
    onClick,
    href
  }, $[8] = href, $[9] = onClick, $[10] = t5) : t5 = $[10], t5;
}
var __defProp$1 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b))
      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  return a;
}, __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b)), __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source))
      exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
const StateLink = forwardRef(function(props, ref) {
  var _a;
  const $ = c(18);
  let onClickProp, replace, restProps, state, t0, target;
  $[0] !== props ? (_a = props, {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex: t0
  } = _a, restProps = __objRest(_a, [
    "onClick",
    "replace",
    "state",
    "target",
    "toIndex"
  ]), $[0] = props, $[1] = onClickProp, $[2] = replace, $[3] = restProps, $[4] = state, $[5] = t0, $[6] = target) : (onClickProp = $[1], replace = $[2], restProps = $[3], state = $[4], t0 = $[5], target = $[6]);
  const toIndex = t0 === void 0 ? !1 : t0;
  let t1;
  $[7] !== onClickProp || $[8] !== replace || $[9] !== state || $[10] !== target || $[11] !== toIndex ? (t1 = {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex
  }, $[7] = onClickProp, $[8] = replace, $[9] = state, $[10] = target, $[11] = toIndex, $[12] = t1) : t1 = $[12];
  const {
    onClick,
    href
  } = useStateLink(t1);
  let t2;
  return $[13] !== href || $[14] !== onClick || $[15] !== ref || $[16] !== restProps ? (t2 = /* @__PURE__ */ jsx("a", __spreadProps$1(__spreadValues$1({}, restProps), { href, onClick, ref })), $[13] = href, $[14] = onClick, $[15] = ref, $[16] = restProps, $[17] = t2) : t2 = $[17], t2;
});
function useRouterState(t0) {
  const $ = c(3), selector = t0 === void 0 ? identity : t0, {
    state
  } = useRouter();
  let t1, t2;
  return $[0] !== selector || $[1] !== state ? (t2 = selector(state), $[0] = selector, $[1] = state, $[2] = t2) : t2 = $[2], t1 = t2, t1;
}
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function withRouter(Component) {
  function WithRouter2(props) {
    const $ = c(3), router = useRouter(), t0 = props;
    let t1;
    return $[0] !== router || $[1] !== t0 ? (t1 = /* @__PURE__ */ jsx(Component, __spreadProps(__spreadValues({}, t0), { router })), $[0] = router, $[1] = t0, $[2] = t1) : t1 = $[2], t1;
  }
  return WithRouter2.displayName = `withRouter(${Component.displayName || Component.name})`, WithRouter2;
}
const WithRouter = withRouter((props) => props.children(props.router));
export {
  IntentLink,
  Link,
  RouteScope,
  RouterContext2 as RouterContext,
  RouterProvider,
  StateLink,
  WithRouter,
  _createNode,
  decodeJsonParams,
  encodeJsonParams,
  route,
  useIntentLink,
  useLink,
  useRouter,
  useRouterState,
  useStateLink,
  withRouter
};
//# sourceMappingURL=router.esm.js.map
