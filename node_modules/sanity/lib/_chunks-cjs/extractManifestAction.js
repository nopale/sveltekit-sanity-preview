"use strict";
var node_crypto = require("node:crypto"), fs = require("node:fs/promises"), path = require("node:path"), node_worker_threads = require("node:worker_threads"), dateFns = require("date-fns"), readPkgUp = require("read-pkg-up"), timing = require("./timing.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var readPkgUp__default = /* @__PURE__ */ _interopDefaultCompat(readPkgUp), __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const MANIFEST_FILENAME = "create-manifest.json", SCHEMA_FILENAME_SUFFIX = ".create-schema.json", TOOLS_FILENAME_SUFFIX = ".create-tools.json", FEATURE_ENABLED_ENV_NAME = "SANITY_CLI_EXTRACT_MANIFEST_ENABLED", EXTRACT_MANIFEST_ENABLED = process.env[FEATURE_ENABLED_ENV_NAME] !== "false", EXTRACT_MANIFEST_LOG_ERRORS = process.env.SANITY_CLI_EXTRACT_MANIFEST_LOG_ERRORS === "true", CREATE_TIMER = "create-manifest", EXTRACT_TASK_TIMEOUT_MS = dateFns.minutesToMilliseconds(2), EXTRACT_FAILURE_MESSAGE = `Couldn't extract manifest file. Sanity Create will not be available for the studio.
Disable this message with ${FEATURE_ENABLED_ENV_NAME}=false`;
async function extractManifestSafe(args, context) {
  if (EXTRACT_MANIFEST_ENABLED)
    try {
      await extractManifest(args, context);
      return;
    } catch (err) {
      return EXTRACT_MANIFEST_LOG_ERRORS && context.output.error(err), err;
    }
}
async function extractManifest(args, context) {
  var _a, _b;
  const {
    output,
    workDir
  } = context, flags = args.extOptions, defaultOutputDir = path.resolve(path.join(workDir, "dist")), outputDir = path.resolve(defaultOutputDir), defaultStaticPath = path.join(outputDir, "static"), staticPath = (_a = flags.path) != null ? _a : defaultStaticPath, path$1 = path.join(staticPath, MANIFEST_FILENAME), rootPkgPath = (_b = readPkgUp__default.default.sync({
    cwd: __dirname
  })) == null ? void 0 : _b.path;
  if (!rootPkgPath)
    throw new Error("Could not find root directory for `sanity` package");
  const timer = timing.getTimer();
  timer.start(CREATE_TIMER);
  const spinner = output.spinner({}).start("Extracting manifest");
  try {
    const workspaceManifests = await getWorkspaceManifests({
      rootPkgPath,
      workDir
    });
    await fs.mkdir(staticPath, {
      recursive: !0
    });
    const workspaceFiles = await writeWorkspaceFiles(workspaceManifests, staticPath), manifest = {
      /**
       * Version history:
       * 1: Initial release.
       * 2: Added tools file.
       */
      version: 2,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      workspaces: workspaceFiles
    };
    await fs.writeFile(path$1, JSON.stringify(manifest, null, 2));
    const manifestDuration = timer.end(CREATE_TIMER);
    spinner.succeed(`Extracted manifest (${manifestDuration.toFixed()}ms)`);
  } catch (err) {
    throw spinner.info(EXTRACT_FAILURE_MESSAGE), err;
  }
}
async function getWorkspaceManifests({
  rootPkgPath,
  workDir
}) {
  const workerPath = path.join(path.dirname(rootPkgPath), "lib", "_internal", "cli", "threads", "extractManifest.js"), worker = new node_worker_threads.Worker(workerPath, {
    workerData: {
      workDir
    },
    // eslint-disable-next-line no-process-env
    env: process.env
  });
  let timeout = !1;
  const timeoutId = setTimeout(() => {
    timeout = !0, worker.terminate();
  }, EXTRACT_TASK_TIMEOUT_MS);
  try {
    return await new Promise((resolveWorkspaces, reject) => {
      const buffer = [];
      worker.addListener("message", (message) => buffer.push(message)), worker.addListener("exit", (exitCode) => {
        exitCode === 0 ? resolveWorkspaces(buffer) : timeout && reject(new Error(`Extract manifest was aborted after ${EXTRACT_TASK_TIMEOUT_MS}ms`));
      }), worker.addListener("error", reject);
    });
  } finally {
    clearTimeout(timeoutId);
  }
}
function writeWorkspaceFiles(manifestWorkspaces, staticPath) {
  const output = manifestWorkspaces.reduce((workspaces, workspace) => [...workspaces, writeWorkspaceFile(workspace, staticPath)], []);
  return Promise.all(output);
}
async function writeWorkspaceFile(workspace, staticPath) {
  const [schemaFilename, toolsFilename] = await Promise.all([createFile(staticPath, workspace.schema, SCHEMA_FILENAME_SUFFIX), createFile(staticPath, workspace.tools, TOOLS_FILENAME_SUFFIX)]);
  return __spreadProps(__spreadValues({}, workspace), {
    schema: schemaFilename,
    tools: toolsFilename
  });
}
const createFile = async (path$1, content, filenameSuffix) => {
  const stringifiedContent = JSON.stringify(content, null, 2), filename = `${node_crypto.createHash("sha1").update(stringifiedContent).digest("hex").slice(0, 8)}${filenameSuffix}`;
  return await fs.writeFile(path.join(path$1, filename), stringifiedContent), filename;
};
exports.extractManifestSafe = extractManifestSafe;
//# sourceMappingURL=extractManifestAction.js.map
