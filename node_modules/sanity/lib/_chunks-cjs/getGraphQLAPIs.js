"use strict";
var path = require("node:path"), node_worker_threads = require("node:worker_threads"), readPkgUp = require("read-pkg-up"), sanity = require("sanity");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var path__default = /* @__PURE__ */ _interopDefaultCompat(path), readPkgUp__default = /* @__PURE__ */ _interopDefaultCompat(readPkgUp), __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    __hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0 && (target[prop] = source[prop]);
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source))
      exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop) && (target[prop] = source[prop]);
  return target;
};
async function getGraphQLAPIs(cliContext) {
  if (!isModernCliConfig(cliContext))
    throw new Error("Expected Sanity studio of version 3 or above");
  if (!node_worker_threads.isMainThread)
    throw new Error("getGraphQLAPIs() must be called from the main thread");
  const defaultTypes = sanity.createSchema({
    name: "default",
    types: []
  }).getTypeNames(), isCustomType = (type) => !defaultTypes.includes(type.name);
  return (await getApisWithSchemaTypes(cliContext)).map((_a) => {
    var _b = _a, {
      schemaTypes
    } = _b, api = __objRest(_b, [
      "schemaTypes"
    ]);
    return __spreadValues({
      schema: sanity.createSchema({
        name: "default",
        types: schemaTypes.filter(isCustomType)
      })
    }, api);
  });
}
function getApisWithSchemaTypes(cliContext) {
  return new Promise((resolve, reject) => {
    var _a;
    const {
      cliConfig,
      cliConfigPath,
      workDir
    } = cliContext, rootPkgPath = (_a = readPkgUp__default.default.sync({
      cwd: __dirname
    })) == null ? void 0 : _a.path;
    if (!rootPkgPath)
      throw new Error("Could not find root directory for `sanity` package");
    const rootDir = path__default.default.dirname(rootPkgPath), workerPath = path__default.default.join(rootDir, "lib", "_internal", "cli", "threads", "getGraphQLAPIs.js"), worker = new node_worker_threads.Worker(workerPath, {
      workerData: {
        cliConfig: serialize(cliConfig || {}),
        cliConfigPath,
        workDir
      },
      // eslint-disable-next-line no-process-env
      env: process.env
    });
    worker.on("message", resolve), worker.on("error", reject), worker.on("exit", (code) => {
      code !== 0 && reject(new Error(`Worker stopped with exit code ${code}`));
    });
  });
}
function isModernCliConfig(config) {
  return config.sanityMajorVersion >= 3;
}
function serialize(obj) {
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (cause) {
    throw new Error("Failed to serialize CLI configuration", {
      cause
    });
  }
}
exports.getGraphQLAPIs = getGraphQLAPIs;
//# sourceMappingURL=getGraphQLAPIs.js.map
