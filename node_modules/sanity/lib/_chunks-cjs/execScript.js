"use strict";
var node_child_process = require("node:child_process"), fs = require("node:fs/promises"), path = require("node:path"), readPkgUp = require("read-pkg-up"), helpers = require("yargs/helpers"), yargs = require("yargs/yargs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), path__default = /* @__PURE__ */ _interopDefaultCompat(path), readPkgUp__default = /* @__PURE__ */ _interopDefaultCompat(readPkgUp), yargs__default = /* @__PURE__ */ _interopDefaultCompat(yargs), __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
async function parseCliFlags(args) {
  const flags = await yargs__default.default(helpers.hideBin(args.argv || process.argv).slice(2)).option("with-user-token", {
    type: "boolean",
    default: !1
  }).option("mock-browser-env", {
    type: "boolean",
    default: !1
  }).argv;
  return __spreadProps(__spreadValues({}, flags), {
    script: args.argsWithoutOptions[0]
  });
}
const execScript = async function(args, context) {
  var _a;
  const {
    withUserToken,
    mockBrowserEnv,
    script
  } = await parseCliFlags(args), {
    workDir
  } = context, scriptPath = path__default.default.resolve(script || "");
  if (!script)
    throw new Error("SCRIPT must be provided. `sanity exec <script>`");
  if (!await fs__default.default.stat(scriptPath).catch(() => !1))
    throw new Error(`${scriptPath} does not exist`);
  const sanityPkgPath = (_a = await readPkgUp__default.default({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  if (!sanityPkgPath)
    throw new Error("Unable to resolve `sanity` module root");
  const sanityDir = path__default.default.dirname(sanityPkgPath), threadsDir = path__default.default.join(sanityDir, "lib", "_internal", "cli", "threads"), esbuildPath = path__default.default.join(threadsDir, "esbuild.js"), browserEnvPath = path__default.default.join(threadsDir, "registerBrowserEnv.js"), configClientPath = path__default.default.join(threadsDir, "configClient.js");
  if (!await fs__default.default.stat(esbuildPath).catch(() => !1))
    throw new Error("`sanity` module build error: missing threads");
  const baseArgs = mockBrowserEnv ? ["-r", browserEnvPath] : ["-r", esbuildPath], tokenArgs = withUserToken ? ["-r", configClientPath] : [], nodeArgs = [...baseArgs, ...tokenArgs, scriptPath, ...args.extraArguments];
  node_child_process.spawn(process.argv[0], nodeArgs, {
    stdio: "inherit",
    env: __spreadProps(__spreadValues({}, process.env), {
      SANITY_BASE_PATH: workDir
    })
  }).on("close", process.exit);
};
exports.default = execScript;
//# sourceMappingURL=execScript.js.map
