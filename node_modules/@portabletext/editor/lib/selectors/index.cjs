"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var selector_isSelectionCollapsed = require("../_chunks-cjs/selector.is-selection-collapsed.cjs"), types = require("@sanity/types"), selector_getTextBefore = require("../_chunks-cjs/selector.get-text-before.cjs");
const getActiveListItem = ({
  context
}) => {
  if (!context.selection)
    return;
  const guards = selector_isSelectionCollapsed.createGuards(context), selectedTextBlocks = selector_isSelectionCollapsed.getSelectedBlocks({
    context
  }).map((block) => block.node).filter(guards.isTextBlock), firstTextBlock = selectedTextBlocks.at(0);
  if (!firstTextBlock)
    return;
  const firstListItem = firstTextBlock.listItem;
  if (firstListItem && selectedTextBlocks.every((block) => block.listItem === firstListItem))
    return firstListItem;
}, getActiveStyle = ({
  context
}) => {
  if (!context.selection)
    return;
  const guards = selector_isSelectionCollapsed.createGuards(context), selectedTextBlocks = selector_isSelectionCollapsed.getSelectedBlocks({
    context
  }).map((block) => block.node).filter(guards.isTextBlock), firstTextBlock = selectedTextBlocks.at(0);
  if (!firstTextBlock)
    return;
  const firstStyle = firstTextBlock.style;
  if (firstStyle && selectedTextBlocks.every((block) => block.style === firstStyle))
    return firstStyle;
}, getSelectedSpans = ({
  context
}) => {
  if (!context.selection)
    return [];
  const selectedSpans = [], startPoint = context.selection.backward ? context.selection.focus : context.selection.anchor, endPoint = context.selection.backward ? context.selection.anchor : context.selection.focus, startBlockKey = types.isKeySegment(startPoint.path[0]) ? startPoint.path[0]._key : void 0, endBlockKey = types.isKeySegment(endPoint.path[0]) ? endPoint.path[0]._key : void 0;
  if (!startBlockKey || !endBlockKey)
    return selectedSpans;
  const startSpanKey = types.isKeySegment(startPoint.path[2]) ? startPoint.path[2]._key : void 0, endSpanKey = types.isKeySegment(endPoint.path[2]) ? endPoint.path[2]._key : void 0;
  for (const block of context.value)
    if (types.isPortableTextTextBlock(block)) {
      if (block._key === startBlockKey) {
        for (const child of block.children)
          if (types.isPortableTextSpan(child)) {
            if (startSpanKey && child._key === startSpanKey && (selectedSpans.push({
              node: child,
              path: [{
                _key: block._key
              }, "children", {
                _key: child._key
              }]
            }), startBlockKey === endBlockKey))
              break;
            if (endSpanKey && child._key === endSpanKey) {
              selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              });
              break;
            }
            selectedSpans.length > 0 && selectedSpans.push({
              node: child,
              path: [{
                _key: block._key
              }, "children", {
                _key: child._key
              }]
            });
          }
        if (startBlockKey === endBlockKey)
          break;
        continue;
      }
      if (block._key === endBlockKey) {
        for (const child of block.children)
          if (types.isPortableTextSpan(child)) {
            if (endSpanKey && child._key === endSpanKey) {
              selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              });
              break;
            }
            selectedSpans.push({
              node: child,
              path: [{
                _key: block._key
              }, "children", {
                _key: child._key
              }]
            });
          }
        break;
      }
      if (selectedSpans.length > 0)
        for (const child of block.children)
          types.isPortableTextSpan(child) && selectedSpans.push({
            node: child,
            path: [{
              _key: block._key
            }, "children", {
              _key: child._key
            }]
          });
    }
  return selectedSpans;
};
function isActiveAnnotation(annotation) {
  return (snapshot) => {
    if (!snapshot.context.selection)
      return !1;
    const selectedBlocks = selector_isSelectionCollapsed.getSelectedBlocks(snapshot), selectedSpans = getSelectedSpans(snapshot);
    if (selectedSpans.length === 0 || selectedSpans.some((span) => !span.node.marks || span.node.marks?.length === 0))
      return !1;
    const selectionMarkDefs = selectedBlocks.flatMap((block) => types.isPortableTextTextBlock(block.node) ? block.node.markDefs ?? [] : []);
    return selectedSpans.every((span) => (span.node.marks?.flatMap((mark) => {
      const markDef = selectionMarkDefs.find((markDef2) => markDef2._key === mark);
      return markDef ? [markDef._type] : [];
    }) ?? []).includes(annotation));
  };
}
const isSelectionExpanded = ({
  context
}) => !selector_isSelectionCollapsed.isSelectionCollapsed({
  context
});
function isActiveDecorator(decorator) {
  return (snapshot) => {
    if (isSelectionExpanded(snapshot)) {
      const selectedSpans = getSelectedSpans(snapshot);
      return selectedSpans.length > 0 && selectedSpans.every((span) => span.node.marks?.includes(decorator));
    }
    return snapshot.context.activeDecorators.includes(decorator);
  };
}
function isActiveListItem(listItem) {
  return (snapshot) => getActiveListItem(snapshot) === listItem;
}
function isActiveStyle(style) {
  return (snapshot) => getActiveStyle(snapshot) === style;
}
exports.getFirstBlock = selector_isSelectionCollapsed.getFirstBlock;
exports.getFocusBlock = selector_isSelectionCollapsed.getFocusBlock;
exports.getFocusBlockObject = selector_isSelectionCollapsed.getFocusBlockObject;
exports.getFocusChild = selector_isSelectionCollapsed.getFocusChild;
exports.getFocusListBlock = selector_isSelectionCollapsed.getFocusListBlock;
exports.getFocusSpan = selector_isSelectionCollapsed.getFocusSpan;
exports.getFocusTextBlock = selector_isSelectionCollapsed.getFocusTextBlock;
exports.getLastBlock = selector_isSelectionCollapsed.getLastBlock;
exports.getNextBlock = selector_isSelectionCollapsed.getNextBlock;
exports.getPreviousBlock = selector_isSelectionCollapsed.getPreviousBlock;
exports.getSelectedBlocks = selector_isSelectionCollapsed.getSelectedBlocks;
exports.getSelectionEndBlock = selector_isSelectionCollapsed.getSelectionEndBlock;
exports.getSelectionStartBlock = selector_isSelectionCollapsed.getSelectionStartBlock;
exports.isSelectionCollapsed = selector_isSelectionCollapsed.isSelectionCollapsed;
exports.getBlockTextBefore = selector_getTextBefore.getBlockTextBefore;
exports.getSelectionText = selector_getTextBefore.getSelectionText;
exports.getActiveListItem = getActiveListItem;
exports.getActiveStyle = getActiveStyle;
exports.getSelectedSpans = getSelectedSpans;
exports.isActiveAnnotation = isActiveAnnotation;
exports.isActiveDecorator = isActiveDecorator;
exports.isActiveListItem = isActiveListItem;
exports.isActiveStyle = isActiveStyle;
exports.isSelectionExpanded = isSelectionExpanded;
//# sourceMappingURL=index.cjs.map
