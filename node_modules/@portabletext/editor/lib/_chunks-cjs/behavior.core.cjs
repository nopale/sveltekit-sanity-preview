"use strict";
var types = require("@sanity/types"), selector_isSelectionCollapsed = require("./selector.is-selection-collapsed.cjs");
function blockOffsetToSpanSelectionPoint({
  value,
  blockOffset
}) {
  let offsetLeft = blockOffset.offset, selectionPoint;
  for (const block of value)
    if (block._key === blockOffset.path[0]._key && types.isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (types.isPortableTextSpan(child)) {
          if (offsetLeft === 0) {
            selectionPoint = {
              path: [...blockOffset.path, "children", {
                _key: child._key
              }],
              offset: 0
            };
            break;
          }
          if (offsetLeft <= child.text.length) {
            selectionPoint = {
              path: [...blockOffset.path, "children", {
                _key: child._key
              }],
              offset: offsetLeft
            };
            break;
          }
          offsetLeft -= child.text.length;
        }
    }
  return selectionPoint;
}
function spanSelectionPointToBlockOffset({
  value,
  selectionPoint
}) {
  let offset = 0;
  for (const block of value)
    if (block._key === selectionPoint.path[0]._key && types.isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (types.isPortableTextSpan(child)) {
          if (child._key === selectionPoint.path[2]._key)
            return {
              path: [{
                _key: block._key
              }],
              offset: offset + selectionPoint.offset
            };
          offset += child.text.length;
        }
    }
}
function isEmptyTextBlock(block) {
  if (!types.isPortableTextTextBlock(block))
    return !1;
  const onlyText = block.children.every(types.isPortableTextSpan), blockText = getTextBlockText(block);
  return onlyText && blockText === "";
}
function getTextBlockText(block) {
  return block.children.map((child) => child.text ?? "").join("");
}
const IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, aliases = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: IS_MAC ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, keyCodes = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  f13: 124,
  f14: 125,
  f15: 126,
  f16: 127,
  f17: 128,
  f18: 129,
  f19: 130,
  f20: 131
};
function isHotkey(hotkey, event) {
  return compareHotkey(parseHotkey(hotkey), event);
}
function parseHotkey(hotkey) {
  const parsedHotkey = {
    altKey: !1,
    ctrlKey: !1,
    metaKey: !1,
    shiftKey: !1
  }, hotkeySegments = hotkey.replace("++", "+add").split("+");
  for (const rawHotkeySegment of hotkeySegments) {
    const optional = rawHotkeySegment.endsWith("?") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];
    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0)
      throw new TypeError(`Unknown modifier: "${hotkeySegment}"`);
    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);
  }
  return parsedHotkey;
}
function compareHotkey(parsedHotkey, event) {
  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;
}
function toKeyCode(name) {
  const keyName = toKeyName(name);
  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);
}
function toKeyName(name) {
  const keyName = name.toLowerCase();
  return aliases[keyName] ?? keyName;
}
function defineBehavior(behavior) {
  return behavior;
}
const arrowDownOnLonelyBlockObject = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    const isArrowDown = isHotkey("ArrowDown", event.keyboardEvent), focusBlockObject = selector_isSelectionCollapsed.getFocusBlockObject({
      context
    }), nextBlock = selector_isSelectionCollapsed.getNextBlock({
      context
    });
    return isArrowDown && focusBlockObject && !nextBlock;
  },
  actions: [() => [{
    type: "insert.text block",
    placement: "after"
  }]]
}, arrowUpOnLonelyBlockObject = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    const isArrowUp = isHotkey("ArrowUp", event.keyboardEvent), focusBlockObject = selector_isSelectionCollapsed.getFocusBlockObject({
      context
    }), previousBlock = selector_isSelectionCollapsed.getPreviousBlock({
      context
    });
    return isArrowUp && focusBlockObject && !previousBlock;
  },
  actions: [() => [{
    type: "insert.text block",
    placement: "before"
  }, {
    type: "select.previous block"
  }]]
}, breakingBlockObject = {
  on: "insert.break",
  guard: ({
    context
  }) => {
    const focusBlockObject = selector_isSelectionCollapsed.getFocusBlockObject({
      context
    });
    return selector_isSelectionCollapsed.isSelectionCollapsed({
      context
    }) && focusBlockObject !== void 0;
  },
  actions: [() => [{
    type: "insert.text block",
    placement: "after"
  }]]
}, deletingEmptyTextBlockAfterBlockObject = {
  on: "delete.backward",
  guard: ({
    context
  }) => {
    const focusTextBlock = selector_isSelectionCollapsed.getFocusTextBlock({
      context
    }), selectionCollapsed = selector_isSelectionCollapsed.isSelectionCollapsed({
      context
    }), previousBlock = selector_isSelectionCollapsed.getPreviousBlock({
      context
    });
    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !types.isPortableTextTextBlock(previousBlock.node) ? {
      focusTextBlock,
      previousBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    previousBlock
  }) => [{
    type: "delete.block",
    blockPath: focusTextBlock.path
  }, {
    type: "select",
    selection: {
      anchor: {
        path: previousBlock.path,
        offset: 0
      },
      focus: {
        path: previousBlock.path,
        offset: 0
      }
    }
  }]]
}, deletingEmptyTextBlockBeforeBlockObject = {
  on: "delete.forward",
  guard: ({
    context
  }) => {
    const focusTextBlock = selector_isSelectionCollapsed.getFocusTextBlock({
      context
    }), selectionCollapsed = selector_isSelectionCollapsed.isSelectionCollapsed({
      context
    }), nextBlock = selector_isSelectionCollapsed.getNextBlock({
      context
    });
    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !types.isPortableTextTextBlock(nextBlock.node) ? {
      focusTextBlock,
      nextBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    nextBlock
  }) => [{
    type: "delete.block",
    blockPath: focusTextBlock.path
  }, {
    type: "select",
    selection: {
      anchor: {
        path: nextBlock.path,
        offset: 0
      },
      focus: {
        path: nextBlock.path,
        offset: 0
      }
    }
  }]]
}, coreBlockObjectBehaviors = {
  arrowDownOnLonelyBlockObject,
  arrowUpOnLonelyBlockObject,
  breakingBlockObject,
  deletingEmptyTextBlockAfterBlockObject,
  deletingEmptyTextBlockBeforeBlockObject
}, decoratorAdd = {
  on: "decorator.add",
  actions: [({
    event
  }) => [event, {
    type: "reselect"
  }]]
}, decoratorRemove = {
  on: "decorator.remove",
  guard: ({
    event
  }) => ({
    decorator: event.decorator
  }),
  actions: [({
    event
  }) => [event, {
    type: "reselect"
  }]]
}, decoratorToggle = {
  on: "decorator.toggle",
  guard: ({
    event
  }) => ({
    decorator: event.decorator
  }),
  actions: [({
    event
  }) => [event, {
    type: "reselect"
  }]]
}, coreDecoratorBehaviors = {
  decoratorAdd,
  decoratorRemove,
  decoratorToggle
}, MAX_LIST_LEVEL = 10, clearListOnBackspace = {
  on: "delete.backward",
  guard: ({
    context
  }) => {
    const selectionCollapsed = selector_isSelectionCollapsed.isSelectionCollapsed({
      context
    }), focusTextBlock = selector_isSelectionCollapsed.getFocusTextBlock({
      context
    }), focusSpan = selector_isSelectionCollapsed.getFocusSpan({
      context
    });
    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level === 1 ? {
      focusTextBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock
  }) => [{
    type: "text block.unset",
    props: ["listItem", "level"],
    at: focusTextBlock.path
  }]]
}, unindentListOnBackspace = {
  on: "delete.backward",
  guard: ({
    context
  }) => {
    const selectionCollapsed = selector_isSelectionCollapsed.isSelectionCollapsed({
      context
    }), focusTextBlock = selector_isSelectionCollapsed.getFocusTextBlock({
      context
    }), focusSpan = selector_isSelectionCollapsed.getFocusSpan({
      context
    });
    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {
      focusTextBlock,
      level: focusTextBlock.node.level - 1
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    level
  }) => [{
    type: "text block.set",
    level,
    at: focusTextBlock.path
  }]]
}, clearListOnEnter = {
  on: "insert.break",
  guard: ({
    context
  }) => {
    const selectionCollapsed = selector_isSelectionCollapsed.isSelectionCollapsed({
      context
    }), focusListBlock = selector_isSelectionCollapsed.getFocusListBlock({
      context
    });
    return !selectionCollapsed || !focusListBlock || !isEmptyTextBlock(focusListBlock.node) ? !1 : {
      focusListBlock
    };
  },
  actions: [(_, {
    focusListBlock
  }) => [{
    type: "text block.unset",
    props: ["listItem", "level"],
    at: focusListBlock.path
  }]]
}, indentListOnTab = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    if (!isHotkey("Tab", event.keyboardEvent))
      return !1;
    const selectedBlocks = selector_isSelectionCollapsed.getSelectedBlocks({
      context
    }), guards = selector_isSelectionCollapsed.createGuards(context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => ({
    type: "text block.set",
    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1)),
    at: selectedListBlock.path
  }))]
}, unindentListOnShiftTab = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    if (!isHotkey("Shift+Tab", event.keyboardEvent))
      return !1;
    const selectedBlocks = selector_isSelectionCollapsed.getSelectedBlocks({
      context
    }), guards = selector_isSelectionCollapsed.createGuards(context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => ({
    type: "text block.set",
    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1)),
    at: selectedListBlock.path
  }))]
}, coreListBehaviors = {
  clearListOnBackspace,
  unindentListOnBackspace,
  clearListOnEnter,
  indentListOnTab,
  unindentListOnShiftTab
}, softReturn = {
  on: "insert.soft break",
  actions: [() => [{
    type: "insert.text",
    text: `
`
  }]]
}, coreBehaviors = [softReturn, coreDecoratorBehaviors.decoratorAdd, coreDecoratorBehaviors.decoratorRemove, coreDecoratorBehaviors.decoratorToggle, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab], coreBehavior = {
  softReturn,
  decorators: coreDecoratorBehaviors,
  blockObjects: coreBlockObjectBehaviors,
  lists: coreListBehaviors
};
exports.blockOffsetToSpanSelectionPoint = blockOffsetToSpanSelectionPoint;
exports.coreBehavior = coreBehavior;
exports.coreBehaviors = coreBehaviors;
exports.defineBehavior = defineBehavior;
exports.getTextBlockText = getTextBlockText;
exports.isHotkey = isHotkey;
exports.spanSelectionPointToBlockOffset = spanSelectionPointToBlockOffset;
//# sourceMappingURL=behavior.core.cjs.map
