import { isPortableTextTextBlock, isPortableTextSpan } from "@sanity/types";
function isKeyedSegment(segment) {
  return typeof segment == "object" && segment !== null && "_key" in segment;
}
function reverseSelection(selection) {
  return selection.backward ? {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !1
  } : {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !0
  };
}
const getSelectionText = ({
  context
}) => {
  let text = "";
  const {
    value,
    selection
  } = context;
  if (!value || !selection)
    return text;
  const forwardSelection = selection.backward ? reverseSelection(selection) : selection;
  if (!forwardSelection)
    return text;
  for (const block of value)
    if (!(isKeyedSegment(forwardSelection.anchor.path[0]) && block._key !== forwardSelection.anchor.path[0]._key) && isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (isPortableTextSpan(child)) {
          if (isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key && isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset, forwardSelection.focus.offset);
            break;
          }
          if (isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset);
            continue;
          }
          if (isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(0, forwardSelection.focus.offset);
            break;
          }
        }
      if (isKeyedSegment(forwardSelection.focus.path[0]) && block._key === forwardSelection.focus.path[0]._key)
        break;
    }
  return text;
};
function getStartPoint({
  node,
  path
}) {
  return isPortableTextTextBlock(node) ? {
    path: [...path, "children", {
      _key: node.children[0]._key
    }],
    offset: 0
  } : {
    path,
    offset: 0
  };
}
const getBlockTextBefore = ({
  context
}) => {
  if (!context.selection)
    return "";
  const point = (context.selection.backward ? reverseSelection(context.selection) : context.selection).anchor, key = isKeyedSegment(point.path[0]) ? point.path[0]._key : void 0, block = key ? context.value.find((block2) => block2._key === key) : void 0;
  if (!block)
    return "";
  const startOfBlock = getStartPoint({
    node: block,
    path: [{
      _key: block._key
    }]
  });
  return getSelectionText({
    context: {
      ...context,
      value: context.value,
      selection: {
        anchor: startOfBlock,
        focus: point
      }
    }
  });
};
export {
  getBlockTextBefore,
  getSelectionText
};
//# sourceMappingURL=selector.get-text-before.js.map
