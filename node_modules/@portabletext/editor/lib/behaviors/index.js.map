{"version":3,"file":"index.js","sources":["../../src/behaviors/behavior.code-editor.ts","../../src/behaviors/behavior.emoji-picker.ts","../../src/utils/looks-like-url.ts","../../src/behaviors/behavior.links.ts","../../src/behaviors/behavior.markdown.ts"],"sourcesContent":["import * as selectors from '../selectors'\nimport {isHotkey} from '../utils/is-hotkey'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type CodeEditorBehaviorsConfig = {\n  moveBlockUpShortcut: string\n  moveBlockDownShortcut: string\n}\n\n/**\n * @beta\n */\nexport function createCodeEditorBehaviors(config: CodeEditorBehaviorsConfig) {\n  return [\n    defineBehavior({\n      on: 'key.down',\n      guard: ({context, event}) => {\n        const isMoveUpShortcut = isHotkey(\n          config.moveBlockUpShortcut,\n          event.keyboardEvent,\n        )\n        const firstBlock = selectors.getFirstBlock({context})\n        const selectedBlocks = selectors.getSelectedBlocks({context})\n        const blocksAbove =\n          firstBlock?.node._key !== selectedBlocks[0]?.node._key\n\n        if (!isMoveUpShortcut || !blocksAbove) {\n          return false\n        }\n\n        return {paths: selectedBlocks.map((block) => block.path)}\n      },\n      actions: [\n        (_, {paths}) =>\n          paths.map((at) => ({\n            type: 'move.block up',\n            at,\n          })),\n      ],\n    }),\n    defineBehavior({\n      on: 'key.down',\n      guard: ({context, event}) => {\n        const isMoveDownShortcut = isHotkey(\n          config.moveBlockDownShortcut,\n          event.keyboardEvent,\n        )\n        const lastBlock = selectors.getLastBlock({context})\n        const selectedBlocks = selectors.getSelectedBlocks({context})\n        const blocksBelow =\n          lastBlock?.node._key !==\n          selectedBlocks[selectedBlocks.length - 1]?.node._key\n\n        if (!isMoveDownShortcut || !blocksBelow) {\n          return false\n        }\n\n        return {paths: selectedBlocks.map((block) => block.path).reverse()}\n      },\n      actions: [\n        (_, {paths}) =>\n          paths.map((at) => ({\n            type: 'move.block down',\n            at,\n          })),\n      ],\n    }),\n  ]\n}\n","import {assertEvent, assign, createActor, setup} from 'xstate'\nimport * as selectors from '../selectors'\nimport {isHotkey} from '../utils/is-hotkey'\nimport {defineBehavior} from './behavior.types'\n\nconst emojiCharRegEx = /^[a-zA-Z-_0-9]{1}$/\nconst incompleteEmojiRegEx = /:([a-zA-Z-_0-9]+)$/\nconst emojiRegEx = /:([a-zA-Z-_0-9]+):$/\n\n/**\n * @beta\n */\nexport type EmojiPickerBehaviorsConfig<TEmojiMatch> = {\n  /**\n   * Match emojis by keyword.\n   */\n  matchEmojis: ({keyword}: {keyword: string}) => Array<TEmojiMatch>\n  onMatchesChanged: ({matches}: {matches: Array<TEmojiMatch>}) => void\n  onSelectedIndexChanged: ({selectedIndex}: {selectedIndex: number}) => void\n  /**\n   * Parse an emoji match to a string that will be inserted into the editor.\n   */\n  parseMatch: ({match}: {match: TEmojiMatch}) => string | undefined\n}\n\n/**\n * @beta\n */\nexport function createEmojiPickerBehaviors<TEmojiMatch>(\n  config: EmojiPickerBehaviorsConfig<TEmojiMatch>,\n) {\n  const emojiPickerActor = createActor(createEmojiPickerMachine<TEmojiMatch>())\n  emojiPickerActor.start()\n  emojiPickerActor.subscribe((state) => {\n    config.onMatchesChanged({matches: state.context.matches})\n    config.onSelectedIndexChanged({selectedIndex: state.context.selectedIndex})\n  })\n\n  return [\n    defineBehavior({\n      on: 'insert.text',\n      guard: ({context, event}) => {\n        if (event.text === ':') {\n          return false\n        }\n\n        const isEmojiChar = emojiCharRegEx.test(event.text)\n\n        if (!isEmojiChar) {\n          return {emojis: []}\n        }\n\n        const focusBlock = selectors.getFocusTextBlock({context})\n        const textBefore = selectors.getBlockTextBefore({context})\n        const emojiKeyword = `${textBefore}${event.text}`.match(\n          incompleteEmojiRegEx,\n        )?.[1]\n\n        if (!focusBlock || emojiKeyword === undefined) {\n          return {emojis: []}\n        }\n\n        const emojis = config.matchEmojis({keyword: emojiKeyword})\n\n        return {emojis}\n      },\n      actions: [\n        (_, params) => [\n          {\n            type: 'effect',\n            effect: () => {\n              emojiPickerActor.send({\n                type: 'emojis found',\n                matches: params.emojis,\n              })\n            },\n          },\n        ],\n      ],\n    }),\n    defineBehavior({\n      on: 'insert.text',\n      guard: ({context, event}) => {\n        const isColon = event.text === ':'\n\n        if (!isColon) {\n          return false\n        }\n\n        const matches = emojiPickerActor.getSnapshot().context.matches\n        const selectedIndex =\n          emojiPickerActor.getSnapshot().context.selectedIndex\n        const emoji = matches[selectedIndex]\n          ? config.parseMatch({match: matches[selectedIndex]})\n          : undefined\n\n        const focusBlock = selectors.getFocusTextBlock({context})\n        const textBefore = selectors.getBlockTextBefore({context})\n        const emojiKeyword = `${textBefore}:`.match(emojiRegEx)?.[1]\n\n        if (!focusBlock || emojiKeyword === undefined) {\n          return false\n        }\n\n        const emojiStringLength = emojiKeyword.length + 2\n\n        if (emoji) {\n          return {\n            focusBlock,\n            emoji,\n            emojiStringLength,\n            textBeforeLength: textBefore.length + 1,\n          }\n        }\n\n        return false\n      },\n      actions: [\n        () => [\n          {\n            type: 'insert.text',\n            text: ':',\n          },\n        ],\n        (_, params) => [\n          {\n            type: 'effect',\n            effect: () => {\n              emojiPickerActor.send({type: 'select'})\n            },\n          },\n          {\n            type: 'delete.text',\n            anchor: {\n              path: params.focusBlock.path,\n              offset: params.textBeforeLength - params.emojiStringLength,\n            },\n            focus: {\n              path: params.focusBlock.path,\n              offset: params.textBeforeLength,\n            },\n          },\n          {\n            type: 'insert.text',\n            text: params.emoji,\n          },\n        ],\n      ],\n    }),\n    defineBehavior({\n      on: 'key.down',\n      guard: ({context, event}) => {\n        const matches = emojiPickerActor.getSnapshot().context.matches\n\n        if (matches.length === 0) {\n          return false\n        }\n\n        const isEscape = isHotkey('Escape', event.keyboardEvent)\n\n        if (isEscape) {\n          return {action: 'reset' as const}\n        }\n\n        const isEnter = isHotkey('Enter', event.keyboardEvent)\n        const isTab = isHotkey('Tab', event.keyboardEvent)\n\n        if (isEnter || isTab) {\n          const selectedIndex =\n            emojiPickerActor.getSnapshot().context.selectedIndex\n\n          const emoji = matches[selectedIndex]\n            ? config.parseMatch({match: matches[selectedIndex]})\n            : undefined\n\n          if (!emoji) {\n            return false\n          }\n\n          const focusBlock = selectors.getFocusTextBlock({context})\n          const textBefore = selectors.getBlockTextBefore({context})\n          const emojiKeyword = textBefore.match(incompleteEmojiRegEx)?.[1]\n\n          if (!focusBlock || emojiKeyword === undefined) {\n            return false\n          }\n\n          const emojiStringLength = emojiKeyword.length + 1\n\n          if (emoji) {\n            return {\n              action: 'select' as const,\n              focusBlock,\n              emoji,\n              emojiStringLength,\n              textBeforeLength: textBefore.length,\n            }\n          }\n\n          return false\n        }\n\n        const isArrowDown = isHotkey('ArrowDown', event.keyboardEvent)\n        const isArrowUp = isHotkey('ArrowUp', event.keyboardEvent)\n\n        if (isArrowDown && matches.length > 0) {\n          return {action: 'navigate down' as const}\n        }\n\n        if (isArrowUp && matches.length > 0) {\n          return {action: 'navigate up' as const}\n        }\n\n        return false\n      },\n      actions: [\n        (_, params) => {\n          if (params.action === 'select') {\n            return [\n              {\n                type: 'effect',\n                effect: () => {\n                  emojiPickerActor.send({type: 'select'})\n                },\n              },\n              {\n                type: 'delete.text',\n                anchor: {\n                  path: params.focusBlock.path,\n                  offset: params.textBeforeLength - params.emojiStringLength,\n                },\n                focus: {\n                  path: params.focusBlock.path,\n                  offset: params.textBeforeLength,\n                },\n              },\n              {\n                type: 'insert.text',\n                text: params.emoji,\n              },\n            ]\n          }\n\n          if (params.action === 'navigate up') {\n            return [\n              // If we are navigating then we want to hijack the key event and\n              // turn it into a noop.\n              {\n                type: 'noop',\n              },\n              {\n                type: 'effect',\n                effect: () => {\n                  emojiPickerActor.send({type: 'navigate up'})\n                },\n              },\n            ]\n          }\n\n          if (params.action === 'navigate down') {\n            return [\n              // If we are navigating then we want to hijack the key event and\n              // turn it into a noop.\n              {\n                type: 'noop',\n              },\n              {\n                type: 'effect',\n                effect: () => {\n                  emojiPickerActor.send({type: 'navigate down'})\n                },\n              },\n            ]\n          }\n\n          return [\n            {\n              type: 'effect',\n              effect: () => {\n                emojiPickerActor.send({type: 'reset'})\n              },\n            },\n          ]\n        },\n      ],\n    }),\n    defineBehavior({\n      on: 'delete.backward',\n      guard: ({context, event}) => {\n        if (event.unit !== 'character') {\n          return false\n        }\n\n        const matches = emojiPickerActor.getSnapshot().context.matches\n\n        if (matches.length === 0) {\n          return false\n        }\n\n        const focusBlock = selectors.getFocusTextBlock({context})\n        const textBefore = selectors.getBlockTextBefore({context})\n        const emojiKeyword = textBefore\n          .slice(0, textBefore.length - 1)\n          .match(incompleteEmojiRegEx)?.[1]\n\n        if (!focusBlock || emojiKeyword === undefined) {\n          return {emojis: []}\n        }\n\n        const emojis = config.matchEmojis({keyword: emojiKeyword})\n\n        return {emojis}\n      },\n      actions: [\n        (_, params) => [\n          {\n            type: 'effect',\n            effect: () => {\n              emojiPickerActor.send({\n                type: 'emojis found',\n                matches: params.emojis,\n              })\n            },\n          },\n        ],\n      ],\n    }),\n  ]\n}\n\nfunction createEmojiPickerMachine<TEmojiSearchResult>() {\n  return setup({\n    types: {\n      context: {} as {\n        matches: Array<TEmojiSearchResult>\n        selectedIndex: number\n      },\n      events: {} as\n        | {\n            type: 'emojis found'\n            matches: Array<TEmojiSearchResult>\n          }\n        | {\n            type: 'navigate down' | 'navigate up' | 'select' | 'reset'\n          },\n    },\n    actions: {\n      'assign matches': assign({\n        matches: ({event}) => {\n          assertEvent(event, 'emojis found')\n          return event.matches\n        },\n      }),\n      'reset matches': assign({\n        matches: [],\n      }),\n      'reset selected index': assign({\n        selectedIndex: 0,\n      }),\n      'increment selected index': assign({\n        selectedIndex: ({context}) => {\n          if (context.selectedIndex === context.matches.length - 1) {\n            return 0\n          }\n          return context.selectedIndex + 1\n        },\n      }),\n      'decrement selected index': assign({\n        selectedIndex: ({context}) => {\n          if (context.selectedIndex === 0) {\n            return context.matches.length - 1\n          }\n          return context.selectedIndex - 1\n        },\n      }),\n    },\n    guards: {\n      'no matches': ({context}) => context.matches.length === 0,\n    },\n  }).createMachine({\n    id: 'emoji picker',\n    context: {\n      matches: [],\n      selectedIndex: 0,\n    },\n    initial: 'idle',\n    states: {\n      'idle': {\n        on: {\n          'emojis found': {\n            actions: 'assign matches',\n            target: 'showing matches',\n          },\n        },\n      },\n      'showing matches': {\n        always: {\n          guard: 'no matches',\n          target: 'idle',\n        },\n        exit: ['reset selected index'],\n        on: {\n          'emojis found': {\n            actions: 'assign matches',\n          },\n          'navigate down': {\n            actions: 'increment selected index',\n          },\n          'navigate up': {\n            actions: 'decrement selected index',\n          },\n          'reset': {\n            target: 'idle',\n            actions: ['reset selected index', 'reset matches'],\n          },\n          'select': {\n            target: 'idle',\n            actions: ['reset selected index', 'reset matches'],\n          },\n        },\n      },\n    },\n  })\n}\n","export function looksLikeUrl(text: string) {\n  let looksLikeUrl = false\n  try {\n    const url = new URL(text)\n\n    if (!sensibleProtocols.includes(url.protocol)) {\n      return false\n    }\n\n    looksLikeUrl = true\n  } catch {}\n  return looksLikeUrl\n}\n\nconst sensibleProtocols = ['http:', 'https:', 'mailto:', 'tel:']\n","import type {EditorSchema} from '../editor/define-schema'\nimport * as selectors from '../selectors'\nimport {looksLikeUrl} from '../utils/looks-like-url'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type LinkBehaviorsConfig = {\n  linkAnnotation?: (context: {\n    schema: EditorSchema\n    url: string\n  }) => {name: string; value: {[prop: string]: unknown}} | undefined\n}\n\n/**\n * @beta\n */\nexport function createLinkBehaviors(config: LinkBehaviorsConfig) {\n  const pasteLinkOnSelection = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const text = event.data.getData('text/plain')\n      const url = looksLikeUrl(text) ? text : undefined\n      const annotation =\n        url !== undefined\n          ? config.linkAnnotation?.({url, schema: context.schema})\n          : undefined\n\n      if (annotation && !selectionCollapsed) {\n        return {annotation}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {annotation}) => [\n        {\n          type: 'annotation.add',\n          annotation,\n        },\n      ],\n    ],\n  })\n  const pasteLinkAtCaret = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const focusSpan = selectors.getFocusSpan({context})\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n\n      if (!focusSpan || !selectionCollapsed) {\n        return false\n      }\n\n      const text = event.data.getData('text/plain')\n      const url = looksLikeUrl(text) ? text : undefined\n      const annotation =\n        url !== undefined\n          ? config.linkAnnotation?.({url, schema: context.schema})\n          : undefined\n\n      if (url && annotation && selectionCollapsed) {\n        return {focusSpan, annotation, url}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {annotation, url}) => [\n        {\n          type: 'insert.span',\n          text: url,\n          annotations: [annotation],\n        },\n      ],\n    ],\n  })\n\n  const linkBehaviors = [pasteLinkOnSelection, pasteLinkAtCaret]\n\n  return linkBehaviors\n}\n","import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\nimport {getTextBlockText} from '../editor/utils/utils'\nimport {spanSelectionPointToBlockOffset} from '../editor/utils/utils.block-offset'\nimport * as selectors from '../selectors'\nimport {getBlockTextBefore} from '../selectors/selector.get-text-before'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: (context: {\n    schema: EditorSchema\n  }) => {name: string; value?: {[prop: string]: unknown}} | undefined\n  defaultStyle?: (context: {schema: EditorSchema}) => string | undefined\n  headingStyle?: (context: {\n    schema: EditorSchema\n    level: number\n  }) => string | undefined\n  blockquoteStyle?: (context: {schema: EditorSchema}) => string | undefined\n  unorderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n  orderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n}\n\n/**\n * @beta\n */\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticBlockquoteOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const caretAtTheEndOfQuote = blockOffset.offset === 1\n      const looksLikeMarkdownQuote = /^>/.test(blockText)\n      const blockquoteStyle = config.blockquoteStyle?.(context)\n\n      if (\n        caretAtTheEndOfQuote &&\n        looksLikeMarkdownQuote &&\n        blockquoteStyle !== undefined\n      ) {\n        return {focusTextBlock, style: blockquoteStyle}\n      }\n\n      return false\n    },\n    actions: [\n      () => [\n        {\n          type: 'insert.text',\n          text: ' ',\n        },\n      ],\n      (_, {focusTextBlock, style}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: 2,\n          },\n        },\n      ],\n    ],\n  })\n  const automaticHr = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const hrCharacter =\n        event.text === '-'\n          ? '-'\n          : event.text === '*'\n            ? '*'\n            : event.text === '_'\n              ? '_'\n              : undefined\n\n      if (hrCharacter === undefined) {\n        return false\n      }\n\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusTextBlock({context})\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n\n      if (!hrObject || !focusBlock || !selectionCollapsed) {\n        return false\n      }\n\n      const textBefore = getBlockTextBefore({context})\n      const hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0,\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3,\n        },\n      }\n\n      if (textBefore === `${hrCharacter}${hrCharacter}`) {\n        return {hrObject, focusBlock, hrCharacter, hrBlockOffsets}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {hrCharacter}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacter,\n        },\n      ],\n      (_, {hrObject, hrBlockOffsets}) => [\n        {\n          type: 'insert.block object',\n          placement: 'before',\n          blockObject: hrObject,\n        },\n        {\n          type: 'delete.text',\n          ...hrBlockOffsets,\n        },\n      ],\n    ],\n  })\n  const automaticHrOnPaste = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const text = event.data.getData('text/plain')\n      const hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusBlock({context})\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacters,\n        },\n      ],\n      (_, {hrObject, focusBlock}) =>\n        isPortableTextTextBlock(focusBlock.node)\n          ? [\n              {\n                type: 'insert.text block',\n                textBlock: {children: focusBlock.node.children},\n                placement: 'after',\n              },\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n              {type: 'delete.block', blockPath: focusBlock.path},\n            ]\n          : [\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n            ],\n    ],\n  })\n  const automaticHeadingOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const markdownHeadingSearch = /^#+/.exec(blockText)\n      const level = markdownHeadingSearch\n        ? markdownHeadingSearch[0].length\n        : undefined\n      const caretAtTheEndOfHeading = blockOffset.offset === level\n\n      if (!caretAtTheEndOfHeading) {\n        return false\n      }\n\n      const style =\n        level !== undefined\n          ? config.headingStyle?.({schema: context.schema, level})\n          : undefined\n\n      if (level !== undefined && style !== undefined) {\n        return {\n          focusTextBlock,\n          style: style,\n          level,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, level}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: level + 1,\n          },\n        },\n      ],\n    ],\n  })\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({context}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.(context)\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        {\n          type: 'text block.set',\n          style: defaultStyle,\n          at: focusTextBlock.path,\n        },\n      ],\n    ],\n  })\n  const automaticListOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const defaultStyle = config.defaultStyle?.(context)\n      const looksLikeUnorderedList = /^(-|\\*)/.test(blockText)\n      const unorderedListStyle = config.unorderedListStyle?.(context)\n      const caretAtTheEndOfUnorderedList = blockOffset.offset === 1\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfUnorderedList &&\n        looksLikeUnorderedList &&\n        unorderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle,\n        }\n      }\n\n      const looksLikeOrderedList = /^1\\./.test(blockText)\n      const orderedListStyle = config.orderedListStyle?.(context)\n      const caretAtTheEndOfOrderedList = blockOffset.offset === 2\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfOrderedList &&\n        looksLikeOrderedList &&\n        orderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: orderedListStyle,\n          listItemLength: 2,\n          style: defaultStyle,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, listItem, listItemLength}) => [\n        {\n          type: 'text block.set',\n          listItem,\n          level: 1,\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: listItemLength + 1,\n          },\n        },\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [\n    automaticBlockquoteOnSpace,\n    automaticHeadingOnSpace,\n    automaticHr,\n    automaticHrOnPaste,\n    clearStyleOnBackspace,\n    automaticListOnSpace,\n  ]\n\n  return markdownBehaviors\n}\n"],"names":["createCodeEditorBehaviors","config","defineBehavior","on","guard","context","event","isMoveUpShortcut","isHotkey","moveBlockUpShortcut","keyboardEvent","firstBlock","selectors","selectedBlocks","blocksAbove","node","_key","paths","map","block","path","actions","_","at","type","isMoveDownShortcut","moveBlockDownShortcut","lastBlock","blocksBelow","length","reverse","emojiCharRegEx","incompleteEmojiRegEx","emojiRegEx","createEmojiPickerBehaviors","emojiPickerActor","createActor","createEmojiPickerMachine","start","subscribe","state","onMatchesChanged","matches","onSelectedIndexChanged","selectedIndex","text","test","emojis","focusBlock","emojiKeyword","match","undefined","matchEmojis","keyword","params","effect","send","getSnapshot","emoji","parseMatch","textBefore","emojiStringLength","textBeforeLength","anchor","offset","focus","action","isEnter","isTab","isArrowDown","isArrowUp","unit","slice","setup","types","events","assign","assertEvent","guards","no matches","createMachine","id","initial","states","target","always","exit","looksLikeUrl","url","URL","sensibleProtocols","includes","protocol","createLinkBehaviors","pasteLinkOnSelection","selectionCollapsed","data","getData","annotation","linkAnnotation","schema","pasteLinkAtCaret","focusSpan","annotations","createMarkdownBehaviors","automaticBlockquoteOnSpace","focusTextBlock","blockOffset","spanSelectionPointToBlockOffset","value","selectionPoint","selection","blockText","getTextBlockText","caretAtTheEndOfQuote","looksLikeMarkdownQuote","blockquoteStyle","style","props","automaticHr","hrCharacter","hrObject","horizontalRuleObject","getBlockTextBefore","hrBlockOffsets","placement","blockObject","automaticHrOnPaste","hrRegExp","hrCharacters","isPortableTextTextBlock","textBlock","children","blockPath","automaticHeadingOnSpace","markdownHeadingSearch","exec","level","headingStyle","clearStyleOnBackspace","atTheBeginningOfBLock","defaultStyle","automaticListOnSpace","looksLikeUnorderedList","unorderedListStyle","caretAtTheEndOfUnorderedList","listItem","listItemLength","looksLikeOrderedList","orderedListStyle","caretAtTheEndOfOrderedList"],"mappings":"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"}