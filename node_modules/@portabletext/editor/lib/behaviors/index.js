import { getFirstBlock, getSelectedBlocks, getLastBlock, getFocusTextBlock, isSelectionCollapsed, getFocusSpan, getFocusBlock } from "../_chunks-es/selector.is-selection-collapsed.js";
import { defineBehavior, isHotkey, spanSelectionPointToBlockOffset, getTextBlockText } from "../_chunks-es/behavior.core.js";
import { coreBehavior, coreBehaviors } from "../_chunks-es/behavior.core.js";
import { createActor, setup, assign, assertEvent } from "xstate";
import { getBlockTextBefore } from "../_chunks-es/selector.get-text-before.js";
import { isPortableTextTextBlock } from "@sanity/types";
function createCodeEditorBehaviors(config) {
  return [defineBehavior({
    on: "key.down",
    guard: ({
      context,
      event
    }) => {
      const isMoveUpShortcut = isHotkey(config.moveBlockUpShortcut, event.keyboardEvent), firstBlock = getFirstBlock({
        context
      }), selectedBlocks = getSelectedBlocks({
        context
      }), blocksAbove = firstBlock?.node._key !== selectedBlocks[0]?.node._key;
      return !isMoveUpShortcut || !blocksAbove ? !1 : {
        paths: selectedBlocks.map((block) => block.path)
      };
    },
    actions: [(_, {
      paths
    }) => paths.map((at) => ({
      type: "move.block up",
      at
    }))]
  }), defineBehavior({
    on: "key.down",
    guard: ({
      context,
      event
    }) => {
      const isMoveDownShortcut = isHotkey(config.moveBlockDownShortcut, event.keyboardEvent), lastBlock = getLastBlock({
        context
      }), selectedBlocks = getSelectedBlocks({
        context
      }), blocksBelow = lastBlock?.node._key !== selectedBlocks[selectedBlocks.length - 1]?.node._key;
      return !isMoveDownShortcut || !blocksBelow ? !1 : {
        paths: selectedBlocks.map((block) => block.path).reverse()
      };
    },
    actions: [(_, {
      paths
    }) => paths.map((at) => ({
      type: "move.block down",
      at
    }))]
  })];
}
const emojiCharRegEx = /^[a-zA-Z-_0-9]{1}$/, incompleteEmojiRegEx = /:([a-zA-Z-_0-9]+)$/, emojiRegEx = /:([a-zA-Z-_0-9]+):$/;
function createEmojiPickerBehaviors(config) {
  const emojiPickerActor = createActor(createEmojiPickerMachine());
  return emojiPickerActor.start(), emojiPickerActor.subscribe((state) => {
    config.onMatchesChanged({
      matches: state.context.matches
    }), config.onSelectedIndexChanged({
      selectedIndex: state.context.selectedIndex
    });
  }), [defineBehavior({
    on: "insert.text",
    guard: ({
      context,
      event
    }) => {
      if (event.text === ":")
        return !1;
      if (!emojiCharRegEx.test(event.text))
        return {
          emojis: []
        };
      const focusBlock = getFocusTextBlock({
        context
      }), emojiKeyword = `${getBlockTextBefore({
        context
      })}${event.text}`.match(incompleteEmojiRegEx)?.[1];
      return !focusBlock || emojiKeyword === void 0 ? {
        emojis: []
      } : {
        emojis: config.matchEmojis({
          keyword: emojiKeyword
        })
      };
    },
    actions: [(_, params) => [{
      type: "effect",
      effect: () => {
        emojiPickerActor.send({
          type: "emojis found",
          matches: params.emojis
        });
      }
    }]]
  }), defineBehavior({
    on: "insert.text",
    guard: ({
      context,
      event
    }) => {
      if (event.text !== ":")
        return !1;
      const matches = emojiPickerActor.getSnapshot().context.matches, selectedIndex = emojiPickerActor.getSnapshot().context.selectedIndex, emoji = matches[selectedIndex] ? config.parseMatch({
        match: matches[selectedIndex]
      }) : void 0, focusBlock = getFocusTextBlock({
        context
      }), textBefore = getBlockTextBefore({
        context
      }), emojiKeyword = `${textBefore}:`.match(emojiRegEx)?.[1];
      if (!focusBlock || emojiKeyword === void 0)
        return !1;
      const emojiStringLength = emojiKeyword.length + 2;
      return emoji ? {
        focusBlock,
        emoji,
        emojiStringLength,
        textBeforeLength: textBefore.length + 1
      } : !1;
    },
    actions: [() => [{
      type: "insert.text",
      text: ":"
    }], (_, params) => [{
      type: "effect",
      effect: () => {
        emojiPickerActor.send({
          type: "select"
        });
      }
    }, {
      type: "delete.text",
      anchor: {
        path: params.focusBlock.path,
        offset: params.textBeforeLength - params.emojiStringLength
      },
      focus: {
        path: params.focusBlock.path,
        offset: params.textBeforeLength
      }
    }, {
      type: "insert.text",
      text: params.emoji
    }]]
  }), defineBehavior({
    on: "key.down",
    guard: ({
      context,
      event
    }) => {
      const matches = emojiPickerActor.getSnapshot().context.matches;
      if (matches.length === 0)
        return !1;
      if (isHotkey("Escape", event.keyboardEvent))
        return {
          action: "reset"
        };
      const isEnter = isHotkey("Enter", event.keyboardEvent), isTab = isHotkey("Tab", event.keyboardEvent);
      if (isEnter || isTab) {
        const selectedIndex = emojiPickerActor.getSnapshot().context.selectedIndex, emoji = matches[selectedIndex] ? config.parseMatch({
          match: matches[selectedIndex]
        }) : void 0;
        if (!emoji)
          return !1;
        const focusBlock = getFocusTextBlock({
          context
        }), textBefore = getBlockTextBefore({
          context
        }), emojiKeyword = textBefore.match(incompleteEmojiRegEx)?.[1];
        if (!focusBlock || emojiKeyword === void 0)
          return !1;
        const emojiStringLength = emojiKeyword.length + 1;
        return emoji ? {
          action: "select",
          focusBlock,
          emoji,
          emojiStringLength,
          textBeforeLength: textBefore.length
        } : !1;
      }
      const isArrowDown = isHotkey("ArrowDown", event.keyboardEvent), isArrowUp = isHotkey("ArrowUp", event.keyboardEvent);
      return isArrowDown && matches.length > 0 ? {
        action: "navigate down"
      } : isArrowUp && matches.length > 0 ? {
        action: "navigate up"
      } : !1;
    },
    actions: [(_, params) => params.action === "select" ? [{
      type: "effect",
      effect: () => {
        emojiPickerActor.send({
          type: "select"
        });
      }
    }, {
      type: "delete.text",
      anchor: {
        path: params.focusBlock.path,
        offset: params.textBeforeLength - params.emojiStringLength
      },
      focus: {
        path: params.focusBlock.path,
        offset: params.textBeforeLength
      }
    }, {
      type: "insert.text",
      text: params.emoji
    }] : params.action === "navigate up" ? [
      // If we are navigating then we want to hijack the key event and
      // turn it into a noop.
      {
        type: "noop"
      },
      {
        type: "effect",
        effect: () => {
          emojiPickerActor.send({
            type: "navigate up"
          });
        }
      }
    ] : params.action === "navigate down" ? [
      // If we are navigating then we want to hijack the key event and
      // turn it into a noop.
      {
        type: "noop"
      },
      {
        type: "effect",
        effect: () => {
          emojiPickerActor.send({
            type: "navigate down"
          });
        }
      }
    ] : [{
      type: "effect",
      effect: () => {
        emojiPickerActor.send({
          type: "reset"
        });
      }
    }]]
  }), defineBehavior({
    on: "delete.backward",
    guard: ({
      context,
      event
    }) => {
      if (event.unit !== "character" || emojiPickerActor.getSnapshot().context.matches.length === 0)
        return !1;
      const focusBlock = getFocusTextBlock({
        context
      }), textBefore = getBlockTextBefore({
        context
      }), emojiKeyword = textBefore.slice(0, textBefore.length - 1).match(incompleteEmojiRegEx)?.[1];
      return !focusBlock || emojiKeyword === void 0 ? {
        emojis: []
      } : {
        emojis: config.matchEmojis({
          keyword: emojiKeyword
        })
      };
    },
    actions: [(_, params) => [{
      type: "effect",
      effect: () => {
        emojiPickerActor.send({
          type: "emojis found",
          matches: params.emojis
        });
      }
    }]]
  })];
}
function createEmojiPickerMachine() {
  return setup({
    types: {
      context: {},
      events: {}
    },
    actions: {
      "assign matches": assign({
        matches: ({
          event
        }) => (assertEvent(event, "emojis found"), event.matches)
      }),
      "reset matches": assign({
        matches: []
      }),
      "reset selected index": assign({
        selectedIndex: 0
      }),
      "increment selected index": assign({
        selectedIndex: ({
          context
        }) => context.selectedIndex === context.matches.length - 1 ? 0 : context.selectedIndex + 1
      }),
      "decrement selected index": assign({
        selectedIndex: ({
          context
        }) => context.selectedIndex === 0 ? context.matches.length - 1 : context.selectedIndex - 1
      })
    },
    guards: {
      "no matches": ({
        context
      }) => context.matches.length === 0
    }
  }).createMachine({
    id: "emoji picker",
    context: {
      matches: [],
      selectedIndex: 0
    },
    initial: "idle",
    states: {
      idle: {
        on: {
          "emojis found": {
            actions: "assign matches",
            target: "showing matches"
          }
        }
      },
      "showing matches": {
        always: {
          guard: "no matches",
          target: "idle"
        },
        exit: ["reset selected index"],
        on: {
          "emojis found": {
            actions: "assign matches"
          },
          "navigate down": {
            actions: "increment selected index"
          },
          "navigate up": {
            actions: "decrement selected index"
          },
          reset: {
            target: "idle",
            actions: ["reset selected index", "reset matches"]
          },
          select: {
            target: "idle",
            actions: ["reset selected index", "reset matches"]
          }
        }
      }
    }
  });
}
function looksLikeUrl(text) {
  let looksLikeUrl2 = !1;
  try {
    const url = new URL(text);
    if (!sensibleProtocols.includes(url.protocol))
      return !1;
    looksLikeUrl2 = !0;
  } catch {
  }
  return looksLikeUrl2;
}
const sensibleProtocols = ["http:", "https:", "mailto:", "tel:"];
function createLinkBehaviors(config) {
  const pasteLinkOnSelection = defineBehavior({
    on: "paste",
    guard: ({
      context,
      event
    }) => {
      const selectionCollapsed = isSelectionCollapsed({
        context
      }), text = event.data.getData("text/plain"), url = looksLikeUrl(text) ? text : void 0, annotation = url !== void 0 ? config.linkAnnotation?.({
        url,
        schema: context.schema
      }) : void 0;
      return annotation && !selectionCollapsed ? {
        annotation
      } : !1;
    },
    actions: [(_, {
      annotation
    }) => [{
      type: "annotation.add",
      annotation
    }]]
  }), pasteLinkAtCaret = defineBehavior({
    on: "paste",
    guard: ({
      context,
      event
    }) => {
      const focusSpan = getFocusSpan({
        context
      }), selectionCollapsed = isSelectionCollapsed({
        context
      });
      if (!focusSpan || !selectionCollapsed)
        return !1;
      const text = event.data.getData("text/plain"), url = looksLikeUrl(text) ? text : void 0, annotation = url !== void 0 ? config.linkAnnotation?.({
        url,
        schema: context.schema
      }) : void 0;
      return url && annotation && selectionCollapsed ? {
        focusSpan,
        annotation,
        url
      } : !1;
    },
    actions: [(_, {
      annotation,
      url
    }) => [{
      type: "insert.span",
      text: url,
      annotations: [annotation]
    }]]
  });
  return [pasteLinkOnSelection, pasteLinkAtCaret];
}
function createMarkdownBehaviors(config) {
  const automaticBlockquoteOnSpace = defineBehavior({
    on: "insert.text",
    guard: ({
      context,
      event
    }) => {
      if (event.text !== " ")
        return !1;
      const selectionCollapsed = isSelectionCollapsed({
        context
      }), focusTextBlock = getFocusTextBlock({
        context
      }), focusSpan = getFocusSpan({
        context
      });
      if (!selectionCollapsed || !focusTextBlock || !focusSpan)
        return !1;
      const blockOffset = spanSelectionPointToBlockOffset({
        value: context.value,
        selectionPoint: {
          path: [{
            _key: focusTextBlock.node._key
          }, "children", {
            _key: focusSpan.node._key
          }],
          offset: context.selection?.focus.offset ?? 0
        }
      });
      if (!blockOffset)
        return !1;
      const blockText = getTextBlockText(focusTextBlock.node), caretAtTheEndOfQuote = blockOffset.offset === 1, looksLikeMarkdownQuote = /^>/.test(blockText), blockquoteStyle = config.blockquoteStyle?.(context);
      return caretAtTheEndOfQuote && looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {
        focusTextBlock,
        style: blockquoteStyle
      } : !1;
    },
    actions: [() => [{
      type: "insert.text",
      text: " "
    }], (_, {
      focusTextBlock,
      style
    }) => [{
      type: "text block.unset",
      props: ["listItem", "level"],
      at: focusTextBlock.path
    }, {
      type: "text block.set",
      style,
      at: focusTextBlock.path
    }, {
      type: "delete.text",
      anchor: {
        path: focusTextBlock.path,
        offset: 0
      },
      focus: {
        path: focusTextBlock.path,
        offset: 2
      }
    }]]
  }), automaticHr = defineBehavior({
    on: "insert.text",
    guard: ({
      context,
      event
    }) => {
      const hrCharacter = event.text === "-" ? "-" : event.text === "*" ? "*" : event.text === "_" ? "_" : void 0;
      if (hrCharacter === void 0)
        return !1;
      const hrObject = config.horizontalRuleObject?.(context), focusBlock = getFocusTextBlock({
        context
      }), selectionCollapsed = isSelectionCollapsed({
        context
      });
      if (!hrObject || !focusBlock || !selectionCollapsed)
        return !1;
      const textBefore = getBlockTextBefore({
        context
      }), hrBlockOffsets = {
        anchor: {
          path: focusBlock.path,
          offset: 0
        },
        focus: {
          path: focusBlock.path,
          offset: 3
        }
      };
      return textBefore === `${hrCharacter}${hrCharacter}` ? {
        hrObject,
        focusBlock,
        hrCharacter,
        hrBlockOffsets
      } : !1;
    },
    actions: [(_, {
      hrCharacter
    }) => [{
      type: "insert.text",
      text: hrCharacter
    }], (_, {
      hrObject,
      hrBlockOffsets
    }) => [{
      type: "insert.block object",
      placement: "before",
      blockObject: hrObject
    }, {
      type: "delete.text",
      ...hrBlockOffsets
    }]]
  }), automaticHrOnPaste = defineBehavior({
    on: "paste",
    guard: ({
      context,
      event
    }) => {
      const text = event.data.getData("text/plain"), hrRegExp = /^(---)$|(___)$|(\*\*\*)$/gm, hrCharacters = text.match(hrRegExp)?.[0], hrObject = config.horizontalRuleObject?.(context), focusBlock = getFocusBlock({
        context
      });
      return !hrCharacters || !hrObject || !focusBlock ? !1 : {
        hrCharacters,
        hrObject,
        focusBlock
      };
    },
    actions: [(_, {
      hrCharacters
    }) => [{
      type: "insert.text",
      text: hrCharacters
    }], (_, {
      hrObject,
      focusBlock
    }) => isPortableTextTextBlock(focusBlock.node) ? [{
      type: "insert.text block",
      textBlock: {
        children: focusBlock.node.children
      },
      placement: "after"
    }, {
      type: "insert.block object",
      blockObject: hrObject,
      placement: "after"
    }, {
      type: "delete.block",
      blockPath: focusBlock.path
    }] : [{
      type: "insert.block object",
      blockObject: hrObject,
      placement: "after"
    }]]
  }), automaticHeadingOnSpace = defineBehavior({
    on: "insert.text",
    guard: ({
      context,
      event
    }) => {
      if (event.text !== " ")
        return !1;
      const selectionCollapsed = isSelectionCollapsed({
        context
      }), focusTextBlock = getFocusTextBlock({
        context
      }), focusSpan = getFocusSpan({
        context
      });
      if (!selectionCollapsed || !focusTextBlock || !focusSpan)
        return !1;
      const blockOffset = spanSelectionPointToBlockOffset({
        value: context.value,
        selectionPoint: {
          path: [{
            _key: focusTextBlock.node._key
          }, "children", {
            _key: focusSpan.node._key
          }],
          offset: context.selection?.focus.offset ?? 0
        }
      });
      if (!blockOffset)
        return !1;
      const blockText = getTextBlockText(focusTextBlock.node), markdownHeadingSearch = /^#+/.exec(blockText), level = markdownHeadingSearch ? markdownHeadingSearch[0].length : void 0;
      if (blockOffset.offset !== level)
        return !1;
      const style = level !== void 0 ? config.headingStyle?.({
        schema: context.schema,
        level
      }) : void 0;
      return level !== void 0 && style !== void 0 ? {
        focusTextBlock,
        style,
        level
      } : !1;
    },
    actions: [({
      event
    }) => [event], (_, {
      focusTextBlock,
      style,
      level
    }) => [{
      type: "text block.unset",
      props: ["listItem", "level"],
      at: focusTextBlock.path
    }, {
      type: "text block.set",
      style,
      at: focusTextBlock.path
    }, {
      type: "delete.text",
      anchor: {
        path: focusTextBlock.path,
        offset: 0
      },
      focus: {
        path: focusTextBlock.path,
        offset: level + 1
      }
    }]]
  }), clearStyleOnBackspace = defineBehavior({
    on: "delete.backward",
    guard: ({
      context
    }) => {
      const selectionCollapsed = isSelectionCollapsed({
        context
      }), focusTextBlock = getFocusTextBlock({
        context
      }), focusSpan = getFocusSpan({
        context
      });
      if (!selectionCollapsed || !focusTextBlock || !focusSpan)
        return !1;
      const atTheBeginningOfBLock = focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0, defaultStyle = config.defaultStyle?.(context);
      return atTheBeginningOfBLock && defaultStyle && focusTextBlock.node.style !== defaultStyle ? {
        defaultStyle,
        focusTextBlock
      } : !1;
    },
    actions: [(_, {
      defaultStyle,
      focusTextBlock
    }) => [{
      type: "text block.set",
      style: defaultStyle,
      at: focusTextBlock.path
    }]]
  }), automaticListOnSpace = defineBehavior({
    on: "insert.text",
    guard: ({
      context,
      event
    }) => {
      if (event.text !== " ")
        return !1;
      const selectionCollapsed = isSelectionCollapsed({
        context
      }), focusTextBlock = getFocusTextBlock({
        context
      }), focusSpan = getFocusSpan({
        context
      });
      if (!selectionCollapsed || !focusTextBlock || !focusSpan)
        return !1;
      const blockOffset = spanSelectionPointToBlockOffset({
        value: context.value,
        selectionPoint: {
          path: [{
            _key: focusTextBlock.node._key
          }, "children", {
            _key: focusSpan.node._key
          }],
          offset: context.selection?.focus.offset ?? 0
        }
      });
      if (!blockOffset)
        return !1;
      const blockText = getTextBlockText(focusTextBlock.node), defaultStyle = config.defaultStyle?.(context), looksLikeUnorderedList = /^(-|\*)/.test(blockText), unorderedListStyle = config.unorderedListStyle?.(context), caretAtTheEndOfUnorderedList = blockOffset.offset === 1;
      if (defaultStyle && caretAtTheEndOfUnorderedList && looksLikeUnorderedList && unorderedListStyle !== void 0)
        return {
          focusTextBlock,
          listItem: unorderedListStyle,
          listItemLength: 1,
          style: defaultStyle
        };
      const looksLikeOrderedList = /^1\./.test(blockText), orderedListStyle = config.orderedListStyle?.(context), caretAtTheEndOfOrderedList = blockOffset.offset === 2;
      return defaultStyle && caretAtTheEndOfOrderedList && looksLikeOrderedList && orderedListStyle !== void 0 ? {
        focusTextBlock,
        listItem: orderedListStyle,
        listItemLength: 2,
        style: defaultStyle
      } : !1;
    },
    actions: [({
      event
    }) => [event], (_, {
      focusTextBlock,
      style,
      listItem,
      listItemLength
    }) => [{
      type: "text block.set",
      listItem,
      level: 1,
      style,
      at: focusTextBlock.path
    }, {
      type: "delete.text",
      anchor: {
        path: focusTextBlock.path,
        offset: 0
      },
      focus: {
        path: focusTextBlock.path,
        offset: listItemLength + 1
      }
    }]]
  });
  return [automaticBlockquoteOnSpace, automaticHeadingOnSpace, automaticHr, automaticHrOnPaste, clearStyleOnBackspace, automaticListOnSpace];
}
export {
  coreBehavior,
  coreBehaviors,
  createCodeEditorBehaviors,
  createEmojiPickerBehaviors,
  createLinkBehaviors,
  createMarkdownBehaviors,
  defineBehavior
};
//# sourceMappingURL=index.js.map
